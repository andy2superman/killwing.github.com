<!DOCTYPE html>
<html>
<title>C++ Coding Standards</title>
<xmp theme="readable" style="display:none;">
## 组织和策略问题
### 0.不要拘泥于小节（又名：了解哪些东西不应该标准化）
**只规定需要规定的事情：不要强制施加个人喜好或者过时的做法。**

* 应该在每个源文件乃至每个项目中都使用一致的格式，因为同一段代码中要在几种编程风格（style）之间换来换去是很不舒服的。但是无需在多个项目或者整个公司范围内强制实施一致的格式。
    * 不要规定缩进多少，应该规定要用缩进来体现代码的结构。
    * 不要强制行的具体长度，应该保证代码行的长度有利于阅读。
    * 不要在命名方面规定过多，应该规定的是使用一致的命名规范。
        * 永远不要使用“晦涩的名称”，即以下划线开始或者包含双下划线的名称；
        * 总是使用形如ONLY_UPPERCASE_NAMES的全大写字母表示宏，不要考虑使用常见的词或者缩略语作为宏的名称（包括常见的模板参数，比如T和U；像`#define T anything`这样的代码是极容易混淆的）。
* 不要规定注释体例（除非需要使用工具从特定的体例中提取出文档），应该编写有用的注释。
* 不要尝试强制实施陈旧的规则，即使它们曾经在一些比较陈旧的编程规范中出现过。
    * 任何C++编程规范都不应该要求使用匈牙利记法。
    * 单入口，单出口对于支持异常和析构函数的语言而言已经过时了。

### 1.在高警告级别干净利落地进行编译
**高度重视警告：使用编译器的最高警告级别。应该要求构建是干净利落的（没有警告）。理解所有的警告。通过修改代码而不是降低警告级别来排除警告。**

* 对于无法修改的库文件的警告，可以用自己的头文件wrap起来，并为该作用域关闭警告。
* 未使用的函数参数，注释掉。
* 定义了从未使用过的变量，可以通过插入一个变量本身的求值表达式来去除警告。
* 使用未初始化的变量，初始化。
* 对没有return的不会走到的分支，加上assert(false)再return。
* 有符号数无符号数不匹配，改变所操作的变量的类型。

EX: 对无益警告，单独禁用这个警告，但是要尽可能在局部禁用，并且编写一个清晰的注释，说明为什么必须禁用。

### 2.使用自动构建系统
**一次按键就解决问题：使用完全自动化（“单操作”）的构建系统，无需用户干预即可构建整个项目。**


### 3.使用版本控制系统
**好记性不如烂笔头（中国谚语）：请使用版本控制系统（version control system，CVS）。永远不要让文件长时间地登出。在新的单元测试通过之后，应该频繁登入。确保登入的代码不会影响构建成功。**

* 版本控制系统中的代码必须总能构建成功。

EX: 一个程序员只要一周的项目。

### 4.在代码审查上投入
**审查代码：更多的关注有助于提高质量。亮出自己的代码，阅读别人的代码。互相学习，彼此都会受益。**

* 无需形式主义，一封简单的电子邮件就足够了。

## 设计风格
### 5.一个实体应该只有一个紧凑的职责
**一次只解决一个问题：只给一个实体（变量、类、函数、名称空间、模块和库）赋予一个定义良好的职责。随着实体变大，其职责范围自然也会扩大，但是职责不应该发散。**

* 应该用较小的底层抽象构建更高层次的抽象。要避免将几个低层次抽象集合成一个较大的低层次抽象聚合体。

### 6.正确、简单和清晰第一
**软件简单为美（Keep It Simple Software，KISS）：正确优于速度。简单优于复杂。清晰优于机巧。安全优于不安全（见第83条和第99条）。**

* 简单设计和清晰代码的价值怎么强调都不过分。
* 不要使用不必要的或者小聪明式的操作符重载。
* 应该使用命名变量，而不要使用临时变量，作为构造函数的参数。

### 7.编程中应知道何时和如何考虑可伸缩性
**小心数据的爆炸性增长：不要进行不成熟的优化，但是要密切关注渐近复杂性。处理用户数据的算法对所处理的数据量耗费的时间应该是可预测的，最好不差于线性关系。如果能够证明优化必要而且非常重要，尤其在数据量逐渐增长的情况下，那么应该集中精力改善算法的O(N)复杂性，而不是进行小型的优化，比如节省一个多余的加法运算。**

* 要尽可能优先使用线性（或者更好的）算法。尽可能合理地避免使用比线性算法差的多项式算法。竭力避免使用指数算法。

### 8.不要进行不成熟的优化
**拉丁谚语云，快马无需鞭策：不成熟优化的诱惑非常大，而它的无效性也同样严重。优化的第一原则就是：不要优化。优化的第二原则（仅适用于专家）是：还是不要优化。再三测试，而后优化。**

* 通过引用传递，优先调用前缀形式的++和--，和使用很自然地从指尖流出的惯用法，都不属于不成熟的优化。

EX: 在编写程序库的时候，预测哪些操作最后会用于性能敏感的代码中更加困难，但要先进行性能测试。

### 9.不要进行不成熟的劣化
**放松自己，轻松编程：在所有其他事情特别是代码复杂性和可读性都相同的情况下，一些高效的设计模式和编程惯用法会从你的指尖自然流出，而且不会比悲观的替代方案更难写。这并不是不成熟的优化，而是避免不必要的劣化（pessimization）。**

* 避免不成熟的优化并不意味着必然损害性能。所谓不成熟的劣化一词，我们指的就是编写如下这些没有必要的、可能比较低效的程序：
    * 在可以用通过引用传递的时候，却定义了通过值传递的参数（见第25条）。
    * 在使用前缀 ++ 操作符很合适的场合，却使用后缀版本（见第28条）。
    * 在构造函数中使用赋值操作而不是初始化列表（见第48条）
* 构造既清晰又有效的程序有两种重要的方式：使用抽象和库。

### 10.尽量减少全局和共享数据
**共享会导致冲突：避免共享数据，尤其是全局数据。共享数据会增加耦合度，从而降低可维护性，通常还会降低性能。**

* 为“无共享”而奋斗吧，用通信方式（比如消息队列）代替数据共享。

EX: 跨线程共享对象的代码应该总是将对这些共享对象的所有访问序列化。

### 11.隐藏信息
**不要泄密：不要公开提供抽象的实体的内部信息。**

* 为了尽量减少操作抽象的调用代码和抽象的实现之间的依赖性，必须隐藏实现内部的数据。否则，调用代码就能够访问——或者更糟，操作——该信息，而原本应属于内部的信息就泄漏给了调用代码所依赖的抽象。
* 应该公开抽象（如果有的话，还是公开领域抽象更好，但至少应该是get/set 抽象），而不是数据。

EX: 测试代码的白箱访问，不提供任何抽象的struct。

### 12.懂得何时和如何进行并发性编程
**线程安全地: 如果应用程序使用了多个线程或者进程，应该知道如何尽量减少共享对象（见第10条），以及如何安全地共享必须共享的对象。**

* 如果应用程序需要跨线程共享数据：
    * 参考目标平台的文档，了解该平台的同步化原语。
    * 最好将平台的原语用自己设计的抽象包装起来。
    * 确保正在使用的类型在多线程程序中使用是安全的：
        * 保证非共享的对象独立：两个线程能够自由地使用不同的对象，无需调用者的任何特殊操作。
        * 记载调用者在不同线程中使用该类型的同一个对象需要做什么：
* 编写可用于多线程程序的类型时的选择：
    * 外部加锁：调用者负责加锁。
    * 内部加锁：每个对象将所有对自己的访问串行化，通常采用为每个公用成员函数加锁的方法来实现，这样调用者就可以不用串行化对象的使用了。需要注意，只有在知道了以下两件事情之后这个选项才适用。
        * 必须事先知道该类型的对象几乎总是要被跨线程共享的，否则到头来只不过进行了无效加锁。
        * 必须事先知道成员函数级加锁的粒度是合适的，而且能满足大多数调用者的需要。
    * 不加锁的设计，包括不变性（只读对象）：无需加锁。
* 在获取多个锁时，通过安排所有获取同样的锁的代码以相同的顺序获取锁，可以避免死锁。（释放锁可以按照任意顺序进行。）

### 13.确保资源为对象所拥有。使用显式的RAII和智能指针
**利器在手，不要再徒手为之：C++的“资源获取即初始化”（resource acquisition is initialization，RAII）惯用法是正确处理资源的利器。RAII使编译器能够提供强大且自动的保证，这在其他语言中可是需要脆弱的手工编写的惯用法才能实现的。分配原始资源的时候，应该立即将其传递给属主对象。永远不要在一条语句中分配一个以上的资源。 **

* 在实现RAII时，要小心复制构造和赋值。
* 每次都应该马上将分配的资源赋予管理对象，否则，就可能泄漏资源。解决：绝对不要在一条语句中分配一个以上的资源。

EX: 智能指针可能会被过度使用。


## 编程风格
### 14.宁要编译时和连接时错误，也不要运行时错误
**能够在编译时做的事情，就不要推迟到运行时：编写代码时，应该在编译期间使用编译器检查不变式（invariant），而不应该在运行时再进行检查。运行时检查取决于控制流和数据的具体情况，这意味着很难知道检查是否彻底。相比而言，编译时检查与控制流和数据无关，一般情况下能够获得更高的可信度。**

* 使用静态检查功能可以带来下列好处：
    * 静态检查与数据和控制流无关。
    * 静态表示的模型更加可靠。
    * 静态检查不会带来运行时开销。
* 用编译时检查代替运行时检查：
    * 编译时bool条件。
    * 编译时多态。
    * 枚举。
    * 向下强制。

EX: 运行时用断言检查内部编程错误，其它错误遵循“错误处理与异常”部分。

### 15.积极使用const
**const是我们的朋友：不变的值更易于理解、跟踪和分析，所以应该尽可能地使用常量代替变量，定义值的时候，应该把const作为默认的选项：常量很安全，在编译时会对其进行检查（见第14条），而且它与C++的类型系统已浑然一体。不要强制转换const的类型，除非要调用常量不正确的函数（见第94条）。**

* 当类的const成员函数需要合法地修改成员变量时，声明该成员变量为mutable的。
* 不要强制转换const，除非要调用常量不正确的函数。

### 16.避免使用宏
**实不相瞒：宏是C和C++语言的抽象设施中最生硬的工具，它是披着函数外衣的饥饿的狼，很难驯服，它会我行我素地游走于各处。要避免使用宏。**

* C++的宏的主要问题在于，它们表面上看起来很好，而实际上做的却是另一回事。宏会忽略作用域，忽略类型系统，忽略所有其他的语言特性和规则，而且会劫持它为文件其余部分所定义（#define）的符号。

EX: 宏仍然是几个重要任务的惟一解决方案，比如#include保护符（guard）（见第24条），条件编译中的#ifdef和#if defined，以及assert的实现（见第68条）。在条件编译（如与系统有关的部分）中，要避免在代码中到处杂乱地插入#ifdef。相反，应该对代码进行组织，利用宏来驱动一个公共接口的多个实现，然后始终使用该接口。如果不想到处复制和粘贴代码段，那么可以使用宏（但要非常小心）。

### 17.避免使用“魔数”
**程序设计并非魔术，所以不要故弄玄虚：要避免在代码中使用诸如42和3.14159这样的文字常量。它们本身没有提供任何说明，并且因为增加了难于检测的重复而使维护更加复杂。可以用符号名称和表达式替换它们，比如`width * aspectRatio`。**


### 18.尽可能局部地声明变量
**避免作用域膨胀，对于需求如此，对于变量也是如此。变量将引入状态，而我们应该尽可能少地处理状态，变量的生存周期也是越短越好。这是第10条的一个特例，但值得单独阐述。**

* 变量的生存期超过必需的长度时会产生以下几个缺点：
    * 它们会使程序更难以理解和维护。
    * 它们的名字会污染上下文。
    * 它们不能总是被合理地初始化。
* 解决方案很简单：尽可能局部地定义每个变量，通常就是在你有了足够的数据进行初始化的时候，而且恰恰就在首次使用变量之前。

EX: 有时候将变量提出循环是有好处的（见第9条）。因为常量并不添加状态，所以本条对常量不适用（见第17条）。

### 19.总是初始化变量
**一切从白纸开始：未初始化的变量是C和C++程序中错误的常见来源。养成在使用内存之前先清除的习惯，可以避免这种错误，在定义变量的时候就将其初始化。**

EX: 硬件或者其他进程直接写入的输入缓冲区数据和volatile型数据不需要程序对其进行初始化。

### 20.避免函数过长，避免嵌套过深
**短胜于长，平优于深：过长的函数和嵌套过深的代码块的出现，经常是因为没能赋予一个函数以一个紧凑的职责所致（见第5条），这两种情况通常都能够通过更好的重构予以解决。**

* 请遵循这样的常识和常理：限制函数的长度和嵌套深度。以下所有的合理建议对这一点都有所裨益：
    * 尽量紧凑：对一个函数只赋予一种职责（见第5条）。
    * 不要自我重复：优先使用命名函数，而不要让相似的代码片断反复出现。
    * 优先使用&&：在可以使用&&条件判断的地方要避免使用连续嵌套的if。
    * 不要过分使用try：优先使用析构函数进行自动清除而避免使用try代码块（见第13条）。
    * 优先使用标准算法：算法比循环嵌套要少，通常也更好（见第84条）。
    * 不要根据类型标签（type tag）进行分支（switch）。优先使用多态函数（见第90条）。

EX: 如果一个函数的功能无法合理地重构为多个独立的子任务（因为任何重构尝试都需要传递许多局部变量和上下文，使重构结果的可读性非但不好，反而更差），那么它的较长和嵌套较多就是合理的。但是如果有几个这样的函数都具有相似的参数，那么它们就有可能成为一个新类的成员。

### 21.避免跨编译单元的初始化依赖
**保持（初始化）顺序：不同编译单元中的名字空间级对象决不应该在初始化上互相依赖，因为其初始化顺序是未定义的。这样做会惹出很多麻烦，轻则在项目中稍做修改就会引发奇怪的崩溃，重则出现严重的不可移植问题——即使是同一编译器的新版本也不行。**

* Singleton本质上也是全局变量 - 披着羊皮的“狼”（另见第10条），它会因为相互依赖或者循环依赖而被破坏（同样，零初始化只会使情况更复杂）。

### 22.尽量减少定义性依赖。避免循环依赖
**不要过分依赖：如果用前向声明（forward declaration）能够实现，那么就不要包含（#include）定义。
不要互相依赖：循环依赖是指两个模块直接或者间接地互相依赖。所谓模块就是一个紧凑的发布单元（见“名字空间与模块”部分的引言部分）。互相依赖的多个模块并不是真正的独立模块，而是紧紧胶着在一起的一个更大的模块，一个更大的发布单元。因此，循环依赖有碍于模块性，是大型项目的祸根。请避免循环依赖。**

* 为了打破循环，可以应用依赖倒置原则（DIP）：不要让高层模块依赖于低层模块；相反，应该让两者都依赖于抽象。

EX: 类之间的循环依赖并不一定都是坏事 - 只要类被认为属于同一模块，一起测试，一起发布。

### 23.头文件应该自给自足
**各司其责：应该确保所编写的每个头文件都能够独自进行编译，为此需要包含其内容所依赖的所有头文件。**


### 24.总是编写内部#include保护符，决不要编写外部#include保护符
**为头（文件）添加保护：在所有头文件中使用带有惟一名称的包含保护符（#include guard）防止无意的多次包含。**

* 应该用内部包含保护符保护每个头文件，以避免在多次包含时重新定义。
* 定义包含保护符时，应该遵守如下规则：
    * 保护符使用惟一名称。
    * 不要自作聪明：不要在受保护部分的前后放置代码或者注释。
* 避免使用一些比较老的书中所提倡的已经过时了的外部包含保护符：

EX: 在一些非常罕见的情况下，可能需要多次包含一个头文件。


## 函数与操作符
### 25.正确地选择通过值、（智能）指针或者引用传递参数
**正确选择参数：分清输入参数、输出参数和输入/输出参数，分清值参数和引用参数。正确的传递参数。**

* 选择参数的准则：对只输入参数:
    * 始终用const限制所有指向只输入参数的指针和引用
    * 优先通过值来取得原始类型和复制开销比较低的值对象的输入。
    * 优先按const的引用取得其他用户定义类型的输入。
    * 如果函数需要其参数的副本，则可以考虑通过值传递代替通过引用传递。
* 对输出参数或者输入/输出参数：
    * 如果参数是可选的或者函数需要保存这个指针的副本或者操控参数的所有权，那么应该优先通过（智能）指针传递。
    * 如果参数是必须的，而且函数无需保存指向参数的指针或者无需操控参数的所有权，则应该优先通过引用传递。

### 26.保持重载操作符的自然语义
**程序员讨厌以外情况：只有在有充分理由时才重载操作符，而且应该保持其自然语义；如果做到这一点很困难，那么你可能已经误用了操作符重载。**

EX: 专门的程序库为操作符定义了特定领域的规范，与C++语义迥异。

### 27.优先使用算术操作符和赋值操作符的标准形式
**如果要定义a＋b，也应该定义a+=b：在定义二元算术操作符时，也应该提供操作符的赋值形式，并且应该尽量减少重复，提高效率。**

* 用@=来定义@。
* 应将所有非成员操作符放入像T这样的同一个名字空间下。
* 一种变体是让operator@通过值接受其第一个参数。
* 另一种变体是让operator@返回一个const值。

EX: 在一些情况下（比如操作于复数的operator\*=），操作符可能要显著地改变其左参数，此时用operator\*实现operator\*=可能会比反过来更有利。

### 28.优先使用++和- -的标准形式。优先调用前缀形式
**如果定义++c，也要定义c++：递增和递减操作符很麻烦，因为它们都有前缀和后缀形式，而两种形式语义又略有不同。定义operator++和operator--时，应该模仿它们对应的内置操作符。如果不需要原值，应该优先调用前缀版本。**

* 应该用前缀形式实现后缀形式。

EX: 表达模板框架将通过不同的方式保持语义。

### 29.考虑重载以避免隐含类型转换
**如无必要勿增对象（奥卡姆剃刀原理）：隐式类型转换提供了语法上的便利（但另见第40条），但是如果创建临时对象的工作并不必要而且适于优化（见第8条），那么可以提供签名与常见参数类型精确匹配的重载函数，而且不会导致转换。**


### 30.避免重载&&、||或 ,（逗号）
**明知就是知道何时应该适可而止：内置的&&，||和，得到了编译器的特殊照顾。如果重载它们，它们就会变成普通函数，具有完全不同的语义（违反第26条和第30条），这肯定会引入微妙的错误和缺陷。不要轻率地重载这些操作符。**

* 主要原因：无法在三种情况下实现内置操作符的完整语义。
* 内置逗号保证其表达式是从左到右求值的。

EX: 表达式模板库是个例外。

### 31.不要编写依赖于函数参数求值顺序的代码
**保持（求值）顺序：函数参数的求职顺序是不确定的，因此不要依赖具体的顺序。**



## 类的设计与继承
### 32.弄清所要编写的是哪种类
**了解自我：有很多种不同的类。弄清楚要编写的是哪一种。**


### 33.用小类代替巨类
**分而治之：小类更易于编写，更易于保证正确，测试和使用，更有可能适用于各种不同的情况。应该用小类体现简单概念，不要用大杂烩式的类，它们要实现的概念既多又复杂（见第5，6条）。**


### 34.用组合代替继承
**避免继承带来的重负：继承是C++中第二紧密的耦合关系，仅次于友元关系。紧密的耦合是一种不良现象，应该尽量避免。因此，应该用组合代替继承，除非知道后者确实对设计有好处。**

* 组合是指在一个类型中嵌入另一个类型的成员变量。用这种方式能够保存和使用对象，还能控制耦合强度。

EX: 使用公用继承模仿可替换性（见第37条）。非公用的继承。

### 35.避免从并非要设计成基类的类中继承
**有些人并不想生孩子：本意是要独立使用的类所遵守的设计蓝图与基类不同（见第32条）。将独立类用作基类是一种严重的设计错误，应该避免。要添加行为，应该添加非成员函数而不是成员函数（见第44条）。要添加状态，应该使用组合而不是继承（见第34条）。要避免从具体的基类中继承。**

* 应该通过新的非成员函数来添加新功能。为了避免名字查找问题，一定要将这些函数与要扩展的类型放到同一个名字空间中。
* 用组合代替公用继承或者私有继承。

### 36.优先提供抽象接口
**偏爱抽象艺术吧：抽象接口有助于我们集中精力保证抽象的正确性，不至于受到实现或者状态管理细节的干扰。优先采用实现了（建模抽象概念的）抽象接口的设计层次结构。**

* 遵守依赖倒置原理DIP。

EX: 空基类优化是一个纯粹为了优化而使用继承的实例。基于策略的设计使用的是静态多态。

### 37.公用继承即可替换性。继承，不是为了重用，而是为了被重用
**知其然：公用继承能够使基类的指针或者引用实际指向某个派生类的对象，既不会破坏代码的正确性，也不需要改变已有代码。
还要知其所以然：不要通过公用继承重用（基类中的已有）代码，公用继承是为了被（已经多态地使用了基类对象的已有代码）重用的。**

* 公有继承的目的并不是为了派生类重用基类的代码，从而用基类的代码实现自己。这种“用...来实现”的关系可能完全没有问题，但是应该用组合关系来建模 - 或者仅仅在某些特殊的情况下，通过非公有继承来实现。

EX: 策略类和混入类（mixins）通过公有继承添加行为，但这并不是误用公有继承来建模“用...来实现”关系。

### 38.实施安全的改写
**负责任的进行改写：改写一个虚拟函数时，应该保持可替换性，即保持基类中函数的前后条件，不要改变虚拟函数的默认参数。应该显式的将改写函数重新声明为virtual。谨防在虚拟类中隐藏重载函数。**

* 如果基类的重载函数应该可见，那就写一条using声明语句，在派生类中重新声明。

### 39.考虑将虚拟函数声明为非公用的，将公用函数声明为非虚拟的
**在基类中进行修改代码高昂（尤其是库中和框架中的基类）：请将公用函数设为非虚拟的，应该将虚拟函数设为私有的，或者如果派生类需要调用基类版本，则设为保护的。（不适用于析构函数，见第50条）**

* NVI与模板方法很类似，但是动机和意图不同。
* 通过将公有函数与虚拟函数分离，可以获得好处：
    * 每个接口都能自然形成
    * 基类拥有控制权
    * 基类能够健壮地适应变化

EX: NVI对析构函数不适用。NVI不支持调用者的协变返回类型。

### 40.要避免提供隐式转换
**并非所有的变化都是进步：隐式转换所带来的影响经常是弊大于利。在为自定义类型提供隐式转换之前，请三思而行，应该依赖的是显式转换（explicit构造函数和命名转换函数）。**

* 隐式转换构造函数与重载机制配合得很糟糕。
* 定义成operator T形式的成员函数的转换也好不到哪里去 - 它们与隐式构造函数的配合很糟。

EX: 只要谨慎地保守使用隐式转换，就可以编写出简洁直观的调用代码。

### 41.将数据成员设为私有的，无行为的聚集（C语言形式的struct）除外
**它们不关调用者的事：将数据成员设为私有的。简单的C语言形式的struct类型只是将一组值聚集在了一起，并不封装或者提供行为，只有在这种struct类型中才可以将所有数据成员都设成公有的。要避免将公有数据和非公有数据混合在一起，因为这几乎总是设计混乱的标志。**

EX: get/set函数很有用，但是主要由get/set组成的类可能是一种设计不良的表现。

### 42.不要公开内部数据
**不要过于自动自发，避免返回类所管理的内部数据的句柄，这样类的客户就不会不受控制地修改对象自己拥有的状态。**

EX: 兼容遗留代码或者其他系统进行接口。

### 43.明智地使用Pimpl
**抑制语言的分离欲望，C++将私有成员指定为不可访问的，但并没有指定为不可见的。虽然这样自有其好处，但是可以考虑通过Pimpl惯用法使私有成员真正不可见，从而实现编译器防火墙，并提高信息隐藏度（见第11，41条）。**

* 应该用Pimpl来存储所有私有成员，包括成员数据和私有函数。
* 这个惯用法的标记性特点：独立，自由。
* 声明Impl类型为类中的嵌套类型。

EX: 只有弄清楚了增加间接层次确实有好处之后，才能添加复杂性，Pimpl也是一样。

### 44.优先编写非成员非友元函数
**要避免交成员费：尽可能将函数指定为非成员非友元函数。**

* 非成员非友元函数通过尽量减少依赖提高了封装性。

### 45.总是一起提供new和delete
**它们是一揽子交易：每个类专门的重载`void* operator new(parms)`都必须与对应的重载`void delete(void*, parms)`相伴，其中parms是额外参数类型的一个列表（第一个总是std::size_t）。数组形式的new[]和delete[]也同样如此**

* 编译器可能需要`T::operator delete`的重载，即使实际上从来也不会调用它。

EX: operator new的in-place形式不需要对应的operator delete。

### 46.如果提供类专门的new，应该提供所有标准形式（普通、就地和不抛出）
**不要隐藏好的new：如果类定义了operator new的重载，则应该提供operator new所有三种形式――普通(plain),就地(in-place)和不抛出(nothrow)的重载，不然类的用户就无法看到和使用它们。**
```
static void*operator new(std::size_t);//普通
static void*operator new(std::size_t,std::nothrow_t) throw();//不抛出
static void*operator new(std::size_t,void*);//就地
```

* 在某个作用域定义了一个名字之后，就会隐藏所有外围作用域中同样的名字，而且永远不会发生跨作用域的重载。
* 应该总是避免隐藏就地new。
* 在两种不同的环境下，公开隐藏的operator new需要采取两种不同的方式。


## 构造、析构与复制
### 47.以同样的顺序定义和初始化成员变量
**与编译器一致：成员变量初始化的顺序要与类定义中声明的顺序始终保持一致，不用考虑构造函数初始化列表中编写的顺序，要确保构造函数代码不会导致混淆的指定不同的顺序。**


### 48.在构造函数中用初始化代替赋值
**设置一次，到处使用：在构造函数中，使用初始化代替赋值来设置成员变量，能够防止发生不必要的运行时操作，而输入代码的工作量则保持不变。**

EX: 应该总是在构造函数体内而不是初始化列表中执行非托管资源获取。

### 49.避免在构造函数和析构函数中调用虚拟函数
**虚拟函数仅仅“几乎”总是表现得虚拟：在构造函数和析构函数中，它们并不虚拟。更糟糕的是，从构造函数或析构函数直接或间接调用未实现的纯虚拟函数，会导致未定义的行为。如果设计方案希望从基类构造函数或者析构函数虚拟分派到派生类，那么需要采用其他技术，比如后构造函数（post-constructor）。**


### 50.将基类析构函数设为公用且虚拟的，或者保护且非虚拟的
**删除，还是不删除，这是个问题：如果允许通过指向基类Base的指针执行删除操作，则Base的析构函数必须是公用且虚拟的。否则，就应该是保护且非虚拟的。**

* 当且仅当基类析构函数是公用的，才将其设为虚拟的。
* 总是为基类编写析构函数，因为隐含生成的析构函数是公有且非虚拟的。
* 策略类经常被用作基类，是出于方便考虑的，而不是出于多态行为考虑的。建议将它们的析构函数设为保护且非虚拟的。

EX: 可以将析构函数设为公有且非虚拟的，但要注明不能被多态使用。

### 51.析构函数、释放和交换绝对不能失败
**它们的一切尝试都必须成功：决不允许析构函数，资源释放（deallocation）函数（如operator delete）或者交换函数报告错误。说得更具体一些，就是绝不允许将那些析构函数可能会抛出异常的类型用于C++标准库。**


### 52.一致地进行复制和销毁
**既要创建，也要清除：如果定义了复制构造函数、复制赋值操作符或者析构函数中的任何一个，那么可能也需要定义另一个或者另外两个。**

* 如果需要定义这三个函数中的任何一个，就意味着我们需要函数默认行为之外的功能，而这三个函数是不对称相关的。

EX: 如果只是为了将它们设为私有的或者虚拟的，而没有什么特殊语义，就不需要其余两个函数。拥有一些奇怪类型成员的类，有奇特的复制语义。

### 53.显式地启用或者禁止复制
**清醒地进行复制：在下述三种行为之间谨慎选择 - 使用编译器生成的复制构造函数和赋值操作符；编写自己的版本；如果不允许复制的话，显式地禁用前两者。**


### 54.避免切片。在基类中考虑用克隆代替复制
**切片面包很好：切片对象则不然：对象切片是自动的、不可见的，而且可能会使漂亮的多态设计嘎然而止。在基类中，如果客户需要进行多态（完整的、深度的）复制的话，那么请考虑禁止复制构造函数和复制赋值操作符，而改为提供虚拟的Clone成员函数。**

* 将基类的复制构造函数设为protected，并改而依赖于一个虚拟的Clone函数。
* Clone应该用NVI模式。

EX: 通过指针来传递所导致的切片以及不希望出现的临时构造的机会要小得多。

### 55.使用赋值的标准形式
**赋值，你的任务：在实现operator=时，应该使用标准形式——具有特定签名的非虚拟形式。**
```
T& operator=(const T&); // 传统的
T& operator=(T); // 如果要复制操作符内的参数
```

* 要避免将复制操作符设为虚拟的。
* 如果使用swap惯用法编写复制赋值操作符，则操作符不仅会自动具有强大的防错功能，而且对于自我赋值也是安全的。
* 要显式调用所有基类赋值操作符，并为所有数据成员赋值。

### 56.只要可行，就提供不会失败的swap（而且要正确地提供）
**swap既可无关痛痒，又能举足轻重：应该考虑提供一个swap函数，高效且绝对无误地交换两个对象。这样的函数便于实现许多惯用法，从流畅地将对象四处移动以轻易地实现赋值，到提供一个有保证的、能够提供强大防错调用代码的提交函数（另见第51条）。**

* 对于原始类型和标准容器而言，用std::swap就可以了。其他的类可能需要各种名字的成员函数来实现交换。
* 考虑使用swap以复制构造来实现复制赋值，而不要用一个后跟定位new的显式析构函数，用复制构造来实现复制赋值。

EX: 交换对于基类没那么有用。

## 名字空间与模块
### 57.将类型及其非成员函数接口置于同一名字空间中
**非成员函数也是函数：如果要将非成员函数（特别是操作符和辅助函数）设计成类X的接口的一部分，那么就必须在与X相同的名字空间中定义它们，以便正确调用。**


### 58.应该将类型和函数分别置于不同的名字空间中，除非有意想让它们一起工作
**协助防止名字查找问题：通过将类型（以及与其直接相关的非成员函数，见第57条）置于自己单独的名字空间中，可以使类型与无意的ADL（参数依赖查找）隔离开来，促进有意的ADL。要避免将类型和模板化函数或者操作符放在相同的名字空间中。**

* 避免将不属于类型X的接口的非成员函数与X放在同一个名字空间中，尤其绝对不要将模板化函数或者操作符与用户定义类型放在同一名字空间中。

### 59.不要在头文件中或者#include之前编写名字空间using
**名字空间using是为了使我们更方便，而不是让我们用来叨扰别人得：绝对不要编写using声明或者在#include之前编写using指令。**
**推论：在头文件中，不要编写名字空间级的using指令或者using声明，相反应该显式地用名字空间限定所有的名字。（因为头文件无法知道以后其他头文件会出现什么样的#include）**

* 这一建议并不适用于编写类成员级的using声明以导入需要的基类成员名字的情况。
* 在所有#include之后的实现文件中，可以而且应该不受限制地编写名字空间级的using声明和指令。

EX: 从老的标准化之前的标准库将一项目移植到更新后的标准库上。

### 60.要避免在不同的模块中分配和释放内存
**物归原位：在一个模块中分配内存，而在另一个模块中释放它，会在这两个模块之间产生微妙的远距离依赖，使程序变得脆弱。必须使用相同版本的编译器、同样的标志（比较著名的比如用debug还是NDEBUG）和相同的标准库实现对它们进行编译，实践中，在释放内存时，用来分配内存的模块最好仍在内存中。**

* 确保删除由合适的函数进行，一个很好的方式是使用shared_ptr设施。

### 61.不要在头文件中定义具有链接的实体
**重复会导致膨胀：具有链接的实体（entity with linkage），包括名字空间级的变量或函数，都需要分配内存。在头文件中定义这样的实体将导致连接时错误或者内存的浪费，请将所有具有链接的实体放入实现文件。**

* 不要在头文件中定义名字空间级的static实体。

EX: 外部链接的实体（内联函数，函数模板，类模板的静态数据成员）可以放入头文件中。Schwarz计数器全局数据初始化技术。

### 62.不要允许异常跨越模块边界传播
**不要向邻家的花园抛掷石头：C++异常处理没有普遍通用的二进制标准。不要在两段代码之间传播异常，除非能够控制用来构建两段代码的编译器和编译选项；否则模块可能无法支持可兼容地实现异常传播。这通常可以一言以蔽之：不要允许异常跨越模块或子系统边界传播。**

* 最低限度，应用程序必须在以下位置有捕获所有异常的catch(...)兜底语句，除此之外经常是一种不良设计的前兆：
    * 在main函数的附近
    * 在从无法控制的代码中执行回调附近
    * 在线程边界附近
    * 在模块接口边界的附近
    * 在析构函数内部
* 确保所有模块在内部一致地使用一种错误处理策略（最好是C++异常，见第72条），而在其接口中也一致地使用另一种错误处理策略（例如，C语言的错误码）。
* 错误处理策略只有在跨越模块边界时才可以改变。
* catch(...)子句可能捕获的不仅仅是普通的C++异常。
* 好的程序不应该有很多捕获全部异常的catch，实际上，连try/catch语句都不多；理想情况下，错误可以在模块内部到处顺畅地传播，在跨越模块边界时转换（不得不付出的代价），在按策略设置的边界上进行处理。

### 63.在模块的接口中使用具有良好可移植性的类型
**生在（模块的）边缘，必须格外小心：不要让类型出现在模块的外部接口中，除非能够确保所有的客户代码都能正确的理解该类型。应该使用客户代码能够理解的最高层抽象。**

* 使用的抽象层次越低，可移植性就越好，但复杂性也越高。


## 模板与泛型
### 64.理智地结合静态多态性和动态多态性
**1+1可远远不止是2：静态多态性和动态多态性是相辅相成的。理解它们的优点，善用它们的长处，结合两者以获得两方面的优势。**

* 不要将虚函数放入类模板中。

### 65.有意地进行显式自定义
**有意胜过无意，显式强似隐式：在编写模板时，应该有意地、正确地提供自定义点，并清晰地记录文档。在使用模板时，应该了解模板想要你如何进行自定义以将其用于你的类型，并且正确地自定义。**


### 66.不要特化函数模板
**只有在能够正确实施的时候，特化才能起到好作用：在扩展其他人的函数模板（包括std::swap）时，要避免尝试编写特化代码；相反，要编写函数模板的重载，将其放在重载所用的类型的名字空间中（见第56，57条）。编写自己的函数模板时，要避免鼓励其他人直接特化函数模板本身（替代方法见第65条）。**

* 特化函数模板很不直观：
    * 不可能部分地特化函数模板，只能完全特化
    * 函数模板特化决不能参与重载（选中的将总是非模板函数）
* 如果要编写一个函数模板，应该将它编写成一个永远都不会被特化或者被重载的函数模板，并使用一个类模板来实现函数模板。
* 如果要扩展std::swap，应该在自己的类型所在的名字空间中提供一个重载版本。

### 67.不要无意地编写不通用的代码
**依赖抽象而非细节：使用最通用、最抽象的方法来实现一个功能。**

* 使用!=代替<对迭代器进行比较。
* 使用迭代代替索引访问。
* 使用`empty()`代替`size()==0`。
* 使用层次结构中最高层的类提供需要的功能。
* 编写常量正确的代码。

EX: 为了某些优化。


## 错误处理与异常
### 68.广泛地使用断言记录内部假设和不变式
**使用断言吧！广泛地使用assert或者等价物记录模块内部（也就是说，调用代码和被调用代码由同一个人和小组维护）的各种假设，这些假设是必须成立的，否则就说明存在编程错误（另见第70条）。当然，要确保断言不会产生任何副作用。**

* 断言的强大怎么高估都不算过分。
* 要避免使用assert(false)，应该使用assert(!"informational message")。
* 我们知道有些错误是可能会发生的。对于其他不应该发生的错误，如果发生了，就是程序员的错，此时就该使用assert了。

### 69.建立合理的错误处理策略，并严格遵守
**应该在设计早期开发实际、一致、合理的错误处理策略，并予以严格遵守。许许多多的项目对这一点的考虑（或者错误估计）都相当草率，应该对此有意识地规定，并认真应用。策略必须包括以下内容：**

* **鉴别：哪些情况属于错误**
* **严重程度：每个错误的严重性或紧急性**
* **检查：哪些代码负责检查错误**
* **传递：用什么机制在模块中报告和传递错误通知**
* **处理：哪些代码负责处理错误**
* **报告：怎样将错误记入日志，或通知用户。**

**只在模块边界处改变错误处理机制。**

* 按定义回调函数和线程主函数是（或者可能是）位于模块边界。

### 70.区别错误与非错误
**违反约定就是错误：函数是一个工作单元。因此，失败应该视为错误，或根据其对函数的影响而定。在函数f中，当且仅当失败违反了f的一个前条件，或者阻碍了f满足其调用代码的任何前条件，实现f自己的任何后条件或者重新建立f有责任维持的不变式时，失败才是一个错误。特别排除内部的程序设计错误。**


### 71.设计和编写错误安全代码
**承诺，但不是惩罚：在所有函数中，都应该提供最强的安全保证，而且不应惩罚不需要这种保证的调用代码。至少要提供基本保证。
确保出现错误时程序会处于有效状态。这是所谓的基本保证（basic）。要小心会破坏不变式的错误（包括但是不限于泄漏），它们肯定都是bug。
应该进一步保证最终状态要么是最初状态（如果有错误，则回滚操作），要么是所希望的目标状态（如果没有错误，则提交操作）。这就是所谓的强保证（strong）。
应该进一步保证操作永远不会失败。虽然这对于大多数函数来说是不可能的，但是对于析构函数和释放函数这样的函数来说则是必须的。这就是所谓的不会失败保证（no-fail）。**

* 如果无法满足最低的基本保证，那么无疑是一个程序bug。
* 如果一段代码连基本保证都很难满足，那么这几乎就是说明设计很糟糕。

### 72.优先使用异常报告错误
**出现问题时，就是用异常：应该使用异常而不是错误码来报告错误。但不能使用异常时，对于错误以及不是错误的情况，可以使用状态码（比如返回码，errno）（见第62条）来报告异常。当不可能从错误中恢复或者不需要恢复时，可以使用其他方法，比如正常终止或者非正常终止。**

* 如果抛出异常非常频繁，以至于对异常的抛出和捕获进行处理的性能开销非常明显，那么几乎可以肯定你在并非真正出现错误的情况下使用了异常，所以问题出在没有正确地区别错误与非错误。

EX: 在极罕见的情况下使用错误码：异常的优点不适用，性能差异明显。

### 73.通过值抛出，通过引用捕获
**学会正确捕获（catch）；通过值（而非指针）抛出异常，通过引用（通常是const的引用）捕获异常，这是与异常语义配合最佳的组合，当重新抛出相同的异常时，应该优先使用throw;，避免使用throw e;。**


### 74.正确地报告、处理和转换错误
**什么时候说什么话：在检查出并确认是错误时报告错误。在能够正确处理错误的最近一层处理或者转换每个错误。**

* 在以下情况转换错误：
    * 要添加高层的语义
    * 要改变错误处理机制

EX: 接受并再次发送同样的错误以添加测试代码有时是有用的。

### 75.避免使用异常规范
**对异常规范说不：不要在函数中编写异常规范，除非不得以而为之（因为其他无法修改的代码已经使用了异常规范）。**

* EX: 不得不改写已经使用了异常规范的基类虚拟函数。

## STL：容器
### 76.默认时使用vector。否则，选择其他合适的容器
**使用“正确的容器”才是正道：如果有充分的理由使用某个特定容器类型，那就用好了，因为我们心中有数：自己做出了正确的选择。
使用vector同样如此：如果没有充分的理由，那就编写vector，继续前进，无需停顿，我们同样心中有数：自己做出了正确的选择。**

* vector容器中相邻对象保证在内存中也相邻，这是其他标准容器都无法保证的。
* 将vector用于小型列表几乎总是优于使用list。

### 77.用vector和string代替数组
**何必用贵重的明代花瓶玩杂耍呢？不要使用C语言风格的数组，指针运算和内存管理原语操作实现数组抽象。使用vector或者string不仅更轻松，而且有助于编写更安全、伸缩性更好的软件。**


### 78.使用vector（和string::c_str）与非C++ API交换数据
**vector不会在转换中迷失：vector和string::c_str是与非C++ API通信的通道。但是不要将迭代器当作指针。要获取`vector<T>::iterator iter`所引用的元素地址，应该使用`&*iter`。**

* 虽然大多数标准库实现中string都使用连续内存，但这是没有保证的。

### 79.在容器中只存储值和智能指针
**在容器中存储值对象：容器假设它们所存放的是类似值的类型，包括值类型（直接存放）、智能指针和迭代器。**

* 如果需要`map<Thing, Widget>`，但是有些Thing没有相关联的Widget，就应该使用`map<Thing, shared_ptr<Widget> >`。

### 80.用push_back代替其他扩展序列的方式
**尽可能使用push_back：如果不需要操心插入位置，就应该使用push_back在序列中添加元素。其他方法可能极慢而且不简明。**

* 可以通过back_inserter，要求算法使用push_back。

EX: 如果知道要添加的范围，即使位于容器的末尾，也应该使用范围插入函数。

### 81.多用范围操作，少用单元素操作
**顺风顺水无需桨：在序列容器中添加元素时，应该多用范围操作（例如接受一对迭代器为参数的insert形式），而不要连续调用该操作的单元素形式。调用范围操作通常更易于编写，也更易于阅读，而且比显式循环的效率更高（另见第84条）。**
```
v.insert(position, first, last);
```


### 82.使用公认的惯用法真正地压缩容量，真正地删除元素
**使用有效减肥法：要真正的压缩容器的多余容量，应该使用swap魔术惯用法。要真正的删除容器中的元素，应该使用erase-remove惯用法。**

* swap:
```
container<T>(c).swap(c);
container<T>().swap(c);
```

* erase-remove:
```
c.erase(remove(c.begin(), c.end(), value), c.end());
```

* 对于有remove或者remove_if的容器，应该尽量使用这两个函数的成员版本。

EX: 通常的shrink-to-fit惯用法对写时复制方式实现的std::string不适用。


## STL：算法
### 83.使用带检查的STL实现
**安全第一（见第6条）：即使只在其中的一个编译器平台上可用，即使只能在发行前的测试中使用，也仍然要使用带检查的STL实现。**

* 大多数带检查的stl都会通过在容器和迭代器中添加附加的调试和支持信息来自动的检查这些错误。

### 84.用算法调用代替手工编写的循环
**明智地使用函数对象：对非常简单的循环而言，手工编写的循环有可能是最简单也是最有效率的解决方案。但是编写算法调用代替手工编写的循环，可以使表达力更强、维护性更好、更不容易出错，而且同样有效。
调用算法时，应该考虑编写自定义的函数对象以封装所需的逻辑。不要将参数绑定器（parameter-binder）和简单的函数对象凑在一起（例如bind2nd和plus），通常这会降低清晰性。还可以考虑尝试[boost]的Lambda库，这个库自动化了函数对象的编写过程。**

EX: 算法调用与函数对象一起使用时，将会使循环体离开调用点，从而使循环更难阅读。调用命名函数包括成员函数，仍然需要绑定器式的语法。

### 85.使用正确的STL查找算法
**选择查找方式应“恰到好处”- 正确的查找方式应该使用STL（虽然比光速慢，但已经非常快了）：本条款适用于在一个范围内查找某个特定值，或者查找某个值的位置（如果它处在范围内的话）。查找无序范围，应该使用find/find_if或者count/count_if。查找有序范围，应使用lower_bound, upper_bound, equal_range或者（在少数情况下）binary_search（尽管binary_search有一个通行的名字，但是选择它通常并不一定正确）。**

* 对于有序范围，应该将`p=equal-rang(first, last, value); distance(p.fisrt, p.second); `当作`count(first, last, value);`的更快版本使用。
* 如果所查找的是一个关联容器，那么应该使用同名的成员函数。

### 86.使用正确的STL排序算法
**选择排序的方式应“恰到好处”：理解每个排序算法的作用，选择能够实现所需而开销最低的算法。**

* partition, stable_partition, 和nth_element算法是线性时间的。
* nth_element, partial_sort, sort和stable_sort需要随机访问迭代器。
* partial_sort除了可以完成nth_element的工作之外，还能使第n个元素之前的元素都处在正确的排序位置上。

EX: 如果需要对范围中大多数或全部元素排序，partial_sort会比完全的sort慢。

### 87.使谓词成为纯函数
**保持谓词纯洁性：谓词就是返回是或否（返回值通常是bool类型）的函数对象。从数学的意义上来说，如果函数的结果只取决于其参数，则该函数就是一个纯函数（和纯虚函数没关系）。
不要让谓词保存或访问对其operator()结果有影响的状态，包括成员状态和全局状态。应该使operator()成为谓词的const成员函数。**


### 88.算法和比较器的参数应多用函数对象少用函数
**对象的适配性比函数好：应该向算法传递函数对象，而非函数。关联容器的比较器必须是函数对象。函数对象的适配性好，而且与直觉相反，它们产生的代码一般比函数快。**


### 89.正确编写函数对象
**成本要低，而且要可适配：将函数对象设计为复制成本很低的值类型，尽可能的让他们从unary_function或binary_function继承，从而能够适配。**

* 封装类应该能够：
    * 可适配
    * 具有Pimpl
    * 具有函数调用操作符
* 当函数对象从unary_function和binary_function继承时，这些typedef能够最方便地自动提供。实例化时，对于非指针类型，需要去掉所有顶层的const和&。
* 谓词只是函数对象的一个子集而已。


## 类型安全
### 90.避免使用类型分支，多使用多态
**切勿分支：避免通过对象类型分支来定制行为。使用模板和虚函数，让类型自己（而不是调用它们的代码）来决定行为。**

* 修改能运转的代码是不受欢迎的，应该尽量避免。（开放-封闭原则：实体应该对扩展开放，而对修改关闭）
* 可是抽象之所以称为“抽象”，就是因为它们应该比“细节”（即抽象的可能实现）稳定得多。

### 91.依赖类型，而非其表示方式
**不要企图给对象拍X光片（见第96条）：不要对对象在内存中的准确表示方式做任何假设。相反，应该让类型决定如何在内存中读写其对象。**


### 92.避免使用reinterpret_cast
**谎言总是站不住脚的：不要尝试用reinterpret_cast强制编译器将某个类型对象的内存表示重新解释成另一种类型的对象。这违反了维护类型安全性的原则，尤其可怕的是reinterpret_cast甚至不能保证是否能够达到这一目的，也无法保证其他功能。**

* reinterpret_cast的后果实际上取决于具体编译器实现如何定义，既不可靠又不可移植。

EX: 如果需要在不相关的指针类型之间强制转换，应该通过void*进行转换（及static_cast），不要直接用reinterpret_cast。

### 93.避免对指针使用static_cast
**不要对动态对象的指针使用static_cast：安全的替代方案有很多，包括使用dynamic_cast，重构，乃至重新设计。**

* 设计中应该消除向下强制：对代码进行重构或者重新设计，消除其必要性。
* 向下强制过多可能说明基类接口不足。

### 94.避免强制转换const
**莫以恶小而为之：强制转换const有时会导致未定义的行为，即使合法，也是不良编程风格的主要表现。**

* 即使这种转换不会导致程序崩溃，也破坏了承诺。
* C++有一个隐式的const_cast，可以将字符串常量“起死回生”为char\*：`char* weird = "Trick or treat";`

EX: 调用常量不正确的API。非const函数调用const函数的重载版本。

### 95.不要使用C风格的强制转换
**年纪并不意味着智慧：C语言风格的强制转换根据上下文具有不同（而且经常很危险）的语义，而所有这些都隐藏在相同的语法背后。用C++风格的强制转换代替C风格的强制转换有助于防范意想不到的错误。**


### 96.不要对非POD进行memcpy操作或者memcmp操作
**不要企图给对象拍X光片（见第91条）：不要用memcpy或memcmp来复制或比较任何对象，除非有什么对象的布局就是原始内存。**


### 97.不要使用联合重新解释表示方式
**偷梁换柱也是一种欺骗：通过在union中写入一个成员而读取另一个的滥用方式可以获得“无需要强制转换的强制转换”。这比起reinterpret_cast（见第92条）更阴险，也更难预测。**

EX: 如果两个POD struct是一个union成员，而且均以相同的字段类型开始。

### 98.不要使用可变长参数（...）
**省略会导致崩溃：省略号是来自C语言的遗产。要避免使用可变长参数，应改用高级的C++结构和库。**


### 99.不要使用失效对象。不要使用不安全函数
**不要使用失效药：失效对象和老的但是不安全的函数会对程序的健康产生极大的破坏。**

* 不要使用不安全的C语言遗留函数：strcpy，strncpy，sprintf等。

### 100.不要多态地处理数组
**数组的可调整性很差：多态地处理数组是绝对的类型错误，而且编译器有可能不会做出任何提示。不要掉入这一陷阱。**

* 对指向Base的指针p进行指针运算时，编译器会将`p[n]`计算为`*(p+n*sizeof(Base))`，因此是将内存中的对象都当作Base类型的了——而不是大小可能不同的派生类对象。
</xmp>
<script src="js/strapdown.js"></script>
</html>
