<!DOCTYPE html>
<html>
<title>ECMAScript6</title>
<xmp theme="readable" style="display:none;">
## Block Scoping
`let`可以使变量作用域限制在block`{ }`范围之内。在block内，let声明之前，该变量都不可用（ReferenceError)
`let`声明的变量不会发生[变量提升](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting)现象，字面定义的函数或类属于块级作用域，也不会被提升。
`let`不允许再用`let`或`var`重复声明一个变量。
for循环中用`let`声明的的迭代变量只在循环体内可见。

`const`和`let`一样也是块级作用域，不过声明的是常量（只读，但重新赋值不会报错）。


## Collections
### Map
`Map`是一个key/value关联结构，任意类型的值都可以作为key或value。可以用`[key, value]`的数组初始化。
key的相等性用`===`比较，除了`NaN`与自身相等。

实例方法/属性：
`get(key)` 取得key对应的值，没有则返回`undefined`。
`set(key, value)` 设置key对应的值，并返回map本身。
`has(key)` 测试key对应的是否有值。
`delete(key)` 删除一个key对应的值。
`clear()` 清空。
`forEach(callbackFn(value, key, map)[, thisArg])` 按插入的顺序迭代Map。
`keys()` 返回键名迭代器。
`values()` 返回键值迭代器。
`entries()` 返回`[key, value]`迭代器(默认迭代器)。
`size` map的长度。

与`Object`的比较：

* `Object`有一些原型里的默认key/value对，虽然`Map`也继承自`Object`但存取值的方式不一样。
* `Object`的key只能是`String`，`Map`可以是任意类型。
* 通过`size`属性可以直接得到`Map`的长度，`Object`需要自己计算。

### WeakMap
`WeakMap`是一种特殊的`Map`，其key的类型是对象，但此key对对象的引用不影响GC。
`WeakMap`没有size属性，不可枚举键值。

实例方法：
`get(key [, defaultValue])` 取得key对应的值，没有可以返回默认值。
`set(key, value)` 设置key对应的值。
`has(key)` 测试key对应的是否有值。
`delete(key)` 删除一个key对应的值。

### Set
`Set`可以存储任意类型的唯一值。可以用数组（或可iterable类型）初始化。

实例方法/属性：
`add(value)` 加入一个值。
`delete(value)` 删除一个值。
`has(value)` 测试是否有值。
`clear()` 清空。
`forEach(callbackFn(value, key, set)[, thisArg])` 按插入的顺序迭代Set。
`keys()` 返回键名迭代器。
`values()` 返回键值迭代器(默认迭代器)。对于Set，key和value一样。
`entries()` 返回`[key, value]`迭代器。
`size` set的长度。

### WeakSet
和WeakMap类似。

实例方法：
`add(value)` 加入一个值。
`delete(value)` 删除一个值。
`has(value)` 测试是否有值。


## Iteration
一个迭代器(iterator)是一个有`next()`方法的对象，并返回`{value, done}`，done表示迭代是否结束。
一个可迭代的对象有一个特殊的方法`prototype[Symbol.iterator]`，这个方法返回其迭代器。原生可迭代的类型：Array, String, Map, Set, Generator 以及类似数组的类型如arguments, DOM NodeList等。
用`for-of`来迭代一个迭代器或可迭代的对象(`for-in`枚举对象的属性)。


## Generators
> First-class coroutines, represented as objects encapsulating suspended execution contexts.

generator函数产生一个特殊的迭代器(generator)，每运行到`yield`返回为一次迭代（返回对象属性done为false，value为yield的值），并保留context，下次迭代从上次`yield`处继续往下运行，如果运行到函数结束而没有由`yield`返回则迭代结束（返回对象属性done变为true，value为return的值）。
声明一个generator函数 `function *foo(){ }`。

```
function *Counter(){
    let n = 0;
    while (n < 2) {
        yield n++;
    }
    return 10;
}

var countIter = new Counter(); // 或直接Counter()

// 用next方法迭代
console.log(countIter.next());
console.log(countIter.next());
console.log(countIter.next());

// 或用for-of迭代
for (let c of countIter) {
    console.log(c);
}
```

输出：
```
{ value: 0, done: false }
{ value: 1, done: false }
{ value: 10, done: true }

0
1
```


成员方法`next(param)`可以传入参数作为**上次**yield表达式的返回值：
```
function *pow() {
    let ret = Math.pow(yield "x", yield "y");
    return ret;
}

var p = pow();
console.log(p.next().value); // "x"
console.log(p.next(2).value); // "y"
console.log(p.next(10).value); // 1024
```

成员方法`throw(error)`可以在yield处抛出异常。如果没有在generator函数内捕获，则会抛到外面来。一旦抛出异常，generator就无法继续执行下去，`next`会一直返回发生异常前的那个值。

Delegating yield `yield*`: 委派给另一个generator（或一个迭代器），直到其全部yield完成，自己再继续，`yield*`表达式返回由委派的generator最后return的值，`yield*`本身并不是一次迭代返回。
可用来递归：
```
function *fibonacci(n) {
    return (n == 0 || n == 1) ? n : (yield *fibonacci(n-1)) + (yield *fibonacci(n-2));
};
```

## Numeric Literals
二进制：`0b010111`, `0B010111`
八进制：`0o7177`, `0O7177`

## Promises
Promise表示执行异步操作的结果，遵循[Promises/A+规范](https://promisesaplus.com/)。
`new Promise(function(resolve, reject) { ... });` 构造函数传入异步操作，成功调用`resolve`(resolved/fulfilled)，失败调用`reject`(rejected)，最后用`then`取得结果。
Promise构造时异步操作就开始执行，调用`then`时如果没有执行完成，则等待以取得结果。`resolve`保存异步操作的结果，本身并不等待，参数可以是另一个Promise对象，并且`then`取结果时也要等这个对象的异步操作先执行完成（`reject`不会等待）。

![promises](https://mdn.mozillademos.org/files/8633/promises.png)

实例方法：
`then(onResolved, onRejected)` onResolved对应resolve的结果，onRejected对应reject的结果或抛出的异常。返回一个新的Promise对象，可以链式调用，onResolved/onReject的return的结果会作为其resolve的参数。

`catch(onRejected)` 相当于`then(null, onRejected)`，在resolve/reject后抛出的异常不会被捕获。如果异常没有被then处理，则会带到返回的Promise中由后面的then或catch处理。Promise对象中没有被捕获的异常不会传到外层代码。

静态方法：
`Promise.all(iterable)` 将多个Promise对象合成一个，只有所有对象都resolved，它才会变为resolved，且回调参数为所有resolve参数组成的数组；只有有一个对象reject或抛出异常，它就会变为rejected，回调参数为第一个reject的参数。
`Promise.race(iterable)` 类似all，但只要有一个对象状态先改变为resovled/rejected，其状态就改变。
`Promise.resolve(obj)` 将一个thenable对象转为Promise对象。如果此对象不thenable，直接转为一个resolved的Promise对象。
`Promise.reject(obj)` 转为一个rejected的Promise对象。


## Symbols
`Symbol([name])`产生唯一的ID，可以作为对象的唯一属性名。
对象的Symbol属性只能由`getOwnPropertySymbols`和`getOwnPropertyKeys`获得。

`Symbol.for(name)` 注册一个名为name的Symbol，如果已注册则返回它。
`Symbol.keyFor(s)` 返回一个Symbol的注册名字。

内置的Symbol值（内部方法）：
`Symbol.hasInstance` 是否是某个类型的实例
`Symbol.isConcatSpreadable` 是否可以扩展成数组
`Symbol.isRegExp` 是否是正则表达式
`Symbol.iterator` 返回默认迭代器
`Symbol.toPrimitive` 转为原始类型
`Symbol.toStringTag` 转为字符串
`Symbol.unscopables` 被with排除的属性值

## Template Strings
用反引号引用（反引号本身需要反斜杠转义），可以当作普通字符串使用，支持多行表示。
嵌入变量（如果变量没有声明过则会ReferenceError）：`${var}`，大括号内可以进行表达式计算，引用对象属性，调用函数。
标签函数(tag function，函数名后直接跟模版字符串)，第一个参数是没有被变量替换的部分组成的数组，后面跟各个变量被替换后的值：
```
let ver = 5;
tagfunc`this is ECMAScript ${ver + 1}!`
// 相当于tagfunc(['this is ECMAScript ', '!'], 6)，第一个字符串数组参数有个`raw`属性，是其字符串的未转义表示。
// 即使两个变量间没有字符（或在字符串头尾），数组中也会有一个空字符串
```

## Object Literal Extensions
对象的字面表示可以直接写变量（变量名作为属性名）和方法，还可以用表达式作为属性名（中括号引用）：
```
{
    x,
    y,
    [x+y]: true,
    foo() { }
    *gen() { }
}
```


## Proxies
Proxies提供了一个元编程API，可以通过traps(代理方法)重新定义原始对象的语义。操作必须应用在Proxy对象上才能被代理。

`new Proxy(target, hanlder)` target是被代理的对象，hanlder是traps的集合。
`Proxy.create(handler, proto)` 创建一个原型是proto的代理对象。
`Proxy.revocable(target, handler)` 返回`{proxy, revoke}`，执行`revoke()`后再访问proxy对象会产生TypeError。

```
var handler = {
    get: function(target, name) {
        return name in target? target[name] : 42;
    }
};

var p = new Proxy({}, handler);
p.a = 1;
p.b = undefined;

console.log(p.a, p.b, p.c); // 1, undefined, 42
```

可被代理的操作种类：
`enumerate(target)` 返回一个迭代器，代理`for (x in proxy)`
`has(target, propKey)` 代理`propKey in proxy`
`get(target, propKey, receiver)` 代理对象属性的读取
`set(target, propKey, value, receiver)` 代理对象属性的设置
`deleteProperty(target, propKey)` 代理`delete proxy[propKey]`
`defineProperty(target, propKey, propDesc)` 代理`Object.defineProperty`
`getOwnPropertyDescriptor(target, propKey)` 代理`Object.getOwnPropertyDescriptor`
`getPrototypeOf(target)` 代理`Object.getPrototypeOf`
`setPrototypeOf(target, proto)` 代理`Object.setPrototypeOf`
`isExtensible(target)` 代理`Object.isExtensible`
`ownKeys(target)` 代理`Object.getOwnPropertyPropertyNames`, `Object.getOwnPropertySymbols`, `Object.keys`
`preventExtensions(target)` 代理`Object.preventExtensions`
对函数类型对象：
`apply(...)` 代理各种函数调用`proxy(...)`, `proxy.call(...)`, `proxy.apply(...)`
`construct()` 代理构造函数调用`new proxy()`


## Classes
`class`并不是一个新的结构，只是一个语法糖。类和对象的机制还是基于原型链。

```
class A {
    constructor(x) {
        this.x = x;
    }

    foo() { // A.prototype.foo = ...
        console.log('this is foo, x = ', this.x);
    }

    static bar() { // A.bar = ...
        console.log('this is bar');
    }

    get x() { return this.x; }
    set x(a) { this.x = a; }
    *gen() { ... }
}
```
只能用`new`创建实例对象。
在类或模块内部不需要显式指定默认就是严格模式。
如果不写构造函数会默认生成空的构造函数。构造函数默认返回this。
`A.name`属性返回类名('A')。
表达式形式定义（类似函数）：`let A = class { ... }`
静态函数由类名直接调用，在函数里不要引用`this`。[没法定义静态数据成员](http://stackoverflow.com/questions/22528967/es6-class-variable-alternatives)（可以直接`A.xxx`）。


### 继承
```
class Sub extends Base {
}
```

默认构造函数：
```
constructor(...args) {
    super(...args);
}
```
`super`调用父类构造函数，且只能是子类构造函数的第一个语句。

子类对象(s)是子类(Sub)的实例，也是父类(Base)的实例。以下皆为true：
```
s instanceof Sub
s instanceof Base
Base.prototype instanceof Object
Base.__proto__ === Function.prototype
Sub.prototype instanceof Base
Sub.__proto__ === Base
s.__proto__ === Sub.prototype
s.__proto__.__proto__ === Base.prototype
```

## Module

## Unicode
Unicode增强都是为了能够更好地兼容UTF16，因为JavaScript使用UCS2编码只能处理双字节。

字符的完全码点表示：`"\u{codePoint}"`
正则表达式的`u`修饰符：`/^.$/u.test(s)`，`i`修饰符可以识别字型相近(正规化后一样)的字符。
正确返回UTF16的字符串长度：`Array.from(string).length`
字符串相关函数：`fromCodePoint`, `codePointAt`, `at`(ES7), `normalize`


## 类型扩展
### Number
`Number.isFinite(n)` 检查一个值是否为非无穷。
`Number.isNaN(n)` 检查一个值是否为NaN。
`Number.parseInt(n)` 字符串转整型。
`Number.parseFloat(n)` 字符串转浮点型。
`Number.isInteger(n)` 检查一个值是否为整型，`1.0`也是整型。[关于浮点数](http://floating-point-gui.de/)
`Number.isSafeInteger(n)` 检查一个值是否是在`[Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]`(`[-2^53,2^53]`)之内的安全整数。

### Math
`Math.trunc(x)` 取出整数部分。
`Math.sign(x)` 返回一个数的符号，可以为-1, 1, 0, NaN。
`Math.sinh(x)` 双曲正弦。
`Math.asinh(x)` 反双曲正弦。
`Math.cosh(x)` 双曲余弦。
`Math.acosh(x)` 反双曲余弦。
`Math.tanh(x)` 双曲正切。
`Math.atanh(x)` 反双曲正切。
`Math.cbrt(x)` 立方根。
`Math.clz32(x)` 32位二进制整数表示前面0的个数。
`Math.expm1(x)` `e^x - 1`
`Math.fround(x)` 单精度浮点数形式。
`Math.hypot(x, y, ...)` 所有数的平方和的平方根。
`Math.imul(x, y)` 以32位整数形式相乘。
`Math.log1p(x)` `1+x`的自然对数。
`Math.log10(x)` 以10为底的对数。
`Math.log2(x)` 以2为底的对数。

### Object
`Object.observe(obj, callback[, event])` (ES7) 运行时观测一个对象的变化，相关改变信息通过回调返回。`unobserve`取消。
`Object.is(a, b)` 比较两个值是否相等，基本和`===`一致，除了+0不等于-0，NaN等于自身。
`Object.assign(target, source1[, source2, ...])` 将源对象的可枚举属性复制到目标对象上。有同名属性，则后面的会覆盖前面的。
`Object.getPrototypeOf(obj)` 返回一个对象的proto对象(`__proto__`属性)。
`Object.setPrototypeOf(obj, proto)` 设置一个对象的proto对象。

### String
`String.fromCodePoint(codePoint)` 从码点返回字符。
`String.raw({raw: s}, params, ...)` 返回字符串未转义的原始表示，一般以标签函数形式使用。

实例方法：
`codePointAt(index)` 返回一个字符的码点，能正确处理所有UTF16字符。
`normalize(param)` 正规化一个字符，参数可以是`NFC`（默认）, `NFD`, `NFKC`, `NFKD`。
`repeat(n)` 重复一个字符串。
`includes(searchString, [, position])` 是否包含指定字符串，可以指定起始查找位置。
`startsWith(searchString [, position])` 测试是否以指定字符串起始，可以指定起始位置。
`endsWith(searchString [, position])` 测试是否以指定字符串结束，可以指定结束位置。
`contains(searchString [, position])` 测试是否包含指定字符串，可以指定起始查找位置。

### Array
`Array.from(arrayish)` 从一个类似数组的对象构造一个数组，这些对象可以索引访问且有length属性。
`Array.of([elem1], [elem2], ...)` 从一些值构造数组，避免直接用构造函数的一些陷阱。

### RegExp
`sticky` 粘连属性，表示带有头`^`匹配的全局`g`匹配，`/string/y`每次剩余匹配都要从头开始匹配。


## Reference
[ECMAScript 6入门](http://es6.ruanyifeng.com/)
[ES6 Features Implemented in V8](https://github.com/joyent/node/wiki/ES6-%28a.k.a.-Harmony%29-Features-Implemented-in-V8-and-Available-in-Node)
[ECMAScript 6 support in Mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/ECMAScript_6_support_in_Mozilla)
[ECMAScript 6 compatibility table](http://kangax.github.io/es5-compat-table/es6/)
[ECMAScript Wiki - harmony proposals](http://wiki.ecmascript.org/doku.php?id=harmony:proposals)
[babel](https://babeljs.io)

</xmp>
<script src="js/strapdown.js"></script>
</html>
