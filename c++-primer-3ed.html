<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<title>C++ Primer 3ed</title>
<xmp theme="readable" style="display:none;">
# 一 C++概述
## 1 开始
### 1.1 问题的解决
### 1.2 C++程序
### 1.3 预处理器指示符
### 1.4 注释
### 1.5 输入/输出初步


## 2 C++浏览
### 2.1 内置数组数据类型
### 2.2 动态内存分配和指针
### 2.3 基于对象的设计
### 2.4 面向对象的设计
### 2.5 泛型设计
### 2.6 基于异常的设计
### 2.7 用其他名字来命名数组
### 2.8 标准数组——向量


# 二 基本语言
## 3 C++数据类型
### 3.1 文字常量
一个8位有符号的`char`可以代表从-128 到127 的数值而一个无符号的char则表示0 到255 范围内的数值。(补码表示，负数是其绝对值二进制取反加1,-128:1000 0000;-1:1111 1111)
文字常量(`10`,`true`/`false`,`'a'`,`"china"`)，不可寻址的，尽管它的值也存储在机器内存的某个地方但是我们没有办法访问它们的地址。
`f F l L`后缀只能用在十进制形式中。
`\ooo`这里的ooo 代表三个八进制数字组成的序列。(8进制的ASCII码)
`L'a'`这称为宽字符(汉语，日语)文字类型为`wchar_t`。
一个字符串文字可以扩展到多行，在一行的最后加上一个反斜杠。

### 3.2 变量
全局，静态:初始值0;局部，动态(new):初始值随机。

关于初始化:
```
int a = 10;	//初始化而不是赋值符号，等于a(10)
int a(10);	//初始化为10
int a = int();	//初始化为0
```

### 3.3 指针类型
`void*`类型指针它可以被任何数据指针类型的地址值赋值(函数指针不能赋值给它)，我们不能够操作空类型指针所指向的对象，只能传送该地址值或将它与其他地址值作比较。

### 3.4 字符串类型
### 3.5 const限定修饰符
`const char* p` 常量指针(指向的值不变);
`char* const p` 指针常量(指针的值不变);
`const char* const p` 都不变。
`const* int p` = `const* p` = `const int* p` `*`后面类型忽略，默认为整形
`int const* const p` = `const int* const p` 中间没有`*`，位置可以互换

### 3.6 引用类型
对文字常量、const常量、const对象，必须用const引用。
`const int& ir = 1024;`(实际上是内部临时对象的引用)

用一个const 对象的地址来初始化一个引用(指针的引用):
`const int ival = 1024;`
`const int* const& pi_ref = &ival;`

### 3.7 布尔类型
隐式转换:

* 布尔对象和布尔文字都被提升成int,false变成0 而true变成1。
* 0或空指针被转换成false所有其他的值都被转换成true。

### 3.8 枚举类型
向枚举形参传递一个相等的整数值，编译仍错误。
C++不支持在枚举成员之间的前后移动。
可以显式地把一个值赋给一个枚举成员，这个值不必是唯一的。
可以定义枚举类型的对象，只能被一个相同枚举类型的对象或枚举成员集中的某个值初始化或赋值。(相等的整数值不行，但可强制转换)，但是在必要时枚举类型会自动被提升成算术类型。

### 3.9 数组类型
数组维数值必须是常量表达式即必须能在编译时刻计算出它的值.(解决:可动态申请数组)
初始化时，如果指定的维数大于给出的元素的个数那么没有被显式初始化的元素将被置为0。
不允许声明一个引用数组(即由引用组成的数组)。

### 3.10 vector容器类型
使用vector有两种不同的形式即所谓的数组习惯`vector<int> ivec(10)`和STL习惯`vector<string> text`。

### 3.11 复数类型
### 3.12 typedef名字
typedef不是宏扩展:
```
typedef char* cstring;	//定义类型cstring
const cstring cstr;	//变量cstr是char* const类型
```
即`const cstring cstr`相当于`cstring const cstr`，类似: `const int i`相当于`int const i`。(没有指针时const直接修饰变量)

### 3.13 volatile限定修饰符
`volatile`修饰符的主要目的是提示编译器该对象的值可能在编译器未监测到的情况下被改变，因此编译器不能武断地对引用这些对象的代码作优化处理。

### 3.14 pair类型
### 3.15 类类型
在类定义内部定义的成员函数在缺省情况下被设置为`inline`,在类外而定义的成员函数必须显式地声明为`inline`。
在类体外定义的内联成员函数应该被包含在含有该类定义的头文件中即放在同一个文件中。


## 4 表达式
### 4.1 什么是表达式？
### 4.2 算术操作符
### 4.3 等于、关系和逻辑操作符
二元关系操作符的左右操作数的计算顺序在标准C和C++中都是未定义的，因此计算过程必须是与顺序无关的。

### 4.4 赋值操作符
### 4.5 递增和递减操作符
### 4.6 复数操作
### 4.7 条件操作符
### 4.8 sizeof操作符
```
sizeof(bool)=1;
sizeof(bool*)=4;
sizeof(bool&)=1;
```

### 4.9 new和delete表达式
### 4.10 逗号操作符
### 4.11 位操作符
`&`按位与，`&&`逻辑与(短路)，`|`按位或，`||`逻辑或(短路)

### 4.12 bitset操作
### 4.13 优先级
### 4.14 类型转换
C++标准强制转换:

* `static_cast<type>`可隐式转换(double->int)
* `const_cast<type>`转换掉表达式的常量性或volatile特性(原来仍const,见3.5)
* `reinterpret_cast<type>`显式强制(通用)。
* `dynamic_cast<type>`支持在运行时刻识别由指针或引用指向的类对象(见19.1)。

无论何时，当我们面对令人费解的运行时刻程序错误时，可能的罪魁祸首首先会是具有功能障碍的指针：

* 第一个原因就是无效的显式强制转换，因此用`reinterpret_cast`操作符来执行并标识出所有的显式指针强制转换是很有用的。
* 第二个原因是它指向的内存变成了无效的，这可能会发生在"我们偶尔删除了一个仍然在被使用的指针"或者"返回一个局部对象的地址"时。

### 4.15 栈类实例


## 5 语句
### 5.1 简单语句和复合语句
### 5.2 声明语句
### 5.3 if语句

### 5.4 switch语句
`switch`语句中，如果一个定义(初始化)没有被包围在一个语句块中，那么它在`case`标签之间是可见的，但是只有当定义它的`case`标签被执行时它才能被初始化，因此需要一个语句块来保证名字只在当前`case`中可见，并且也只有这个语句块才能够使用它.跳过对象的初始化操作是个程序设计错误，但声明不会被跳过.(是编译器为类对象插入构造函数/析构函数调用的需要，语句块保证构造函数和析构函数都被执行或忽略保证对象只在它被初始化的地方才可见)

### 5.5 for循环语句
在`for`循环condition中定义的对象的可视性局限在`for`循环体内。(`if`, `switch`, `while`中一样)

### 5.6 while语句
### 5.7 do while语句
`do-while`的condition中不支持对象定义语句。

### 5.8 break语句
### 5.9 continue语句
### 5.10 goto语句

### 5.11 链表示例
如果需要，每个构造函数都要有成员初始化表。


## 6 抽象容器类型
### 6.1 我们的文本查询系统
### 6.2 vector还是list?
### 6.3 vector怎样自己增长
### 6.4 定义一个顺序容器
我们能够定义的容器的类型(用户定义的类类型)有三个限制:必须支持等于操作符，必须支持小于操作符(所有关系操作符都用这两个操作符来实现)，必须支持一个缺省值，对于类类型即指缺省构造函数.所有预定义数据类型包括指针都满足这些限制。

### 6.5 迭代器
要遍历const容器必须用const iterator类型。
iterator算术运算只适用于vector或deque而不适用于list，因为list的元素在内存中不是连续存储的。

### 6.6 顺序容器操作
### 6.7 存储文本行
### 6.8 找到一个子串
### 6.9 处理标点符号
### 6.10 任意其他格式的字符串
### 6.11 其他string操作
### 6.12 生成文本位置map
### 6.13 创建单词排除集
### 6.14 完整的程序
### 6.15 multimap和multiset
### 6.16 栈
### 6.17 队列和优先级队列
### 6.18 回顾iStack类

# 三 基于过程的程序设计
## 7 函数
### 7.1 概述
### 7.2 函数原型
### 7.3 参数传递
```
func(char (&a)[8])	// 数组的引用，要检查元素个数。
func(char  &a [8])	// 非法
func(char (*a)[8])	// 二维数组，等于(char [][8]),a是有8个元素的行指针。
func(char  *a [8])	// 指针数组
```

数组永远不会按值传递，函数参数没有数组类型。`func(int a[10])`相当于`func(int a[])`相当于`func(int* a)`。
缺省参数靠右起，不能隔，按位置解析，习惯上只在声明中写, 后继声明可指定给还没有缺省参数的参数，已有则不能改。

### 7.4 返回一个值
### 7.5 递归
### 7.6 inline函数
注意`inline`指示对编译器来说只是一个建议.会随编译器的实现而不同，如果编译器在调用点上没有内联该函数，则编译器会为该函数生成一个定义或产生警告.因为把一个函数声明为`inline`函数并不见得真的适合在调用点上展开，例如一个递归函数并不能在调用点完全展开，一个1200行的函数也不太可能在调用点展开，一般地`inline`机制用来优化小的只有几行的经常被调用的函数。
`inline`函数和符号常量必须在调用该函数的每个文本文件中定义，不能用`extern`声明。(建议把定义放到头文件中)。

### 7.7 链接指示符: extern "C"
### 7.8 main(): 处理命令行选项
### 7.9 指向函数的指针


## 8 域和生命期
### 8.1 域
### 8.2 全局对象和函数
声明: `extern int a;` 定义: `int a;`
声明: `[extern] void func();` 定义: `void func() {...};`
头文件不应该含有非`inline`函数或对象的定义，但符号常量定义(`const char*`不行, `char* const`可)以及`inline`函数定义是特殊的定义除外，符号常量和`inline`函数可以被定义多次(即声明被放到一个头文件中并且程序的两个独立的文件可同时包含它)，否则用`ifndef`解决。
在文件作用域下声明的`inline`函数和`const`常量默认为`static`类型，可加上`extern`成为外部类型。

### 8.3 局部对象
### 8.4 动态分配的对象
`auto_ptr`: 用另一个`auto_ptr`初始化和赋值会发生所有权的改变。
不能用一个指向内存不是通过应用new表达式分配的指针来初始化或赋值`auto_ptr`;不能让两个`auto_ptr`对象拥有空闲存储区内同一对象的所有权(用同一个指针初始化或赋值两个`auto_ptr`对象或是通过使用`get()`操作)。
动态分配数组不能new时初始化，必须在for循环中(可用memset)被赋初值。
动态分配多维数组，除第一维外必须是常量: `int (*p)[1024] = new int[5][1024];`
动态分配`const`对象必须被初始化(对于具有缺省构造函数的class类型的对象初始值可以省略)，用new表达式返回的值作为初始值的指针必须是一个指向`const`类型的指针。(如:`const int *pci = new const int(1024);`)
定位new表达式并不分配内存。

### *8.5 名字空间定义*
### *8.6 使用名字空间成员*


## 9 重载函数
### 9.1 重载函数声明
重载函数不排除以某种参数调用带来的二义性，若参数个数(缺省参数也是一个参数)或类型不同就可以重载。
```
func(unsign int);
func(int);
```

当一个参数类型是`const`或`volatile`时，在识别函数声明是否相同时并不考虑`const`和`volatile`修饰符。
但是如果把`const`或`volatile`应用在指针或引用参数指向的类型上则在判断函数声明是否相同时就要考虑`const`和`volatile`修饰符。
```
// 声明同一函数
void f( int );
void f( const int );
// 声明同一函数
void f( int* );
void f( int* const );
// 声明了不同的函数
void f( int* );
void f( const int* );
// 也声明了不同的函数
void f( int& );
void f( const int& );
```

一重载函数集合中的函数都是在同一个域中被声明的，即使这些声明可能是用`using`声明或`using`指示符或`extern`引入的。
一个声明为局部的函数将隐藏而不是重载一个全局域中声明的函数。
`using`声明总是为重载函数集合的所有函数声明(引入全部)。
在两个函数指针类型之间不能进行类型转换，也不能用标准转换成`void*`。
链接指示符`extern "C"`只能指定重载此函数集中的一个函数(链接指示符并不影响函数调用时对于函数的选择，只用参数类型来选择将被调用的函数，被选中的函数是与实参类型精确匹配的那个)。因为类型安全链接(名字改编)不适用于用链接指示符`extern "C"`声明的函数，具有不同的参数表的两个`extern "C"`的函数会被链接编辑器视为同一函数。

### 9.2 - 9.4 重载解析的三个步骤 - 参数类型转换 - 函数重载解析细节
函数重载解析的步骤:

1. 确定函数调用考虑的重载函数的候选集合，确定函数调用中实参表的属性。(候选函数: 在调用点上可见的函数(若实参是类类型等见15.10&15.12，若有继承见19.3)。)
1. 从重载函数集合中选择可行函数，该函数可以在(给出实参个数和类型的)情况下用调用中指定的实参进行调用。(可行函数: 对于每个实参都存在到函数参数表中相应的参数类型之间的转换。)
    1. 精确匹配
        s. 无转换: 如引用传递。
        a. 从左值到右值的转换: 值传递时，用实参对形参赋值。
        b. 从数组到指针的转换: 传递数组名
        c. 从函数到指针的转换: 传递函数名
        d. 限定修饰转换(只应用在指针指向的类型):
        ```
		int* i -> const int* i  (d)
		int* i -> int* const i	(a)
		int  i -> const int i	(a)
	    const int* i -> int* i	(不匹配)
        ```
    1. 类型转换匹配
        a. 提升(表示范围扩大)
        b. 标准转换(整值类型转换，浮点转换，浮点—整值转换，指针转换，bool转换)
        c. 用户定义的转换(由转换函数来执行)
    1. 无匹配
1. 划分等级(Ranked: 无转换(非const引用)=左值转换(a,b,c)>const引用>限定修饰转换>提升>标准转换>用户定义的转换)，选择与调用最匹配的函数(最佳可行函数)。
    没有额外修饰符的引用初始化是比较好的引用初始化。
    ```
    int  a = 1;
    int* p = &a;
    ```
    `func(int*& p)` = `func(int* p)` > `func(const int*& p)` > `func(const int* p)`
    转换序列(即多步转换)的等级以构成该序列最坏转换的等级为准。
    标准转换序列: 左值转换->提升或者标准转换->限定修饰转换。
    如果两个转换序列前面都相同，只是一个在序列尾部有一个额外的限定转换，则另一个没有额外限定转换的序列比较好。
    若有一个以上的实参，选择最佳可行函数时必须考虑转换全部实参所需的转换序列的等级。

最后，若没有找到最佳可行函数，则该函数调用是有二义的。

精确匹配可以用一个显式强制转换强行执行，如果因为实参与两个以上可行函数匹配，使得函数重载解析的结果是二义的，则可以用显式强制转换来打破二义性使函数调用被解析为一个特殊的可行函数。
枚举类型定义了一个惟一的类型，它只与枚举类型中的枚举值(不是对应整数)以及被声明为该枚举类型的对象精确匹配。
枚举类型根据枚举常量值的不同可提升为不同的类型，枚举类型不是整型，为0的枚举型值不能被转换成指针类型。
临时值(不能修改，是右值)和常量(实际上转为临时值在赋给引用)不能初始化非`const`引用。
`using`指示符使名字空间成员可见就好像它们是在名字空间之外，在定义名字空间的位置上被声明的一样。


## 10 函数模板
### 10.1 函数模板定义
为了让编译器能够分析模板定义，用户必须指示编译器哪些表达式是类型表达式(加上关键字`typename`)。
模板非类型参数由一个普通的参数声明构成，表示该参数名代表了一个潜在的值，而该值代表了模板定义中的一个常量。
模板每个类型参数前都要有关键字`typename`/`class`。
顺序: `template <typename Type> inline/extern Type min(Type, Type);`

### 10.2 函数模板实例化
在取函数模板实例的地址时，必须能够通过上下文环境为一个模板实参决定一个惟一的类型或值。

### 10.3 模板实参推演
模板实参推演的通用算法:

1. 依次检查每个函数实参，以确定在每个函数参数的类型中出现的模板参数
1. 如果找到模板参数，则通过检查函数实参的类型，推演出相应的模板实参
1. 函数参数类型和函数实参类型不必完全匹配(可以应用:左值转换，限定修饰转换，从派生类到基类类型的转换)
1. 如果在多个函数参数中找到同一个模板参数，则从每个相应函数实参推演出的模板实参必须相同

### 10.4 显式模板实参
当函数模板实参被显式指定时，把函数实参转换成相应函数参数的类型可以应用任何隐式类型转换。
在显式特化中，只需列出不能被隐式推演的模板实参(同缺省实参一样，只能省略尾部的实参)。
显式模板实参应该只被用在完全需要它们来解决二义性或在模板实参不能被推演出来的上下文中使用模板实例时。

### 10.5 模板编译模式
分离编译模式中，关键字export不需要出现在头文件的模板声明中，一个函数模板只能被定义为export一次。
尽管程序不能确切地知道编译器在何时何地实例化函数模板，但是它必须表现得好像对一个特定的模板实参集合只实例化一次模板。
显式实例化声明来帮助程序员控制模板实例化发生的时间.对于给定的函数模板实例，显式实例化声明在一个程序中只能出现一次.在显式实例化声明所在的文件中，函数模板的定义必须被给出，否则该显式实例化声明是错误的。

### 10.6 模板显式特化
如果模板实参可以从函数参数中推演出来，则模板实参的显式特化可以从显式特化声明中省略。
即使函数模板显式特化所指定的函数模板只有声明而没有定义，仍然可以声明函数模板显式特化。
一个程序不能对相同的模板实参集的同一模板同时有一个显式特化和一个实例。

### 10.7 重载函数模板
为实例选择的模板函数是最特化的。

### 10.8 虑模板函数实例的重载解析
重载解析确立一个函数的过程只看其声明。
普通函数和函数模板的函数重载解析步骤:

1. 生成候选函数集。考虑与函数调用同名的函数模板。如果对于该函数调用的实参模板实参推演能够成功，则实例化一个函数模板或者对于推演出来的模板实参存在一个模板特化，则该模板特化就是一个候选函数。模板显式特化不会自动进入候选函数集，只有模板实参推演成功的模板特化才被考虑。
1. 生成可行函数集，只保留候选函数集中可以用函数调用实参调用的函数。
1. 对类型转换划分等级，如果该调用是二义的(非模板函数被给予更高的优先级)，则从可行函数集中去掉函数模板实例。
1. 只考虑可行函数集中的普通函数，完成重载解析过程。

### 10.9 模板定义中的名字解析
模板定义中的名字解析分两个步骤，被解析的名字必须有前向声明:

* 不依赖于模板参数的名字在模板定义时被解析
* 依赖于模板参数的名宇在模板被实例化时被解析

函数模板的实例化点总是在名字空间域中，并且跟在引用该实例的函数后。
当模板实例要多次使用时就有多个实例化点，编译器自由选择这些实例化点之一来真正实例化该函数模板，这意味着在组织代码时，必须把解析依赖于模板参数的名字所需要的声明放置在模板的第一个实例化点之前。

### 10.10 名字空间和函数模板
函数模板的显式特化声明必须被声明在该通用模板被定义的名字空间内。

### 10.11 函数模板示例


## 11 异常处理
### 11.1 抛出异常
### 11.2 try块
一个try块引入一个局部域，在try块内声明的变量不能在try块外被引用，包括在catch子句中。

### 11.3 捕获异常
```
try {
    throw(obj);
} catch(ExClass& obj) { // 传值或引用throw的对象，一般声明为&
}
```

异常对象总是在抛出点被创建，即使throw表达式不是一个构造函数调用或者它没有表现出要创建一个异常对象。
一旦异常被处理(抛出)，程序的执行就不能够在异常被抛出的点继续，一层层向外寻找该异常的catch子句。一旦找到匹配，则后续的catch子句就不在检查，并继续执行catch子句之后的语句。
如果一个程序没有为已被抛出的异常提供catch子句，调用C++标准库中定义的函数`terminate()`，其缺省行为是调用`abort()`指示从程序非正常退出。
被重新抛出`throw;`的异常就是原来的异常对象。
`catch(...)`捕获任何异常，必须放在最后。

### 11.4 异常规范
异常规范: 在函数(或函数指针)声明后可指明抛出的全部异常`void fn() throw(ExType1,ExType2);`，同一函数的重复声明必须一样，保证不会抛出其他异常。若抛出了其他异常，而没有在该函数结束之前捕获，则系统调用`unexpected()`，其缺省行为是调用`terminate()`。
空的异常规范保证函数不会抛出任何异常`void fn() throw();`。如果一个函数声明没有指定异常规范，则该函数可以抛出任何类型的异常。
函数异常规范的违例只有在运行时刻才能被检测到，若没有执行到抛出的语句则没有错误，否则系统调用`unexpected()`。
在被抛出的异常类型与异常规范中指定的类型之间不允许类型转换。
用作初始值或右值的指针异常规范必须与被初始化或赋值的指针异常规范一样或更严格(右比左严格)。

### 11.5 异常与设计事项
不能在局部函数内解决问题，因为这些错误不能在函数中被处理，所以我们决定抛出异常，以便通知使用该库的程序。
决定一个库抛出哪些异常是库设计的一个重要阶段，如果该库希望被用在不会崩溃的程序中，那么该库必须自己处理问题，或者如果它不能处理的话则必须把程序的不正常情况通知给使用该库的程序部分，在库代码本身没有可采取的有意义动作时，让调用者选择应该采取什么行动决定。把哪些情况应该当作异常来处理是库设计中很难的一部分。


## 12 泛型算法
### 12.1 概述
### 12.2 使用泛型算法
### 12.3 函数对象
函数指针的主要性能缺点是它的间接引用使其不能被内联。对函数指针的替代策略是函数对象，函数对象是一个类，它重载了调用操作符`()`，该操作符封装了通常应该被实现为一个函数的动作。它有两个方面的优点：如果被重载的调用操作符是inline函数，则编译器能够执行内联编译，提供可能的性能好处；函数对象可以拥有任意数目的额外数据，用这些数据可以缓冲结果，也可以缓冲有助于当前操作的数据。
标准库还提供了一组函数适配器(adaptor)，用来特殊化或者扩展一元和二元函数对象。适配器是一种特殊的类，分为两类：绑定器(binder)通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象；取反器(negator)是一个将函数对象的值翻转的函数适配器。

### 12.4 回顾iterator
`const`容器只能被绑定在`const iterator`上。
使用专门的`istream_iterator`缺省构造函数定义结束位置，用作`iterator`对的结束标记。
五种`iterator`，适用性逐渐变高(前2个一样):

* InputIterator	可以被用来读取容器中的元素，但是不保证支持向容器的写入操作。
* OutputIterator 可以被用来向容器写入元素，但是不保证支持读取容器的内容。
* ForwardIterator 可以被用来以某一个遍历方向，向容器读或写。
* BidirectionalIterator	从两个方向读或写一个容器。
* RandomAccessIterator 除了支持BidirectionalIterator所有的功能外，还可在常数时间内访问容器的任意位置。

### 12.5 泛型算法
所有泛型算法(带有相当多异常，这些异常也构成了相应的规则)的前两个实参都是iterator对，通常被称为first和last，它们标记出要操作的容器或内置数组中的元素范围:[first,last)，当(first == last)时范围为空。

### 12.6 何时不用泛型算法

# 四 基于对象的程序设计
## 13 类
### 13.1 类定义
因为只有当一个类的类体已经完整时，它才被视为已经被定义，所以一个类不能有自身类型的数据成员(静态可以)。但是当一个类的类头被看到时，它就被视为已经被声明了，所以一个类可以用指向自身类型的指针或引用作为数据成员。(在类的定义中实现成员函数时，使用的类型必须已被定义)

### 13.2 类对象
缺省情况下拷贝一个类对象与拷贝它的全部数据成员等价(指赋值)。

### 13.3 类成员函数
只有被声明为const的成员函数才能被一个const类对象调用。
标识符位置:

* default parameter:仅在声明中。
* inline:仅在定义中(才起作用)。
* const(function):同时。
* static:仅在声明(类定义)中。
* virtual:仅在声明(类定义)中，只需在根基类中，以下派生类可以省略。

把一个成员函数声明为const可以保证这个成员函数不修改类的数据成员，但不能保证在调用成员函数期间类对象引用的所有东西都保持不变(如类成员指针所指的对象)。
const成员函数可以被相同参数表的非const成员函数重载，类对象的常量性决定了调用哪个函数.构造函数和析构函数是两个例外，因为一个const类对象从"构造完成时刻到析构开始时刻"这段时间内才被认为是const的。(volatile同)
即使一个const对象的数据成员我们也可以声明为mutable.即使是在一个const成员函数中,mutable成员总可以被更新。

### 13.4 隐含的this指针
this指针: 非const成员函数中它的类型是指向该类类型的指针，在const成员函数中是指向const类类型的指针。

### 13.5 静态类成员
静态数据成员必须要被定义在类定义之外并可初始化(因为类定义不分配空间)，但有序型(数组不是)的const静态数据成员可以在类体中用一常量值初始化，该成员必须仍然要被定义在类定义之外，不能再指定初始值。
静态成员是属于该类的全局对象和函数(编译时就已分配空间和初始化)，静态成员函数没有this指针，不能访问非静态成员。
静态数据成员的类型可以是该类的对象，而非static数据成员只能被声明为该类的对象的指针或引用。静态数据成员可以被作为类成员函数的缺省实参，而非static成员不能。

### 13.6 指向类成员的指针
普通指针不能被赋值为类成员的地址，虽然普通指针和类成员指针都被称作指针，但是它们是不同的事物(静态除外)。
静态类成员指针是普通指针，解引用该指针不需类对象。
指向类数据成员的指针: `int MyClass::* pm_iMember = &MyClass::m_iMember`
指向类成员函数的指针: `void (MyClass::* pFunc)(int a) = MyClass::Func`
调用:
```
MyClass obj;
MyClass* pObj;
obj.*pm_iMember = 1;
(obj.*pFunc)(1);
pObj->*pm_iMember = 1;
(pObj->*pFunc)(1);
```

### 13.7 联合：一种节省空间的类
union是特殊的类，可以为union定义成员函数包括构造函数和析构函数。
union的成员可以被声明为公有私有或保护的(默认公有)，union不能有静态数据成员或是引用成员，如果一个类类型定义了构造函数析构函数或拷贝赋值操作符则它不能成为union的成员类型。
匿名union: 没有名字的union，它后面也没有跟着对象定义。其数据成员可以在定义匿名union的域中被直接访问，不能有私有或保护的成员也不能定义成员函数.在全局域中定义的匿名union必须被声明在未命名的名字空间中(或者被声明为static)。

### 13.8 位域(bit-field)：一种节省空间的成员
位域是特殊的类数据成员.由于取地址操作符&不能被应用在位域上，所以也没有能指向类的位域的指针，位域也不能是类的静态成员。
如果可能的话它们会被放在同一个整数的连续位中并以此提供空间压缩。
eg:
```
class MyClass { int mode_a:4; int mode_b:8 };	//有4bit,8bit
sizeof(MyClass);				//4byte,用一个整形存储
```

### 13.9 类域
在类定义中用到的名字必须在使用前首先被声明(只有前面的可见)。被用在inline成员函数定义中的名字和被用作缺省实参的名字(静态)以及类成员的定义在类体之外，则所有类成员声明都可见。
在类体之外的类成员定义中，在被定义的成员名字之前的程序文本(类中的自定义类型标识)不在该类的域内，要用域解析操作符。
类成员函数定义中的名字解析(覆盖)顺序: 局部域->类成员(先嵌套后外围)->外围(之前)的名字空间域。
显式调用: this, ::(全局)

### 13.10 嵌套类
嵌套类是其外围类的一个成员。
嵌套与外围类的私有成员不能互相访问(需要友元).如果没有权限限制，对嵌套(外围)的非静态成员的访问都要求通过嵌套(外围)类的指针引用或定义对象来完成。而对于静态成员，枚举值，类型名(typedef名字，枚举类型名，类名)，可以直接访问(在类外访问要求域解析符ClassName::，也用于区分相同名字的成员)。
只有在名字解析成功之后，编译器才会检查访问许可和类型兼容性。

### *13.11 作为名字空间成员的类*
### 13.12 局部类
因为没有语法能够在名字空间域内定义局部类的成员，所以也不允许局部类声明静态数据成员。同嵌套类一样，局部类只能访问在外围局部域中定义的类型名，静态变量以及枚举值。


## 14 类的初始化赋值和析构
### 14.1 类的初始化
显式初始化表`={ , , ,}`只能被应用在所有数据成员都是公有的类的对象上，即不支持使用数据封装和抽象数据类型。但用常量值初始化大型数据结构比较有效。

### 14.2 类的构造函数
缺省构造函数: 没有参数或者全部都有缺省参数。
```
Account newAccount;	//定义一个对象，调用缺省构造函数。
Account newAccount();	//声明一个函数，返回类类型。
```
类对象的动态数组在分配内存的时候要求或者有缺省构造函数或者没有构造函数。
成员初始化表(`:`标识)只能在构造函数定义中被指定而不是在其声明中。
构造函数不能用const/volatile关键字来声明。
一般如果不存在缺省构造函数，系统既不生成缺省构造函数也没有调用它.对于含有类数据成员或继承来的比较复杂的类，可能会生成一个缺省构造函数，但是它不会为内置或复合型的数据成员如指针或数组提供初始值。
非公有的构造函数的主要用处是:

1. 防止用一个类的对象向该类另一个对象作拷贝。
1. 指出只有当一个类在继承层次中被用作基类，而不能直接被应用程序操纵时，构造函数才能被调用。

拷贝构造函数只在初始化(见14.6)而非赋值时调用，一般只有一个拷贝构造函数且参数用const标识。
步骤:

1. 如果声明了拷贝构造函数，并且是可以访问的，则调用它;
1. 如果声明了拷贝构造函数，但是不可访问，则就是一个编译时刻错误;
1. 如果没有声明拷贝构造函数的实例，则执行缺省的按成员初始化。

### 14.3 类的析构函数
析构函数不返回任何值，也没有任何参数，不能被重载，只能提供一个析构函数。
对于堆上的类对象，最好是用`auto_ptr`而不是一个实际的指针，否则的话如果应用`delete`表达式失败，比如一个异常被抛出的情况下不仅会导致内存泄漏而且析构函数也不会被调用。
只有当`delete`表达式中的指针指向一个带有析构函数的类类型时，才调用析构函数。

### 14.4 类对象数组和vector
对于对象数组，如果我们希望指定多个实参，则需要使用完整的构造函数语法，例如`Account pooh_pals[] = {Account( "Piglet", 1000.0 ), Account( "Eeyore", 1000.0 ), Account( "Tigger", 1000.0 )}`
`delete`中`[]`的存在会使编译器获取数组的大小size，然后析构函数再被依次应用在每个元素上，一共size次，否则只有一个元素被析构。无论哪种情况下分配的全部空间都被返回给自由存储区。

### 14.5 成员初始化表
### 14.6 按成员初始化
"用一个类对象初始化该类另一个对象"发生在下列情况下:

* 用一个类对象显式地初始化另一个类对象。
* 把一个类对象作为实参传递给一个函数。
* 把一个类对象作为一个函数的返回值传递回来。
* 非空顺序容器类型的定义。
* 把一个类对象插入到一个容器类型中。

### 14.7 按成员赋值
COPY|浅(缺省)|深(自定义，覆盖缺省)
-|-|-
初始化|按成员|copy构造函数
赋值|按成员|重载操作符"="

步骤:

1. 检查该类判断它是否提供了一个显式的拷贝赋值操作符。
1. 如果是则检查访问权限判断是否在这个程序部分它可以被调用。
1. 如果它不能被调用则会产生一个编译时刻错误否则调用它执行赋值操作。
1. 如果该类没有提供显式的拷贝赋值操作符则执行缺省按成员赋值。
1. 在缺省按成员赋值下每个内置类型或复合类型的数据成员被赋值给相应的成员。
1. 对于每个类成员对象递归执行l 到6 步直到所有内置或复合类型的数据成员都被赋值。

一般来说应该将拷贝构造函数和拷贝赋值操作符视为一个个体单元，因为在我们需要其中一个的时候往往也需要另外一个，而试图禁止一个的时候也很可能需要禁止另一个。

### 14.8 效率问题
C++语言不能有效地返回一个类对象，这被视为C++语言的一个重大缺陷。
类对象的初始化总是比赋值更有效率。


## 15 重载操作符和用户定义的转换
### 15.1 操作符重载
当一个重载操作符是一个名字空间的函数时，对于操作符的第一个和第二个参数，即等于操作符的左和右两个操作数都会考虑转换。
如果一个重载操作符是类成员，那么只有当跟它一起被使用的左操作数是该类的对象时(不会转换)，它才会被调用。如果该操作符的左操作数必须是其他的类型，那么重载操作符必须是名字空间成员。
C++要求赋值`=`，下标`[]`，调用`()`，和成员访问箭头`->`操作符必须被定义为类成员操作符。
只能为类类型或枚举类型的操作数定义重载操作符，即至少有一个类或枚举类型的参数。
除了`operator()`外，对其他重载操作符提供缺省实参都是非法的。

### 15.2 友元
友元声明只能出现在类定义中，友元不是授权类的成员。
只有当一个类的定义已经被看到时，它的成员函数才能被声明为另一个类的友元。

### 15.3 操作符=
一个C风格字符串的类型是`const char*`，不能当参数传给`char*`。

### 15.4 操作符[]
### 15.5 操作符operator()
### 15.6 操作符->
重载的成员访问操作符`->`的返回类型必须是一个类类型的指针，或者是定义该成员访问操作符箭头的类的一个对象。

### 15.7 操作符++和--
### 15.8 操作符new和delete
当new表达式创建一个类类型的对象时，编译器查看该类是否有一个成员操作符`new()`，如果有则选择这个操作符为该类对象分配内存，否则调用全局操作符`new()`。(delete同)
操作符`new()`和`delete()`都是类的静态成员，这些操作符被自动做成静态成员函数而无需显式地声明。

### 15.9 用户定义的转换
转换函数: `operator type();`这里的type可用内置类型类类型或typedef名，但是不允许数组或函数类型，转换函数必须是成员函数，它的声明不能指定返回类型和参数表。
显式的强制类型转换会导致调用转换函数。
为了只允许对被转换的类对象进行只读访问，转换操作符必须返回一个const类型:
```
typedef const char* cchar;
operator cchar() { return p; }
```
在用户定义的转换之后只允许标准转换序列。如果为了到达目标类型必须应用第二个用户定义的转换，则编译器不会隐式应用任何转换。
只带一个参数的构造函数都定义了一组隐式转换，把构造函数的参数类型转换为该类的类型(即与转换函数执行相反的操作)。
如果需要，编译器会在调用构造函数执行用户定义的转换之前，在实参上应用标准转换序列。
防止构造函数进行隐式类型转换，可以把它声明为`explicit`，但仍可以强制转换的形式显式地转换。

### 15.10 选择一个转换
用户定义的转换序列:标准转换序列->用户定义的转换->标准转换序列，如果使用不同的用户定义转换(一样好)，则产生二义性。
不能用显式强制类型转换来解决全部的二义性问题，因为针对这个显式强制转换的转换函数和构造函数都会被考虑。可显式地调用转换函数或构造函数解决。
ADL: 如果一个函数调用的实参是一个类类型的对象，类类型的指针，类类型的引用或者是指向类成员的指针，则候选函数是在调用点可见的函数，在定义该类的名字空间中声明的函数以及在类成员表中声明为友元的函数的并集。
一旦找到了一个函数声明，则查找"在调用点可见的候选函数"的过程马上结束，如果重载解析过程因为在候选函数集中没有最佳匹配函数或发现该调用是二义的则该函数调用就是错误的，不会进一步查找外围域中是否存在与函数调用实参匹配更好的其他候选函数。

### 15.11 重载解析和成员函数
即使成员函数通过类名和域解析操作符`MyClass::mf()`来调用，或者没有通过`obj.func(); pObj->func()`来调用，非静态成员函数仍然被包含在该调用的可行函数集中.如果被选中的最佳可行函数是非静态成员函数，则会因为该调用没有指定对象而编译错误。
对于const对象，只有const成员函数才可以被调用。静态成员函数不能被声明为const或volatile,但仍然被包含在该const对象调用的可行函数集中。

### 15.12 重载解析和操作符
本节描述的操作符的重载解析过程只适用于使用操作符语法时，如果使用了函数调用语法则使用普通函数的重载解析过程。
如果一个操作符只有内置类型的操作数，则函数重载解析过程不会被应用，即使不能应用操作符或即使这些操作数可以通过用户定义的转换被转换成操作符重载函数要求的类型。
使用操作符语法并带有类类型操作数的操作符，则候选函数是在调用点可见的操作符，在定义该类的名字空间中声明的操作符，在类成员表中声明为友元的操作符，在左操作数的类中被声明的成员操作符，内置操作符集合的并集。


## 16 类模板
### 16.1 类模板定义
类模板的参数可以有缺省实参，这对类型参数和非类型参数都一样，是一个类型或值。
只有在类模板自己的定义中，定义自己类型的变量可以省略参数表。

### 16.2 类模板实例化
声明一个类模板实例的指针和引用不会引起类模板被实例化。
绑定给非类型参数的表达式必须是一个常量表达式(类似非动态定义数组元素个数)，非const对象的值不是一个常量表达式,sizeof表达式的结果是一个常量表达式，名字空间域中任何对象的地址(即使该对象不是const)类型是一个常量表达式，而局部对象的地址则不是。
在模板实参的类型和非类型模板参数的类型之间允许进行一些转换，能被允许的转换集是函数实参上被允许的转换的子集:左值转换，限定修饰转换，提升，整值转换(把整型0转换成指针值的转换是不允许的)。

### 16.3 类模板的成员函数
当类模板被实例化时，类模板的成员函数并不自动被实例化，只有当一个成员函数被程序用到函数调用或取地址时，它才被实例化，类模板的成员函数被实例化的时间会影响到在类模板成员函数定义中名字的解析，可以声明一个成员函数特化的时间。

### 16.4 类模板中的友元声明
有三种友元声明可以出现在类模板中:

1. 非模板友元类或友元函数: 友元类和函数不必在全局域中被声明或定义，一个类成员只能由该类的定义引入。(友元是类成员，该类定义必须可见)
```
friend class MyClass;
friend void fn(QueueItem<Type>);
```
1. 绑定的友元类模板或函数模板(1对1):
```
friend class MyClass<Type>;
friend void fn<Type>(QueueItem<Type>);
```
1. 绑定的友元类模板或函数模板(1对多):对于每一个类实例，模板类和函数的所有实例都是友元。
```
template <class T> friend class MyClass;
template <class T> friend void fn(QueueItem<T>);
```

### 16.5 类模板的静态数据成员
一个静态数据成员的实例在被引用的时候，总是要通过一个特定的类模板实例。
在嵌套类模板的实例和外围类模板的实例之间的映射是一对一的，当外围类模板被实例化时它的嵌套类不会自动被实例化。
一般的程序只能引用该嵌套类型的一个实例，此时嵌套类型的名字前必须要加上类模板实例的名字`OuterClass<int>::InnerClass`。

### 16.6 类模板的嵌套类型
### 16.7 成员模板
### 16.8 类模板和编译模式
只有当上下文环境要求类模板的完整类定义时，类模板才被实例化.只有当编译器看到了实际的类模板定义，而不仅仅只是声明时，它才能实例化类模板。
可导出的类模板的声明是在类模板的定义或者声明的关键字`template`之前加上关键字`export`。
显式实例化类模板时，它的所有成员也被显式实例化，而且针对同一组模板实参类型。在显式实例声明出现的地方不但要提供类模板的定义，而且还要提供类模板成员的全部定义。

### 16.9 类模板特化
成员函数的显式特化定义是函数定义而不是模板定义。
只有当通用的类模板被声明(不一定被定义)之后，它的显式特化才可以被定义。
即使我们定义了一个类模板特化，也必须定义与这个特化相关的所有成员函数或静态数据成员。
类模板不能够在某些文件中根据通用模板定义被实例化，而在其他文件中却针对同一组模报实参被特化。

### 16.10 类模板部分特化
类模板部分特化也是一个模板，它的定义看起来就像一个模板定义。
使用类模板部分特化时，它是被隐式实例化的。

### 16.11 类模板中的名字解析
类模板的实例化点总是在名字空间域中，而且它总是在引用类模板实例的声明或定义之前;类模板的成员函数或静态数据成员的实例化点也总是跟在引用类模板成员实例的声明或定义之后 。
当类模板被实例化时，类模板实例的成员不会自动被实例化，只有当程序用到这些成员时，它们才被实例化。

### 16.12 名字空间和类模板
### 16.13 模板数组类

# 五 面向对象的程序设计

## 17 类继承和子类型
### 17.1 定义一个类层次结构
前向声明不足以使其被用作基类，派生类的前向声明不能包括它的派生表(而只是类名，与非派生类一样)。

### 17.2 确定层次的成员
### 17.3 基类成员访问
基类和派生类属于不同的域，派生类的同名成员会隐藏基类的成员(可以显式调用`Base::`)。
using声明可将同名成员函数都引入派生类中(`using Base::fn`，增加全部重载实例)。
派生类不能访问另一个独立的基类对象的`protected`成员，但可以直接访问另一个独立的该类(此派生类)对象的`protected`基类成员以及该类的对象的`protected`和`private`成员。
基类指针只能访问在该类中被声明或继承的数据成员和成员函数，包括虚拟成员函数，而与它可能指向的实际对象无关，把一个成员函数声明为虚拟的只推延了"在程序执行期间根据指向的实际类类型，对于要调用的实例的解析过程"。
友元关系不能被继承。

### 17.4 基类和派生类的构造
构造顺序(析构相反):

1. 基类构造函数.如果有多个基类，调用顺序是基类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
1. 成员类对象构造函数.如果有多个成员类对象，调用顺序是对象在类中被声明的顺序，而不是它们在成员初始化表中的顺序。
1. 派生类构造函数。

作为一般规则，派生类构造函数应该不能直接向一个基类数据成员赋值，而是把值传递给适当的基类构造函数.否则，两个类的实现变成紧耦合的(tightly coupled)，将更加难于正确地修改或扩展基类的实现。
派生类初始化时要调用基类(类成员对象)构造方法，可显式调用`:Sub(int v):Base(v)`，若不显式调用，则要求基类或者有缺省构造函数或者没有构造函数；对类成员对象也一样`:Sub(int v):meb(v);`，顺序:基类->类成员->自己，静态成员最先初始化。
派生类并不继承基类的构造函数(不能用它来初始化)，只能合法地调用其直接基类的构造函数。

### 17.5 基类和派生类虚拟函数
只有类的成员函数才能，静态，内联(因为不能在运行中动态确定其位置，即使放在类定义中也被认为非内联)，构造函数不能，析构可以而且通常声明为虚函数。
虚拟函数机制只在使用指针和引用时才会如预期般地起作用，只有在通过基类指针或引用间接指向派生类子类型时，多态性才会起作用。
用一个派生类对象初始化(或赋值)一个基类对象是合法的，在初始化基类对象之前，派生类对象的派生部分被"切除"。
用一个基类对象初始化(或赋值)一个派生类引用，要用`dynamic_cast`转换(也可转换指针)。
派生类的虚函数实例的原型必须与基类实例完全匹配，返回值也必须相同(特例，派生类实例的返回值可以是:基类实例返回类型的公有派生类类型)。
静态调用:当用类域操作符调用虚拟函数时，就改变了虚拟机制，使得虚拟函数在编译时刻被静态解析`p->Base::fn()`。
纯虚函数仍可有定义，可以被静态调用，但所在的类是抽象类，不能实例化对象。
缺省实参不是在运行时刻决定的，而是在编译时刻根据被调用函数的对象的类型决定的(函数仍多态调用)，如果通过基类指针或引用调用派生类实例，则传递给它的缺省实参是由基类指定的。(如果确实希望函数的实际缺省实参是根据被调用函数的实际实例而决定的，一种方案是:只指定一个缺省实参，用来指示"用户并没有提供参数",而真正的缺省实参被声明为函数中的局部变量，如果没有参数传递进来，则使用该局部变量)
若要动态分配对象，一般只将类层次结构的根基类(声明了一个或多个虚拟函数)的析构函数声明为虚拟的(函数名不一样，析构函数仍多态调用)，且一般不应该是`protected`(虚拟函数承接了"调用者所属类类型"的访问级别)，否则当派生类对象通过基类指针(调用者，承接基类访问级别，即使派生类是`public`)调用析构函数时，只会调用基类的而不会调用派生类的析构函数。
如果派生类没有实现纯虚函数，就仍是抽象类(即使基类有纯虚函数的定义)。
定义一个派生类对象，当执行基类的构造函数时，派生类部分还没有被初始化，实际上此时对象只是一个基类类型的对象.因此，在基类构造函数中调用的虚拟函数总是基类的虚拟函数(原因:如果在基类的构造函数中调用了一个虚拟函数，而基类和派生类都定义了该函数的实例，如果调用虚拟函数的派生类实例并且它访问任意的派生类成员，那么调用的结果在逻辑上是未定义的，而且程序可能会崩溃).对于派生类对象，在基类析构函数中也是如此，派生类部分也是未定义的，但是这一次不是因为它还没有被构造，而是因为它已经被销毁，因此也只会调用基类的虚拟函数实例。

### *17.6 按成员初始化和赋值*
### *17.7 UserQuery管理类*
### *17.8 组合起来*


## *18 多继承和虚拟继承*


## 19 C++中继承的用法
### 19.1 RTTI
`dynamic_cast`操作符允许在运行时刻进行类型转换(常常被称为安全的向下转换downcasting)，从而使程序能够在一个类层次结构中安全地转换类型，把基类指针转换成派生类指针或把指向基类的左值转换成派生类的引用(只有在保证转换能够成功的情况下才可以).被转换的类类型必须带有虚函数。
当我们必须使用派生类的特性，而该特性又没有出现在基类中时常常使用`dynamic_cast`。用指向基类类型的指针来操纵派生类类型的对象，通常通过虚拟函数自动处理;但是在某些情形下，使用虚拟函数是不可能的,`dynamic_cast`为这些情形提供了替代的机制，但是这种机制比虚拟成员函数更易出错，应该小心使用。
如果指针或左值操作数不能被转换成目标类型，则`dynamic_cast`将失败:如果针对指针类型的`dynamic_cast`失败，则`dynamic_cast`的结果是0；如果针对引用类型的`dynamic_cast`失败，则`dynamic_cast`会抛出一个`std::bad_cast`类型的异常。
为了要获取到派生类类型，typeid的操作数必须是一个带有虚拟函数的类类型，且不能是类的指针类型(头文件`<typeinfo>`)。

### 19.2 异常和继承
被选中的catch子句是最先匹配到的，在catch子句列表中最特化的catch子句必须先出现。
throw表达式重新抛出的是原来的异常对象，对于一个异常对象，直到该异常的最后一个catch子句退出时它才被销毁。
派生类虚拟函数的异常规范必须与基类虚拟函数的异常规范一样或者更严格。
如果一个异常规范指定了一个类，则该函数可以抛出从该类公有派生的类类型的异常对象(对指针类似)。
使用函数try块是保证在构造函数中捕获所有在对象构造期间抛出的异常的惟一解决方案。
如:
```
inline
Account::Account(const char* name, double opening_bal)
try
      : _balance(opening_bal - serviceCharge())
{
      _name = new char[strlen(name)+1];
      strcpy(_name, name);
      _acct_nmbr = get_unique_acct_nmbr();
} catch (...) {
      // 特殊处理
      // 现在能够捕获来自 ServiceCharge() 的异常了
}
```

### 19.3 重载解析过程和继承
如果普通函数调用的实参是类类型的对象，类类型的指针或类类型的引用，则候选函数是以下集合的并集:

1. 在调用点上可见的函数
1. 在"定义该类类型的名字空间"或"定义该类的基类的名字空间"中声明的函数
1. 该类或其基类的友元函数

派生类中的成员函数声明并没有重载基类中声明的同名成员函数，相反派生类中的成员函数隐藏了基类中同名成员函数的声明，即使函数参数表并不相同。
在多继承下建立候选成员函数集时，成员函数的声明必须在同一个基类中被找到，否则该调用就是错误的。


## 20 iostream库
### 20.1 输出操作符<<
`const char* p`被`<<`解释成字符串，要输出地址值：`static_cast<void*>(const_cast<char*>(p))`。

### 20.2 输入
数值的读比数值的写操作，更可能导致iostream错误;输入操作符的连接，因为无法测试读操作的错误而更易出错。
有两种情况会使一个istream对象被计算为false:读到文件结束，在这种情况下我们已经正确地读完文件中所有的值或遇到一个无效的值。在读入一个无效值的情况下istream对象被放置到一种错误的状态中(failbit)，并且对于值的所有读入动作都将停止，但对读取操作没有影响。

### 20.3 其他输入/输出操作符
istream: get, ignore, gcount, getline, read
ostream: put, putback, unget, peek

### 20.4 重载输出操作符<<
`operator << (ostream& os, const ClassType& object)`
重载时，操作符必须定义为非成员形式；当操作符要求访问非公有成员时必须将它声明为该类(ClassType)的友元。

### 20.5 重载输入操作符>>
`operator >> (istream& is, const ClassType& object)`
由于不正确的格式而导致失败，istream应该把状态标记为fail。对错误状态中的iostream，插入和提取操作没有影响。

### 20.6 文件输入和输出
ofstream文件可以被打开为输出模式`ios_base::out`或附加模式`ios_base::app`,ifstream类对象可以打开一个被用于输出或者输入的文件`ios_base::in`。当文件以(append)打开，打开时指针在文件头，但总在文件尾写操作，每次写操作后又会把指针定位在文件尾.若要修改已有文件内容应以(in|out)方式打开，覆盖而不是插入，只用(out)会清除原有内容。
`seekg()`, g表示为了获取getting字符而定位，输入流的指针; `seekp()`, p表示为放置字符putting而定位，输出流的指针。
对于fstream对象来说, `seekg()`与`seekp()`等价, `tellg()`与`tellp()`等价，定位指针只有一个(位置类型`:ios::pos_type`)。若要以append模式打开，则应(out|app)。
若fstream处于遇到文件结束符的状态，就不能再执行输入和输出操作，解决方法是调用`clear()`清除文件的这种状态。

### 20.7 条件状态
监视流的当前状态:

* 如果一个流遇到文件结束符，则`eof()`返回true。
* 如果试图做一个无效的操作，比如seeking重定位操作超出了文件尾，则`bad()`返回true。
* 如果操作不成功，比如打开一个文件流对象失败或遇到一种无效的输入格式，则`fail()`返回true。
* 如果其他条件都不为true, 则`good()`返回true。

读写状态(ios_base::badbit, ios_base::eofbit, ios_base::failbit, ios_base::goodbit): `clear()`, `setstate()`, `rdstate()`。

### 20.8 string流
### 20.9 格式状态
当操作符带有一个实参，就必须包含iomanip头文件。
缓冲区可能会满(一般是标准输出)，在这种情况下，它必须被刷新(真正写入，不是清空stream,清空的是buffer)，以便读取后面的值。显式地使用`flush`, `ends`或`endl`操作符来刷新缓冲区。
unitbuf是一个内部的流状态变量，若它被设置，则每次输出操作后都会清空缓冲区。
ostream对象可以捆绑到istream上，在这种情况下，当istream从输入流读取数据时，ostream的缓冲区就会被刷新，`cout`被预定义捆绑在`cin`上。
`setw()`不修改ostream对象的格式状态，仅一次有效。

### 20.10 强类型库
</xmp>
<script src="js/strapdown.js"></script>
</html>
