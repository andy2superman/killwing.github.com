<!DOCTYPE html>
<html>
<title>Journey to the Stack</title>
<xmp theme="readable" style="display:none;">
http://duartes.org/gustavo/blog/post/journey-to-the-stack/

早些时候我们研究了[程序在内存中的剖析](anatomy-of-a-program-in-memory.md.html)，是关于程序是怎样在计算机里运行的一个环境。现在我们转向大多数编程语言和虚拟机的执行主力--*调用栈*。沿途我们将遇到一些神奇的东西如闭包，递归以及缓存溢出。但第一步是栈是如何运作的一幅精确描述。

栈之所以重要因为它跟踪了程序中函数的运行，而函数是建造软件的砖块。实际上，程序的内部运作一般非常简单。它包括大部分函数互相调用的时候把数据压到栈上以及把数据从栈上弹出，同时在堆上为数据分配的内存在函数调用期间始终有效。无论对于底层用C写的软件还是基于虚拟机语言如JavaScript和C#的程序都是如此。真正掌握了这个事实对于程序调试，性能调优和要了解到底特么发生了什么是非常有用的。

当一个函数被调用，一个**栈帧**被创建来支持函数的执行。这个栈帧包含了函数的*局部变量*和调用者传递给这个函数的*参数*。同时也包含了允许被调用函数安全地返回到调用者所需要的辅助信息。栈具体的实际内容和布局根据处理器架构和函数调用约定的不同而不同。本文我们只关注Intel x86架构的栈和使用C风格的调用约定(`cdecl`)。这里是位于栈顶的一个单独的栈帧：
![stackIntro](img/stack/stackIntro.png)

此刻一并出现了三个CPU寄存器。*栈指针*`esp`指向栈顶。栈顶总是被*最后一个压入*栈的但*还没有被弹出*栈的项目占据，就像现实中的一堆碟子或一叠钞票。

`esp`里保存的地址一直随着栈项目的压入和弹出而改变，因此它总是指向最后一个项目。许多CPU指令自动更新`esp`作为其副作用，缺了这个寄存器而使用栈是不可能的。

在Intel架构中，大多数情况下栈向*低内存地址*增长。因而“顶”是栈中最低的内存地址，这里它包含数据`local_buffer`。注意关于从`esp`到`local_buffer`的箭头的真意：它*明确地*指向`local_buffer`占据的*第一个字节*，因为这就是`esp`里保存的确切地址。

第二个跟踪栈的寄存器是`epb`，称为*基准指针*或*帧指针*。它指向*当前执行*的函数栈帧中的一个固定的位置，以及为访问参数和局部变量提供了一个固定的引用点。`ebp`只在一个函数调用开始和结束的时候改变。因此我们可以很容易地以`ebp`偏移的方式寻址到栈中的每个项目（如上图）。

不像`esp`，`ebp`大多数情况CPU很少干预而是由程序代码维护。有时候，通过[编译选项](http://stackoverflow.com/questions/14666665/trying-to-understand-gcc-option-fomit-frame-pointer)尽量不使用`ebp`寄存器可以提高性能。Linux内核就是这么做的一个例子。

最后，`eax`寄存器惯例被用来把大多数C数据类型的返回值传回给调用者。

现在我们来研究栈帧上的数据。这张图精确地以字节形式表示内容，就像你在调试器里看到的一样，内存地址增长从左到右从上到下：
![frameContents](img/stack/frameContents.png)
局部变量`local_buffer`是C程序里常见的包含有一个空终止ascii字符串的字节数组。这个字符串从某些地方读出来比如键盘输入或文件，并有7个字节长。既然`local_buffer`能保存8个字节，还有剩下1个字节。*这1个字节的内容是未知的*，因为在栈的不停压入和弹出过程中，你永远不会知道内存里的内容除非是你写入的。因为C编译器并不初始化一个栈帧的内存，所以内容是不确定有点随机的直到被写入。这有点使人疯狂。

继续，`local1`是个4字节的整数，你能看到每个字节的内容。它看起来是个大数字，8后面跟了许多0，这里直觉使你误入歧途。

Intel处理器是*小头*机器，意味着内存里的数字以*小头*开始。多字节数字里的最不重要的字节（低位）位于最低的内存地址上。因为它（最不重要字节）表示在最左边，所以这和我们通常表示数字的方式不同。了解到大小头之争来源于格列佛游记：就像小人国的人吃鸡蛋从小头磕，Intel处理器从小字节（低位）开始“吃”数字。

因而`local1`实际上保存的是数字8，章鱼脚的数目。`param1`有一个2在第二个字节的位置上，所以它的数值为2\*256=512（乘256是因为每个字节可以表示0到255的范围）。同时，`param2`的数值可算得为1\*256\*256=65536。

一个栈帧的辅助数据包括两个重要部分：*前一个*栈帧的地址(saved ebp)和函数退出时要执行指令的地址(return address)。它们一起使函数安全地返回成为可能并使程序能够一直运行下去。

现在让我们来看看一个栈帧的产生以此建立一个关于它们整个一起工作的清晰记忆图像。栈的增长起初有些绕人，因为它是向着你预期的*反方向*。例如，在栈上分配8个字节要从`esp`减去8，而用减来增长某些东西是一种奇怪的方式。

让我们看一个简单的C程序：
**Simple Add Program - add.c**
```
int add(int a, int b)
{
  int result = a + b;
  return result;
}

int main(int argc)
{
  int answer;
  answer = add(40, 2);
}
```

假设我们运行在Linux上并没有命令行参数。当你运行一个C程序，实际上第一个执行的代码是C运行时库，它然后调用我们的`main`函数。下图一步步地展示了程序运行时所发生的事情。~~每个图链接到显示了内存和寄存器状态的GDB输出。~~你也可以检查所使用的[GDB命令](https://github.com/gduarte/blog/blob/master/code/x86-stack/add-gdb-commands.txt)和整个的[GDB输出](https://github.com/gduarte/blog/blob/master/code/x86-stack/add-gdb-output.txt)。开始吧：
![mainProlog](img/stack/mainProlog.png)

第二，第三以及下面的第四步称为函数序言，这对几乎所有的函数都是一样的：当前`ebp`的值保存到`esp`指向的栈顶(saved ebp)，把`esp`的值复制到`ebp`，从而建立一个新的栈帧。main函数的序言也是类似，不过特别的一点是当程序开始运行的时候，`ebp`被初始化为0。

如果你检查`argc`以下（往右）的栈，可以找到更多信息，包括指向程序名的指针和命令行参数（传统C的`argv`），以及指向Unix环境变量的指针及其实际内容。不过这些在这里并不重要，继续前进到了`add()`调用：
![callAdd](img/stack/callAdd.png)

在`main`从`esp`减去12以获得它所需要的栈空间之后，为`a`和`b`设置值。内存中的值以16进制小头表示，这和调试器里看到的一样。一旦设好了参数的值，`main`就开始调用`add`运行：
![addProlog](img/stack/addProlog.png)

现在到这儿有点兴奋了！我们得到了另外一个（函数）序言，但这次你能清楚地看到栈帧是怎样从`ebp`开始一直顺着栈向下形成一个链表的。这就是调试器以及高级语言里的异常对象如何得到它们的栈跟踪信息的。你也可以看到更加典型的当新栈帧创建时`ebp`追踪`esp`的过程。又一次，我们从`esp`中减去来得到更多的栈空间。

有点奇怪的是当`ebp`寄存器里的值复制到内存中时，字节被反转了。之所以这样是因为寄存器并不真正具有大小头，寄存器里并不像内存里有“增长的地址”。因此按照惯例调试器显示寄存器里的值的时候是以对人而言最自然的格式：从最重要的到最不重要的数字（从高位到低位）。所以在小头机器上复制的结果是和通常内存里从左到右的表示相反的。我想让这些图表提供和你在调试现场所发现内容的一个精确的描述，现在你明白了吧。

最难的部分已经过去，开始相加：
![doAdd](img/stack/doAdd.png)
有一个用户寄存器`edx`出现来帮助相加，但没有什么警告和特别的。`add`完成了它的工作，从这里开始栈要开始往相反的方向动作了，我们保留到下次讲解。

所有读到这里的人都值得奖励一个小礼物，我书呆子似的做了一个[包含所有步骤的大图](img/stack/callSequence.png)。

当它们全部展现出来时看上去是有点乏味。但这些小盒子能有*很大*的帮助。实际上，小盒子是计算机科学的主要工具。我希望这些图片以及寄存器的动作能够提供一个把栈增长和内存内容结合起来的直观的记忆图像。近一点来说，我们的软件和一个简单的图灵机并不相差太远。

我们栈之旅的第一部分到这里就结束了。接下来有更多的字节方面的探险，以及会见到在此基础之上更高级的编程概念。下周见。

</xmp>
<script src="../js/strapdown.js"></script>
</html>
