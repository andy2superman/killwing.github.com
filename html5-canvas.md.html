<!DOCTYPE html>
<html>
<title>HTML5 Canvas</title>
<xmp theme="readable" style="display:none;">
## Basic
### HTML5
HTML5是一个在免费许可条款下开发的开放网络平台。

基本的HTML5页面：
```
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hello World</title>
</head>
<body>
    Hello World!
</body>
</html>
```

### Compatibility Test
测试浏览器支持：
```
function canvasSupport() {
    return !!document.createElement('canvas').getContext;
}
```
兼容性测试库：http://www.modernizr.com/

### Animation Loop
`window.requestAnimationFrame`: 告诉程序浏览器已经准备好可以渲染动画的新的一帧了：
```
(function animationloop(){
    window.requestAnimationFrame(animationloop); // 或 window.setTimeout(animationloop, 1000 / 60); // 1秒60帧
    render();
})();
```

## API
### Canvas Element
属性：

* width: canvas的宽度
* height: canvas的高度

方法：

* getContext(contextId): 取得context对象。
* toDataURL(type, args): 把canvas转化成base64字符串表示，以不同的MIME类型作为参数，如image/png（默认）, image/jpeg。
* toBlob(): 返回一个图像文件的引用。

Canvas是屏幕上可被JavaScript操纵的立即模式的位图区域。当调用Canvas JavaScript API的时候，canvas会在每一帧上完全重绘位图。这和在保留模式操作的Flash, Silverlight或SVG不一样，图形渲染器保存了一个对象的显示列表，对象根据其代码里设置的属性显示在屏幕上。
如果canvas的高度或宽度被重新设置，其内容会被清空。

### Context
属性：

* canvas: 所属canvas对象

方法：

* save(): 保存context的状态
* restore(): 恢复context的状态

所有在canvas上的操作都要通过context对象（`CanvasRenderingContext2D`, 这里只涉及2D）来完成：
```
var theCanvas = document.getElementById('canvasId');
var context = theCanvas.getContext('2d');
```

`CanvasRenderingContext2D`使用笛卡尔座标系，原点(0,0)在左上角，并向右下角增长。

context有个当前绘制状态，全局地对（之后绘制）整个canvas起作用，包括：

* 变换矩阵：由scale, rotate, transform和translate方法设置。
* 裁剪区域：由clip方法创建。
* 属性：包括strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline.

当前context状态可以像栈一样保存和恢复。
当前路径和当前位图不属于当前的context状态。

### Path
方法：

* beginPath()：开始路径
* closePath()：闭合路径
* fill(): 填充
* stroke()：描边
* clip(): 创建裁剪区域
* moveTo(x, y)：移动
* lineTo(x, y)：直线
* quadraticCurveTo(cpx, cpy, x, y)：二次方曲线
* bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)：贝塞尔曲线
* arc(x, y, radius, startAngle, endAngle, anticlockwise)：弧线
* rect(x, y, width, height)：矩形
* arcTo(x1, y1, x2, y2, radius)：夹角弧线
* isPointInPath(x, y): 检查一个点是否在当前路径上

### Rectangle
方法：

* fillRect(x, y, width, height)：填充矩形
* strokeRect(x, y,width, height)：描边矩形
* clearRect(x, y, width, height)：擦除矩形

### Text
属性：

* font: 字体样式，包括style(normal/italic/oblique/inherit), weight(normal/bold/bolder/lighter/100/200/300/400/500/600/700/800/900/inherit/auto), size(px), face(serif/sans-serif/cursive/fantasy/monospace)，默认"10px sans-serif"
* textAlign: 文本对齐，center/start/end/left/right, 默认"center"
* textBaseline: 文本基线，top/hanging/middle/alphabetic/ideographic/bottom, 默认"middle"

方法：

* fillText(text, x, y, maxWidth): 填充文本
* strokeText(text, x, y, maxWidth): 描边文本
* measureText(text): 返回TextMetrics对象，目前只有width属性

### Style
属性：

* strokeStyle: 线条样式
* fillStyle: 填充样式
* shadowOffsetX: 阴影X方向，可负
* shadowOffsetY: 阴影Y方向，可负
* shadowBlur: 阴影模糊
* shadowColor: 阴影颜色
* globalAlpha: 全局透明度，默认1.0不透明
* globalCompositeOperation: 全局混合模式 copy/destination-atop/destination-in/destination-out/destination-over/lighter/source-atop/source-in/source-out/source-over/xor
* lineWidth: 线宽，默认1.0
* lineCap: 端点形状 butt/round/square
* lineJoin: 连接处形状 miter/bevel/round
* miterLimit: 斜接的比例，默认10

方法：

* createLinearGradient(x0, y0, x1, y1): 线性渐变，返回`CanvasGradient`对象，使用`addColorStop(relative-pos, color)`方法添加渐变点。
* createRadialGradient(x0, y0, r0, x1, y1, r1): 放射渐变，返回`CanvasGradient`对象。
* createPattern(image, repeatition): 图像填充，repeat/repeat-x/repeat-y/no-repeat，返回`CanvasPattern`对象。

在填充样式和线条样式中的颜色表示："red", "#ff0000", "rgb(255, 0, 0)", "rgba(255, 0, 0, 0)", 以及渐变对象。

### Transformation
方法：

* rotate(angle): 旋转, 以座标原点
* scale(x, y): 缩放, 以座标原点
* translate(x, y): 改变座标原点的位置
* transform(m11, m12, m21, m22, dx, dy): 矩阵变换
* setTransform(m11, m12, m21, m22, dx, dy): 设置变换矩阵，重置值(1, 0, 0, 1, 0, 0)

所有度数以弧度表示，转换：`degree * Math.PI/180`

### Image
方法：

* drawImage(image, dx, dy, dw, dh): 绘制图像，可选指定宽高度。
* drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh): 绘制图像，指定源图像范围。
* createImageData(sw, sh): 创建图像数据，返回`ImageData`对象，`ImageData`有width, height, data三个属性。
* createImageData(imagedata): 复制一份图像数据。
* getImageData(sx, sy, sw, sh): 获取图像数据。
* putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight): 绘制图像数据，可选指定范围。

加载图像：
```
var img = new Image();
img.src = 'test.jpg';
img.addEventListener('load', function() { render(); }, false);
```

`ImageData.data`是一个`CanvasPixelArray`对象，以32位颜色格式(r,g,b,a)保存了所有像素。每4个元素表示一个像素，每个元素值范围是0~255。

### Cheet Sheet
![Cheet_Sheet](http://www.nihilogic.dk/labs/canvas_sheet/HTML5_Canvas_Cheat_Sheet.png)


## Collision Detection
### ImageObj类
`context`为全局对象。
```
function ImageObj(x, y, src) {
    var self = this;
    self.x = x;
    self.y = y;
    self.image = new Image;
    self.image.src = src;
    self.image.addEventListener('load', function() {
        var image = self.image;
        context.drawImage(image, 0, 0);
        self.width = image.width;
        self.height = image.height;
        self.data = context.getImageData(0, 0, image.width, image.height).data;
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    }, false);
};

ImageObj.prototype.draw = function() {
    context.drawImage(this.image, this.x, this.y);
};
```

### 基于边框检测
把图像当作完整的矩形，检测是否有重合部分。
```
function boundingBoxCollide(object1, object2) {
    var left1 = object1.x;
    var left2 = object2.x;
    var right1 = object1.x + object1.width;
    var right2 = object2.x + object2.width;
    var top1 = object1.y;
    var top2 = object2.y;
    var bottom1 = object1.y + object1.height;
    var bottom2 = object2.y + object2.height;

    if (bottom1 < top2 || top1 > bottom2 || right1 < left2 || left1 > right2) {
        return false;
    }
    return true;
};
```

### 基于像素检测
找出两个图像（矩形的）重合部分，再检查重合部分每个像素在两个图像上的alpha值，如果都不为0，则其是个重合的像素。
```
function pixelCollide(object1, object2) {
    var xMin = Math.max(object1.x, object2.x);
    var yMin = Math.max(object1.y, object2.y);
    var xMax = Math.min(object1.x + object1.width, object2.x + object2.width);
    var yMax = Math.min(object1.y + object1.height, object2.y + object2.height);

    for (var x = xMin; x < xMax; ++x) {
        for (var y = yMin; y < yMax; ++y) {
            var pixel1 = ((x - object1.x) + (y - object1.y) * object1.width) * 4 + 3;
            var pixel2 = ((x - object2.x) + (y - object2.y) * object2.width) * 4 + 3;
            if (object1.data[pixel1] !== 0 && object2.data[pixel2] !== 0) {
                return true;
            }
        }
    }
    return false;
}
```
先进行基于边框的检测（快），如果有重合再进一步进行基于像素的检测（慢）。


## Animation
### Formula
#### 速度 velocity
`v = s/t`: 单位时间的距离
对于每帧（单位时间），新位置就等于现在的位置加上速度：`loc2 = loc1 + v`

#### 加速度 acceleration
`a = v/t`: 单位时间的速度，速度的变化
对于每帧（单位时间），新速度就等于现在的速度加上加速度：`v2 = v1 + a`

### Vector
位置，速度，加速度都可以用向量来表示。


## Reference
[W3C HTML Canvas 2D Context](http://www.w3.org/html/wg/drafts/2dcontext/html5_canvas/)
[HTML Living Standard The canvas element](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#the-canvas-element)
[HTML5 Canvas](http://chimera.labs.oreilly.com/books/1234000001654)
[The Nature of Code](http://natureofcode.com/book/)

</xmp>
<script src="js/strapdown.js"></script>
</html>
