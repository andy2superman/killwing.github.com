<!DOCTYPE html>
<html>
<title>Programming Pearls 2ed</title>
<xmp theme="readable" style="display:none;">
# 一 基础
## 1 开篇
问题：一个最多包含n(n=10^7)个不重复正整数的文件，每个数都小于n，没有其他关联数据。要求按升序排列的输入整数的列表。
限制：最多有大约1MB内存空间可用，充足的磁盘空间可用。运行时间最多几分钟，最好10秒以内。

解法（**位图排序**）：

1. 用10^7个位（1.25MB）来表示整数集合，所有位初始为0。
1. 读入所有整数，如果整数i存在，则设第i位为1。
1. 顺序检查每一位，如果为1，则输出对应整数。

位操作：
```
#define BITSPERWORD 32
#define SHIFT 5
#define MASK 0x1F
#define N 10000000
int a[1 + N/BITSPERWORD];

void set(int i) {       a[i >> SHIFT] |=  (1 << (i & MASK)); } // i & (2^n - 1) 相当于取余 i % 2^n
void clr(int i) {       a[i >> SHIFT] &= ~(1 << (i & MASK)); }
int test(int i) {return a[i >> SHIFT] &   (1 << (i & MASK)); }
```

**原理：**

* 正确的问题
* 位图数据结构
* 多趟算法
* 时间-空间折中与双赢
* 简单的设计

> 设计者确定其设计已经达到完美的标准不是不能再增加任何东西，而是不能再减少任何东西。
- [Antoine de Saint Exupéry](http://en.wikiquote.org/wiki/Antoine_de_Saint_Exup%C3%A9ry)


## 2 啊哈！算法
问题A：给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。
限制：只有几百字节内存，几个外部临时文件可用。

解法（**二分搜索**）：
包含所有整数在内的文件表示全部范围，通过统计中间点之上和之下的元素（个数）来探测范围：或者上面或者下面的范围具有至多全部范围的一半元素。由于整个范围中有一个缺失元素，因此所需的那一半范围中必然也包含缺失元素。

问题B：将一个n元一维向量向左旋转i个位置（循环移位）。
限制：只有数十字节额外存储空间，时间复杂度O(n)。

解法（**翻手算法**）：
旋转操作对应于交换相邻的不同大小的内存块。分别对两部分分别求逆，再对整体求逆：
```
reverse(0, i-1)
reverse(i, n-1)
reverse(0, n-1)
```

问题C：给定一个英语字典，找出其中所有变位词集合（每一单词都可以通过改变其他单词字母顺序得到）。

解法（**排序标识**）：
标识字典中的每一个词（按字母顺序排序单词的字母），使得在相同变位词类中的单词具有相同标识。然后，将所有具有相同标识的单词集中在一起（按标识的顺序排序所有单词）。

**原理：**

* 排序
* 二分搜索
* 标识
* 问题定义
* 问题解决者的观点


## 3 数据决定程序结构
**原理：**

* 使用数组重新编写重复代码
* 封装复杂结构
* 尽可能使用高级工具：超文本，名字-值对，电子表格，数据库，特定领域的编程语言
* 从数据得出程序的结构

> 程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心力研究数据，常常能有奇效。数据的表示形式是程序设计的根本。
- Fred Brooks

## 4 编写正确的程序
在有n个元素的表中，二分搜索大约需要执行log2(n)次比较操作。
程序文本中的重要解释以断言的形式结束；而确定在实际软件中应包含哪些断言则是一门艺术，只能在实践中学习。
调试过程中，需要同时修正错误代码和错误的断言：总是保持对代码的正确理解，不要理会那种“只要让程序工作，怎么改都行”的催促。

**原理：**

* 断言
* 顺序控制结构
* 选择控制结构
* 迭代控制结构
* 函数


## 5 编程小事
二分搜索C++函数：
```
int x[n];

// return (any) position if t in sorted x[0..n-1] or -1 if t is not present
int binarysearch(int t) {
    int l = 0;
    int u = n - 1;
    while (l <= u) {
        int m = (l + u) / 2;
        if (x[m] < t) {
            l = m + 1;
        } else if (x[m] == t) {
            return m;
        } else { // x[m] > t
            u = m - 1;
        }
    }
    return -1;
}
```

**原理：**

* 脚手架
* 编码
* 测试
* 调试
* 计时

> 在测试时使用断言，而在产品发布时将断言关闭的程序员，就像是在岸上操练时穿着救生衣，而下海时将救生衣脱下的水手。
- Tony Hoare


# 二 性能
## 6 程序性能分析
设计层面：

* 问题定义
* 系统结构
* 算法和数据结构
* 代码调优
* 系统软件
* 硬件

**原理：**

* 如果仅需要较小的加速，就对效果最佳的层面做改进。
* 如果需要较大的加速，就对多个层面做改进。

> 计算机系统中最廉价、最快速且最可靠的元件是根本不存在的。
- Gordon Bell

## 7 粗略估算
基本技巧：

* 两个答案比一个答案好
* 快速检验
    * 量纲检验（检验几何或物理等式）：和式中各式的量纲必须相同，这个量纲同时也是最终求和结果的量纲；乘积的量纲是各乘数量纲的乘积。
    * 舍九法（检验加法）：加数的各位数字总和与和数的各位数字总和模9(%9)相等。
    * 不要忘记常识性的东西。
* 经验法则
    * 72法则（估算指数增长）：假设以年利率r%投资一笔钱y年，如果`r × y = 72`，那么你的投资差不多会翻倍。
    * π秒就是一个纳世纪(`10^-9 * 100 = 10^-7`年)。
* 实践

Little定律：系统中物体的平均数量等于物体离开系统的平均速率（如果物体离开和进入系统的总体出入流是平衡的，那么离开速率也就是进入速率）和每个物体在系统中停留的平均时间的乘积。

**原理：**
> 任何事情都应尽量简单，但不宜过于简单。
- Albert Einstein

## 8 算法设计技术
问题：具有n个数字元素的数组，输出任何连续子数组的最大和。

解法（**扫描算法**）：
从数组最左端开始扫描，一直到最右端为止，并记下所遇到的最大总和子数组。前i个元素中，最大总和子数组要么在前i-1个元素中，要么其结束位置为i。

**原理：**

* 保存状态，避免重复计算
* 将信息预处理至数据结构中
* 分治算法
* 扫描算法
* 累积
* 下界

## 9 代码调优
代码调优最重要的原理就是尽量少用它。

**原理：**

* 效率的角色
* 度量工具
* 设计层面
* 双刃剑

## 10 节省空间
数据空间技术：

* 不存储，重新计算
* 稀疏数据结构
* 数据压缩
* 分配策略
* 垃圾回收

代码空间技术：

* 函数定义
* 解释程序
* 翻译成机器语言


**原理：**

* 空间开销
* 空间的“热点”
* 空间度量
* 折中
* 与环境协作
* 使用适合任务的正确工具：最重要的原则 - 简单性

# 三 应用
## 11 排序
n个相同元素的数组：

* 对于插入排序是最好的情况，时间复杂度为O(n)。
* 对于快速排序是最坏的情况，时间复杂度为O(n^2)。

**原理：**

* 插入排序的代码很容易编写，且对于小型的排序任务速度很快。
* 如果n很大，快速排序的O(nlogn)运行时间就非常关键了。

## 12 取样问题
问题：两个整数m和n，其中m<n，输出0～n-1范围内m个随机（每个数出现概率相等）不重复整数的有序列表。

解法：

* 依次考虑整数0, 1, 2, ..., n-1，并通过一个适当的随机测试对每个整数进行选择。时间：O(n)。
* 在一个初始为空的有序集合(`std::set`)里面插入随机数，直到个数足够。时间：O(mlogm)，空间开销大。
* 打乱数组的前m个元素，然后把前m个元素排序输出。时间：O(n+mlogm)，n个元素空间。

**原理：**

* 正确理解所遇到的问题
* 提炼出抽象问题
* 考虑尽可能多的解法
* 实现一种方案
* 回顾

## 13 搜索
对于12章问题的解法2中的有序集合数据结构：

集合|O(init)|O(insert)|O(output)|O(total)|空间
-|-|-|-|-|-
有序数组|1|m|m|m^2|m
有序链表|1|m|m|m^2|2m
二分搜索树|1|logm|m|mlogm|3m
散列表|m|1|m|m|3m
位图|n|1|n|n|n/b

**原理：**

* 库的作用
* 空间的重要性
* 代码调优方法

## 14 堆
堆：一种二叉树

* 任何节点的值都小于等于其子节点的值（最小堆）。左右子节点无顺序。
* 最多在两层上具有叶节点，最底层的叶节点尽可能地靠左分布。

调整堆：

* siftup: 新元素在最后，尽可能地通过交换该节点与其父节点将新元素向上筛选。
* siftdown: 新元素在最前，尽可能地通过交换该节点与其较小子节点将新元素向下筛选。

应用：

* 优先级队列：有序元素集合，最小元素优先出队列。插入：siftup；删除：siftdown。
* 堆排序：保证了最坏情况下的O(nlogn)性能，但对于常见的输入数据，最快的堆排序通常也比简单快速排序慢。建堆（最大堆）：siftup；排序：siftdown。

**原理：**

* 高效性
* 正确性
* 抽象性
* 过程抽象
* 抽象数据类型

## 15 字符串
单词表（有序）：平衡树
单词统计：散列表
查找最长的重复子串：后缀数组
生成随机文本：马尔可夫链

**原理：**

* 字符串的数据结构
* 散列
* 平衡树
* 后缀数组

----
## 代码调优法则
空间换时间法则

* 修改数据结构
* 存储预先计算好的结果
* 高速缓存
* 懒惰求值

时间换空间法则

* 堆积
* 解释程序

循环法则

* 将代码移出循环
* 合并测试条件
* 展开循环
* 删除赋值
* 消除无条件分支
* 循环合并

逻辑法则

* 利用等价的代数表达式
* 短路单调函数
* 对测试条件重新排序
* 预先计算逻辑函数
* 消除布尔变量

过程法则

* 打破函数层次
* 高效处理常见情况
* 协同程序
* 递归函数转换
* 并行性

表达式法则

* 编译时初始化
* 利用等价的代数表达式
* 消除公共子表达式
* 成对计算
* 利用计算机字的并行性

</xmp>
<script src="js/strapdown.js"></script>
</html>
