<!DOCTYPE html>
<html>
<title>Programming Pearls 2ed</title>
<xmp theme="readable" style="display:none;">
# 一 基础
## 1 开篇
问题：一个最多包含n(n=10^7)个不重复正整数的文件，每个数都小于n，没有其他关联数据。要求按升序排列的输入整数的列表。
限制：最多有大约1MB内存空间可用，充足的磁盘空间可用。运行时间最多几分钟，最好10秒以内。

解法（**位图排序**）：

1. 用10^7个位（1.25MB）来表示整数集合，所有位初始为0。
1. 读入所有整数，如果整数i存在，则设第i位为1。
1. 顺序检查每一位，如果为1，则输出对应整数。

位操作：
```
#define BITSPERWORD 32
#define SHIFT 5
#define MASK 0x1F
#define N 10000000
int a[1 + N/BITSPERWORD];

void set(int i) {       a[i >> SHIFT] |=  (1 << (i & MASK)); } // i & (2^n - 1) 相当于取余 i % 2^n
void clr(int i) {       a[i >> SHIFT] &= ~(1 << (i & MASK)); }
int test(int i) {return a[i >> SHIFT] &   (1 << (i & MASK)); }
```

**原理：**

* 正确的问题
* 位图数据结构
* 多趟算法
* 时间-空间折中与双赢
* 简单的设计

> 设计者确定其设计已经达到完美的标准不是不能再增加任何东西，而是不能再减少任何东西。
- [Antoine de Saint Exupéry](http://en.wikiquote.org/wiki/Antoine_de_Saint_Exup%C3%A9ry)


## 2 啊哈！算法
问题A：给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。
限制：只有几百字节内存，几个外部临时文件可用。

解法（**二分搜索**）：
包含所有整数在内的文件表示全部范围，通过统计中间点之上和之下的元素（个数）来探测范围：或者上面或者下面的范围具有至多全部范围的一半元素。由于整个范围中有一个缺失元素，因此所需的那一半范围中必然也包含缺失元素。

问题B：将一个n元一维向量向左旋转i个位置（循环移位）。
限制：只有数十字节额外存储空间，时间复杂度O(n)。

解法（**翻手算法**）：
旋转操作对应于交换相邻的不同大小的内存块。分别对两部分分别求逆，再对整体求逆：
```
reverse(0, i-1)
reverse(i, n-1)
reverse(0, n-1)
```

问题C：给定一个英语字典，找出其中所有变位词集合（每一单词都可以通过改变其他单词字母顺序得到）。

解法（**排序标识**）：
标识字典中的每一个词（按字母顺序排序单词的字母），使得在相同变位词类中的单词具有相同标识。然后，将所有具有相同标识的单词集中在一起（按标识的顺序排序所有单词）。

**原理：**

* 排序
* 二分搜索
* 标识
* 问题定义
* 问题解决者的观点


## 3 数据决定程序结构
**原理：**

* 使用数组重新编写重复代码
* 封装复杂结构
* 尽可能使用高级工具：超文本，名字-值对，电子表格，数据库，特定领域的编程语言
* 从数据得出程序的结构

> 程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心力研究数据，常常能有奇效。数据的表示形式是程序设计的根本。
- Fred Brooks

## 4 编写正确的程序
在有n个元素的表中，二分搜索大约需要执行log2(n)次比较操作。
程序文本中的重要解释以断言的形式结束；而确定在实际软件中应包含哪些断言则是一门艺术，只能在实践中学习。
调试过程中，需要同时修正错误代码和错误的断言：总是保持对代码的正确理解，不要理会那种“只要让程序工作，怎么改都行”的催促。

**原理：**

* 断言
* 顺序控制结构
* 选择控制结构
* 迭代控制结构
* 函数


## 5 编程小事
二分搜索C++函数：
```
int x[n];

// return (any) position if t in sorted x[0..n-1] or -1 if t is not present
int binarysearch(int t) {
    int l = 0;
    int u = n - 1;
    while (l <= u) {
        int m = (l + u) / 2;
        if (x[m] < t) {
            l = m + 1;
        } else if (x[m] == t) {
            return m;
        } else { // x[m] > t
            u = m - 1;
        }
    }
    return -1;
}
```

**原理：**

* 脚手架
* 编码
* 测试
* 调试
* 计时

> 在测试时使用断言，而在产品发布时将断言关闭的程序员，就像是在岸上操练时穿着救生衣，而下海时将救生衣脱下的水手。
- Tony Hoare


# 二 性能

# 三 应用

</xmp>
<script src="js/strapdown.js"></script>
</html>
