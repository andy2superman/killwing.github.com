<!DOCTYPE html>
<html>
<title>Unix Network Programming Vol.1 3ed</title>
<xmp theme="readable" style="display:none;">
## 1 简介
### 1.1 概述
### 1.2 一个简单的时间获取客户程序
### 1.3 协议无关性
### 1.4 错误处理：包裹函数
### 1.5 一个简单的时间获取服务器程序
### 1.6 本书中客户/服务器程序示例索引表
### 1.7 OSI模型
网络应用绕过传输层直接使用IPv4/6是可能的，使用raw socket。

协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。

* 物理层: 位（bit）
* 数据链路层: 帧（frame）
* 网络层: 包（packet），又叫分组
* 传输层: 段（segment），又叫分节

### 1.8 BSD网络支持历史
### 1.9 测试用网络及主机
### 1.10 Unix标准
### 1.11 64位体系结构
Socket API地址结构的长度使用socklen_t类型。
### 1.12 小结

## 2 传输层：TCP、UDP和SCTP
### 2.1 概述
### 2.2 总图
### 2.3 UDP
UDP不保证

* UDP数据包会到达其最终目的地
* 各个数据包的先后顺序跨网络后保持不变
* 每个数据包只到达一次

### 2.4 TCP
TCP提供

* 端对端的连接
* 可靠性：超时重传或故障通知
* 估算往返时间RTT
* 数据排序
* 流量控制：通过通告窗口指出接收缓冲区当前可用的空间量。当接收缓冲区满时，窗口大小为0。
* 拥塞控制
* 全双工

### 2.5 SCTP
SCTP提供

* 关联：取代连接，一个关联指代两个系统之间的一次通信。
* 多宿：单个SCTP端点能够支持多个IP地址，以增强网络故障的健壮性。
* 面向消息的按序递送服务。
* 多流：每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上消息的投递。（TCP会阻塞直至修复）

### 2.6 TCP连接的建立和终止
#### 2.6.1 三路握手
client: connect
server: bind, listen, accept

<pre class="sequence">
Title: TCP three-way handshake: Client active open, Server passive open
Note over Client: socket()
Note over Server: socket(),bind(),listen()
Note over Server: accept()
Note over Client: connect()
Client->Server: 1. SYN J
Server->Client: 2. SYN K,ACK J+1
Note left of Client: connect() return
Client->Server: 3. ACK K+1
Note right of Server: accept() return
</pre>

#### 2.6.2 TCP选项
每一个SYN可以含多个TCP选项

* MSS：最大分节大小，在本连接中的每个TCP分节中愿意接受的最大数据量。发送端使用接收端的MSS作为发送分节的最大大小。设置：TCP_MAXSEG。
* 最大窗口：连接的任何一端能够通告对端的最大窗口大小是65535。设置：SO_RCVBUF。
* 时间戳

#### 2.6.3 TCP连接终止
主动关闭：close
被动关闭：read返回EOF -> close

<pre class="sequence">
Title: TCP connection termination: Client active close, Server passive close
Note over Client: close()
Client->Server: 1. FIN M
Note over Server: read() return 0
Server->Client: 2. ACK M+1
Note right of Server: half close
Note over Server: close()
Server->Client: 3. FIN N
Client->Server: 4. ACK N+1
</pre>

在2-3之间，从被动关闭一端到主动关闭一端的数据流动是可能的，称为半关闭。
当一个进程终止时，所有打开的描述符都被关闭，这会导致仍然打开的任何TCP连接上也发出一个FIN（不需要调close）。

#### 2.6.4 TCP状态转换图
![TCP State](http://upload.wikimedia.org/wikipedia/commons/a/a2/Tcp_state_diagram_fixed.svg)
可以用netstat监视状态

#### 2.6.5 观察分组
<pre class="sequence">
Title: TCP connection: Client active, Server passive
Note over Client: socket()
Note over Server: socket(),bind(),listen()
Note over Server: accept()
Note over Client: connect()
Client->Server: SYN J, MSS1
Note left of Client: SYN_SENT
Note right of Server: SYN_RCVD
Server->Client: SYN K,ACK J+1, MSS2
Note left of Client: ESTABLISHED
Note left of Client: connect() return
Client->Server: ACK K+1
Note right of Server: ESTABLISHED
Note right of Server: accept() return

Note over Server: read()
Note over Client: write()
Client->Server: PSH,ACK
Server->Client: ACK
Note right of Server: read() return
Note over Client: read()
Note over Server: write()
Server->Client: PSH,ACK
Client->Server: ACK
Note left of Client: read() return
Note over Server: read()

Note over Client: close()
Client->Server: FIN M
Note left of Client: FIN_WAIT_1
Note right of Server: CLOSE_WAIT
Note over Server: read() return 0
Server->Client: ACK M+1
Note left of Client: FIN_WAIT_2
Note over Server: close()
Server->Client: FIN N
Note right of Server: LAST_ACK
Note left of Client: TIME_WAIT
Client->Server: ACK N+1
Note right of Server: CLOSED
Note left of Client: 2MSL timeout
Note left of Client: CLOSED
</pre>

不同方向上MSS值不同不成问题。
捎带：服务器对客户端的请求的确认是伴随其应答发送，通常在服务器请求并产生应答的时间少于200ms时发生，否则分2个分节发送。
从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的一大堆细节从TCP转移到UDP应用进程。UDP则避免了TCP连接建立和终止所需的开销。

#### 2.6.7 TIME_WAIT状态
MSL: 任何IP数据报能够在因特网中存活的最长时间。
TIME_WAIT状态的持续时间是MSL的2倍。
执行主动关闭的那一端是处于TIME_WAIT状态的那一端。
TIME_WAIT状态存在的两个理由

* 可靠地实现TCP全双工连接的终止。需要正确处理连接终止序列4个分节中任何一个丢失的情况。
* 允许老的重复分节在网络中消逝。2MSL的时间防止了来自某个连接的老的重复分组在该连接已经终止后再现。

### 2.8 SCTP关联的建立和终止
#### 2.8.1 四路握手
client: connect
server: bind, listen, accept

<pre class="sequence">
Title: SCTP four-way handshake: Client active open, Server passive open
Note over Client: socket()
Note over Server: socket(),bind(),listen()
Note over Server: accept()
Note over Client: connect()
Client->Server: INIT(Ta, J)
Server->Client: Ta:INIT ACK(Tz, K, cookie C)
Client->Server: Tz: COOKIE ECHO C
Note right of Server: accept() return
Server->Client: Ta: COOKIE ACK
Note left of Client: connect() return
</pre>

在关联有效期内，验证标记Ta必须在对端发送的每个分组中出现，验证标记Tz也必须在本端发送的每个分组中出现。
四路握手结束时，两端各自选择一个主目的地址用作数据要发送到的目的地。
使用四路握手是为了避免一种DoS攻击。

#### 2.8.2 关联终止
主动关闭：close
被动关闭：read返回EOF -> close

<pre class="sequence">
Title: SCTP connection termination: Client active close, Server passive close
Note over Client: close()
Client->Server: SHUTDOWN
Note over Server: read() return 0
Note over Server: close()
Server->Client: SHUTDOWN ACK
Client->Server: SHUTDOWN COMPLETE
</pre>

没有半关闭的关联，当一端关闭某个关联时，另一端必须停止发送新的数据。
没有TIME_WAIT状态，因为使用了验证标记。

#### 2.8.3 SCTP状态转换图
#### 2.8.4 观察分组
#### 2.8.5 SCTP选项

### 2.9 端口号
0~1023: 众所周知的端口，可能的话，相同端口号就分给TCP/UDP/SCTP的同一给定服务。Unix下启动这些端口的服务需要root权限。
1024~49151: 已注册的端口。
49152~65535: 私有端口，临时端口。`49152 = 65536*3/4`

socket pair: 一个定义该连接的四元组，唯一标识一个网络上的每个TCP连接。标识每个端点的IP和端口号通常称为一个socket。
SCTP的同一个关联可能需要多个四元组标识（IP地址各不相同但端口号一样）。

### 2.10 TCP端口号与并发服务器
服务器可以指定只接受到达某个特定本地接口(IP地址)的外来连接，这里要么选一个接口要么选任意接口，不能指定某几个接口。
必须由socket pair才能确定由哪个端点(socket)接收某个到达的分节，已连接socket pair的由相应socket接收，其他指定目的端口的TCP分节都由监听socket接收。

### 2.11 缓冲区大小及限制
IPv4数据报的最大大小是65535字节，IPv6为65575字节。
IPv4要求最小链路MTU为68字节，IPv6为1280字节。
两个主机之间路径的最小MTU称为路径MTU。1500字节是以太网常见的路径MTU。
如果IP数据包超过相应链路的MTU，IPv4和IPv6都将执行分片。
IPv4头的DF(don't fragment)位若被设置，则不允许主机或路由器对它们分片。IPv6只有主机对其产生的数据报执行分片。
最小重组缓冲区大小：保证支持的最小数据报的大小，IPv4为576字节，IPv6为1500字节。
TCP的MSS的目的是告诉对端其最小重组缓冲区的实际值，从而试图避免分片。MSS经常设置成MTU减去IP和TCP的头部固定长度，IPv4为1460字节，IPv6为1440字节。
SCTP基于到对端的所有地址的最小路径MTU作为分片点。

#### 2.1.1 TCP输出
每个TCP socket有一个发送缓冲区，可以用SO_SNDBUF设置。
当写一个TCP socket的write调用成功返回仅仅表示可以重新使用原来的应用进程缓冲区（数据已成功复制到发送缓冲区，如果数据比发送缓冲区空闲大小还要大则write调用阻塞），并不表明对端的TCP或应用进程已经收到数据。
对端TCP必须确认收到的数据，只有对端ACK到达本端才能从发送缓冲区中丢弃已确认的数据。

#### 2.1.2 UDP输出
UDP的发送缓冲区并不存在，但它大小有个值，指写到该socket的数据大小的上限，可以用SO_SNDBUF设置。如果写一个大于发送缓冲区大小的数据，则返回EMSGSIZE错误。
UDP不可靠，没有发送缓冲区，不保存应用进程数据的副本，发送后即弃。
相比TCP应用数据更有可能被分片，因为TCP会把应用数据划分成MSS大小，而UDP没有对等的手段。
当写一个UDP socket的write调用成功返回仅仅表示所写的数据报或其所有分片已被加入数据链路层的输出队列。如果队列没有空间则会返回ENOBUF错误给应用进程（不一定，可能直接被丢掉）。

#### 2.1.3 SCTP输出
和TCP类似。

### 2.12 标准因特网服务
### 2.13 常见因特网应用的协议使用
### 2.14 小结


## 3 套接字编程简介
### 3.1 概述
### 3.2 套接字地址结构
一般套接字函数使用通用套接字结构sockaddr，sa_len, sa_family, sa_data[14]。结构大小16字节。
IPv4套接字结构sockaddr_in，POSIX规范只需要三个字段: sin_family(AF_INET), sin_addr, sin_port。端口号以网络字节序存储。32位地址，结构大小16字节。
IPv6套接字结构sockaddr_in6，sin6_family(AF_INET6), sin6_addr, sin6_port。128位地址，结构大小28字节。
还有Unix域结构sockaddr_un/AF_LOCAL, 数据链路结构sockaddr_dl/AF_LINK。
新通用套接字结构sockaddr_storage，ss_len, ss_family。与sockaddr相比能满足苛刻的对齐要求，而且足够大可以容纳所有结构种类。

### 3.3 值-结果参数
传入套接字地址结构的函数：bind, connect, sendto。
传出套接字地址结构的函数：accept, recvfrom, getsockname。

### 3.4 字节排序函数
小端little-endian：低序字节存储在起始地址。(低地址放低位)
大端big-endian：高序字节存储在起始地址。(低地址放高位)
一个字节内部位的排序，不存在大小端问题，高位在前。
转换函数：htons, htonl, ntohs, ntohl。

位序：在RFC分组图示中，最左边的位是最早出现（最先读到）的最高有效位。

### 3.5 字节操纵函数
Berkeley函数strings.h: bzero, bcopy, bcmp。
ANSI C函数string.h: memset, memcpy, memcmp。
bcopy能处理源地址和目标地址有重叠的情况，而memcpy不能，需要用memmove。

### 3.6 inet_aton, inet_addr和inet_ntoa函数
只适用IPv4：点分十进制字符串(ascii)和网络字节序二进制值(numeric)之间的转换。
inet_ntoa使用了静态内存，因此不可重入。

### 3.7 inet_pton和inet_ntop函数
同时适用IPv4和IPv6：地址字符串(presentation)和网络字节序二进制值(numeric)之间的转换。

### 3.8 sock_ntop相关函数
IPv4/6协议无关的wrap函数。

### 3.9 readn, writen和readline函数
字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少，但这不是出错状态。read时很常见，write只有在该套接字为非阻塞下才出现。

### 3.10 小结


## 4 基本TCP套接字编程
### 4.1 概述
### 4.2 socket函数
用socket函数指定期望的通信协议类型。

* family: AF_NET, AF_NET6, AF_LOCAL, AF_ROUTE, AF_KEY
* type: SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET, SOCK_RAW
* protocol: IPPROTO_TCP, IPPROTO_UDP, IPPROTO_SCTP

AF前缀表示地址族，PF前缀表示协议族（不常用）。

### 4.3 connect函数
TCP客户端用connect函数来建立与TCP服务器的连接。

客户在调用connect函数前不必非得调用bind函数，需要的话内核会确定源IP地址，并选择一个临时端口作为源端口。

出错返回：

* 若没有收到SYN分节的响应，则返回ETIMEOUT错误。
* 若收到SYN的响应是RST，则返回ECONNREFUSED错误。表示服务器上指定的端口没有进程等待连接。
* 若发出的SYN在中间的某个路由器上引发了一个目的地不可达的ICMP错误，则返回EHOSTUNREACH/ENETUNREACH错误。

若connect失败则该套接字不再可用，必须关闭。创建新的套接字重新连接。

RST是TCP在发生错误时发送的一种TCP分节。产生RST的三种情况是：

* SYN到达而服务器上指定的端口没有进程等待连接（监听）。
* TCP想取消一个已有连接。
* TCP接收到一个根本不存在的连接上的分节。

### 4.4 bind函数
bind函数把一个本地协议地址赋予一个套接字。

对于TCP：
如果未曾用bind绑定一个端口，当调用connect或listen时，内核就要为相应的套接字选择一个临时端口。
如果不绑定一个IP地址，对于客户端，内核将根据所有外出网络接口来选择源IP地址；对于服务器，内核就把客户发送的SYN的目的IP地址作为服务器的源IP地址。

通配地址：INADDR_ANY (IPv4), in6addr_any (IPv6)

### 4.5 listen函数
listen函数仅由TCP服务器调用：把一个未连接的套接字转换成一个被动套接字，指示内核应该接受指向该套接字的连接请求。

内核为任何一个给定的监听套接字维护两个队列：

* 未完成连接队列：收到SYN分节，并发送SYNACK，处于SYN_RCVD状态。
* 已完成连接队列：已完成三次握手，处于ESTABLISHED状态，长度由backlog参数指定。（还没被accept，收到的数据会被缓存）

在三次握手正常完成的前提下，未完成连接队列中任何一项在其中的存留时间就是一个RTT。

当一个客户端SYN到达时，如果这些队列是满的，TCP就忽略该分节，而不发送RST。

### 4.6 accept函数
accept函数由TCP服务器调用，从已完成连接队列头返回下一个已完成连接。
第一个参数是监听套接字，返回已连接套接字描述符。

### 4.7 fork和exec函数
fork调用一次，返回两次。
父进程中调用fork之前打开的描述符在fork返回之后和子进程共享（引用计数变为2，为0时资源才会被释放）。

### 4.8 并发服务器

### 4.9 close函数
close函数用来关闭套接字，并终止TCP连接。

close调用后，该套接字描述符不能再由调用进程使用，TCP将尝试发送已排队等待发送到对端的任何数据，然后才是正常的TCP终止序列。

在引用计数不为0的时候，用shutdown函数代替close以强制在某个TCP连接上发送一个FIN。

### 4.10 getsockname和getpeername函数
返回与某个套接字关联的本地（外地）协议地址。

如果bind了一个通配IP地址，连接一旦建立，getsockname就可以用于返回由内核赋予该连接使用的本地源IP地址。

### 4.11 小结

## 5 TCP客户/服务器程序实例
### 5.1 概述
### 5.2 TCP回射服务器程序：main函数
### 5.3 TCP回射服务器程序：str_echo函数
### 5.4 TCP回射客户程序：main函数
### 5.4 TCP回射客户程序：str_cli函数
### 5.6 正常启动
用netstat和ps检查进程状态
`netstat -a`
`ps -o pid,ppid,tty,stat,args,wchan`

### 5.7 正常终止
### 5.8 POSIX信号处理
有两个信号不能被捕获SIGKILL和SIGSTOP。
在一个信号处理函数运行期间，正被递交的信号是阻塞的。
如果一个信号在被阻塞期间产生了一次或多次，那么解阻塞之后只递交一次。

### 5.9 处理SIGCHLD信号
当阻塞于某个**慢系统调用**的一个进程**捕获**某个信号且相应信号处理函数返回时，该系统调用可能返回一个错误，并设errno为EINTR。

### 5.10 wait和waitpid函数
要防止僵尸进程，在SIGCHLD信号处理函数中以WNOHANG选项循环调用waitpid而不是wait。

注意三种情况：

* 当fork子进程时，必须捕获SIGCHLD信号。
* 当捕获信号时，必须处理中断的系统调用。
* SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵尸进程。

### 5.11 accept返回前连接中止
当accept返回一个非致命错误，只需再次调用accept。

### 5.12 服务器进程终止
### 5.13 SIGPIPE信号
当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号，默认行为是终止进程。

### 5.14 服务器主机崩溃
### 5.15 服务器主机崩溃后重启
如果客户端不主动向服务器发送数据也想检测出主机崩溃，需要使用SO_KEEPALIVE套接字选项或心跳函数。

### 5.16 服务器主机关机
使用select或poll函数，是的服务器进程的终止一经发生，客户端就能检测到。

### 5.17 TCP程序例子小结
### 5.18 数据格式
解决数据格式问题：

* 把所有数值数据作为字符串来传递。
* 显式定义所支持的数据类型的二进制格式（位数，对齐限制，32/64bit，字节序）。

### 5.19 小结

## 6 I/O复用：select和poll函数
### 6.1 概述
I/O复用：内核一旦发现进程指定的一个或多个I/O条件就绪，它就通知进程。

### 6.2 I/O模型
一个输入操作通常包括两个阶段：

1. 当所等待的分组到达时，它被复制到内核中的某个缓冲区。
1. 把数据从内核缓冲区复制到应用进程缓冲区。

五种I/O模型：

* 阻塞式I/O：一直阻塞
* 非阻塞式I/O：主动轮询检查
* I/O复用：轮询函数阻塞，就绪通知
* 信号驱动式I/O：就绪信号通知
* 异步I/O：完成通知

同步I/O操作：导致请求阻塞进程，直到I/O操作完成。（前4种，第二阶段的I/O操作都阻塞进程）
异步I/O操作：不导致请求进程阻塞。（最后一种）

### 6.3 select函数
select函数允许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。

描述符不局限于套接字，任何描述符都可以用select来测试。
select等待时通常会被进程在等待期间捕获的信号中断，并从信号处理函数返回。
select使用描述符集，通常是个整数数组，其中每个整数中的每一位对应一个描述符。
使用四个宏来设定描述符：FD_ZERO/FD_SET/FD_CLR/FD_ISSET，常量FD_SETSIZE（通常是1024）是fd_set中的描述符总数。
指定select函数的三个参数指针都为空，就可以得到一个比sleep更精确的定时器（微秒）。
第一个参数maxfdp1，为了效率原因，它的值应为待测试的最大描述符加1。
每次调用select函数前，都得再次把所有描述符集内关心的位都置为1。

描述符就绪条件：

* 可读
    * 有数据可读，read返回大于0
    * 连接的读半部关闭（接收了FIN），read返回0
    * 给监听套接字准备好新连接
* 可写
    * 有可用于写的空间
    * 连接的写半部关闭，write将产生SIGPIPE信号
    * 使用非阻塞connect的套接字已建立连接或已失败
* 异常
    * TCP带外数据

对于套接字上发生的错误，则标记为既可读又可写，read/write返回-1。

### 6.4 str_cli函数（修订版）
### 6.5 批量输入
ping程序是测量RTT的一个简单方法。

### 6.6 shutdown函数
close有两个限制，可以用shutdown函数来避免：

* close把描述符引用计数减一，仅在0时才关闭套接字。而shutdown可以不管引用计数都触发TCP正常终止序列。
* close终止读和写两个方向的数据传送。

shutdown行为（howto参数）：

* SHUT_RD：关闭连接的读半部（并不发送FIN），套接字不再有数据可接收，接收缓冲区的现有数据都丢弃，接收的来自对端的任何数据都被确认并丢弃。
* SHUT_WR：关闭连接的写半部，称为半关闭，当前留在套接字发送缓冲区的数据将被发送掉，后跟TCP的正常终止序列。
* SHUT_RDWR：关闭连接的读写。

### 6.7 str_cli函数（再修订版）
### 6.8 TCP回射服务器程序（修订版）
当一个服务器处理多个客户时，它绝对不能阻塞只与单个客户相关的某个函数调用。解决：使用非阻塞I/O；单独进程/线程；设置超时。

### 6.9 pselect函数
pselect是能够处理信号阻塞并提供了更高时间精度的select增强版本。

### 6.10 poll函数
poll在处理流设备时能提供额外的信息。
poll没有select的最大描述符问题，由调用者指定长度。也不需要每次重设关心的事件。
poll识别三类数据：普通(NORM)，优先级带(BAND)，高优先级(PRI)。
测试就绪的错误部分(POLLERR/POLLHUP/POLLNVAL)不需指定，但发生时会在事件中返回。

关于[epoll](http://man7.org/linux/man-pages/man7/epoll.7.html)：
epoll效率较高：epoll_wait返回时已经确定了哪些描述符上发生了事件，不用再像select或poll那样一个个检查比对所有描述符。
支持水平触发LT(level triggered)和边缘触发ET(edge-triggered)两种行为。
相关操作：epoll_create/epoll_ctl/epoll_wait, 事件使用epoll_event结构。


### 6.11 TCP回射服务器程序（再修订版）
### 6.12 小结


## 20 广播
### 20.1 概述
TCP只支持单播寻址，而UDP和原始IP还支持其它寻址类型。IPv6往寻址体系结构中增加了任播(anycasting)方式。

要点：

* 多播支持在IPv4中是可选的，在IPv6中却是必需的。
* IPv6不支持广播。广播程序如果从IPv4移植就必需改用多播。
* 广播和多播要求用于UDP或原始IP，它们不能用于TCP。

广播的用途（多播同）：

* 资源发现（定位主机）
* 减少网络分组流通

例子：

* ARP （链路层广播而不是IP层广播）
* DHCP
* NTP
* 路由守护进程

### 20.2 广播地址
* 子网定向广播地址：{子网ID，-1}，作为指定子网上所有接口的广播地址。如192.168.42/24子网的定向广播地址为192.168.42.255。通常情况下路由器不转发这种广播。
* 受限广播地址：{-1，-1}或255.255.255.255。路由器从不转发这种广播。

### 20.3 单播和广播的比较
单播情况下，如果以太网地址不一致，接口会忽略这个帧。单播帧不会对该主机造成任何额外的开销，因为忽略它们的是接口而不是主机。
子网定向广播地址会被映射成48位全为1的以太网地址（ff:ff:ff:ff:ff:ff），使得每一个以太网接口都接受该帧。

若主机没有任何应用进程绑定指定UDP端口，则丢弃该广播数据包，该主机绝不能发送一个ICMP端口不可达消息，因为可能产生广播风暴。
广播分组去往子网上的所有主机，包括发送主机自身。

广播存在的根本问题：子网上参加相应广播应用的所有主机也不得不沿协议栈一路向上完整地处理收取的UDP广播数据包，直到该数据包经历UDP层时被丢弃为止。

### 20.4 使用广播的dg_cli函数
要发送广播数据包，需设置SO_BROADCAST套接字选项。
Berkeley内核不允许对广播数据包执行分片，如果大小超过外出接口的MTU，将返回EMSGSIZE错误。（Linux可以）

### 20.5 竞争状态
因为信号会在程序执行过程中由内核随时随地提交，让信号去中断阻塞的函数调用（如：recvfrom）几乎不可行（可以用pselect/sigsetjmp/siglongjmp）。
较好的做法是：不是让信号处理函数简单地返回并期望该返回能够中断阻塞中的recvfrom，而是让信号处理函数使用IPC（全局变量pipe）通知主控函数定时器已到时。

### 20.6 小结


## 21 多播
### 21.1 概述
### 21.2 多播地址
IPv4的D类地址（224.0.0.0~239.255.255.255）是IPv4的多播地址。D类地址的低序28位构成多播组ID。

* 224.0.0.1是所有主机组，包括子网上所有具有多播能力的节点。
* 224.0.0.2是所有路由器组，包括子网上所有多播路由器。

介于224.0.0.0到224.0.0.255之间的地址成为链路局部的多播地址。多播路由器从不转发以这些地址为目的地址的数据包。

IPv6多播地址的高序字节值为ff。

* ff01:1和ff02:1是所有节点组。
* ff01:2，ff02:2和ff05:2是所有路由器组。

IPv6多播地址显式存在一个4位的范围字段，用于指定多播数据包能够游走的范围。IPv4没有单独的范围字段，IPv4首部中的TTL字段兼用作多播范围字段，但可管理的范围划分更为可取。

范围                     |IPv6范围字段 |IPv4 TTL|IPv4可管理范围
-                                   |- |-    |-
接口局部的/interface                |1 |0    |
链路局部的/link，不可由路由器转发   |2 |1    |224.0.0.0~224.0.0.255
网点局部的/site                     |5 |<32  |239.255.0.0~239.255.255.255
组织机构局部的/organization         |8 |     |239.192.0.0~239.195.255.255
全球或全局的/global                 |14|<=255|224.0.1.0~238.255.255.255

### 21.3 局域网上多播和广播的比较
发送多播数据包无需任何特殊处理，发送应用进程不必为此加入多播组。
一个进程接收某个多播数据包的先决条件是该进程加入相应多播组并绑定相应端口。

### 21.4 广域网上的多播
多播相对于广播的优势在于不会给对多播组不感兴趣的主机增加额外负担。
多播路由器之间的通信使用某个多播路由协议。

### 21.5 源特定多播
广域网上的多播因为多个原因而难以部署。多播应用系统得使用唯一的地址，而全球性的多播地址分配机制尚未出现。

源特定多播（SSM）把应用系统的源地址结合到组地址上，在有限程度上解决了这些问题：

* 接受进程向多播路由器提供发送进程的源地址作为多播组加入操作的一部分。
* 把多播组的标识从单纯多播组地址细化为单播源地址和多播目的地址之组合（通道）。SSM会话由源地址，目的地址和端口三者的组合标识。

### 21.6 多播套接字选项
setsockopt
IP_ADD_MEMBERSHIP/IPV6_JOIN_GROUP/MCAST_JOIN_GROUP: 在一个指定的本地接口上加入一个不限源的多播组。
IP_DROP_MEMBERSHIP/IPV6_LEAVE_GROUP/MCAST_LEAVE_GROUP: 离开指定的本地接口上不限源的多播组。
IP_BLOCK_SOURCE/MCAST_BLOCK_SOURCE: 对于一个所指定本地接口上已存在的一个不限源的多播组，在本套接字上阻塞接收来自某个源的多播分组。
IP_UNBLOCK_SOURCE/MCAST_UNBLOCK_SOURCE: 开通一个先前被阻塞的源。
IP_ADD_SOURCE_MEMBERSHIP/MCAST_JOIN_SOURCE_GROUP: 在一个指定的本地接口上加入一个特定于源的多播组。
IP_DROP_SOURCE_MEMBERSHIP/MCAST_LEAVE_SOURCE_GROUP: 在一个指定的本地接口上离开一个特定于源的多播组。
IP_MULTICAST_IF/IPV6_MULTICAST_IF: 指定通过本套接字发送的多播数据包的外出接口。默认由内核选择。
IP_MULTICAST_TTL/IPV6_MULTICAST_HOPS: 给外出的多播数据包设置IPv4的TTL或IPv6的跳限。默认为1，本地子网范围。
IP_MULTICAST_LOOP/IPV6_MULTICAST_LOOP: 开启或禁止多播数据包的本地自环。默认开启。

如果本地接口指定为IPv4的通配地址（INADDR_ANY）或IPv6值为0的索引，那就由内核选择一个本地接口。
一个主机在某个给定接口上属于一个给定多播组的前提是该主机上当前有一个或多个进程在那个接口上属于该组。
如果一个进程加入某个多播组之后从不显式离开组，那么当相应套接字关闭时（显式关闭或进程终止），该成员关系也自动抹除。
有些应用进程除端口外还把多播地址也绑定到某个套接字，从而防止所在主机IP层把该端口收取的目的地址为其它单播、广播或多播地址的数据包递送到该套接字。

### 21.7 mcast_join和相关函数
if_nametoindex: 从接口名字获取索引
if_indextoname: 从索引获取接口名字
ioctl(SIOCGIFADDR): 从接口名字获取单播IP地址

### 21.8 使用多播的dg_cli函数
分片操作对于多播数据包不成问题。

### 21.9 接收IP多播基础设施会话声明
IP多播基础设施是具备域间多播能力的因特网之一部分。
想要在IP多播基础设施上声明某个会话的站点会周期性地往一个众所周知的多播组和UDP端口发送包含声明会话的某个描述的一个多播分组。如会话声明协议(SAP)的众所周知多播地址为224.2.127.254:9875。

### 21.10 发送和接收
禁止出现源IP地址是多播地址或广播地址的IP数据包。所以用于发送的套接字不能绑定在多播地址上（如果又要接收就必需使用两个套接字）。

### 21.11 SNTP: 简单网络时间协议

### 21.12 小结

</xmp>
<script src="js/strapdown.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.2/raphael-min.js"></script>
<script src="js/sequence-diagram-min.js"></script>
<script>
var seqs = document.querySelectorAll(".sequence");
for (var i = 0; i < seqs.length; i++) {
    var diagram = Diagram.parse(seqs[i].innerText);
    seqs[i].innerHTML = '';
    diagram.drawSVG(seqs[i], {theme: 'hand'});
}
</script>
</html>
