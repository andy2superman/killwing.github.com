<!DOCTYPE html>
<html>
<title>Unix Network Programming Vol.1 3ed</title>
<xmp theme="readable" style="display:none;">
## 1 简介
### 1.1 概述
### 1.2 一个简单的时间获取客户程序
### 1.3 协议无关性
### 1.4 错误处理：包裹函数
### 1.5 一个简单的时间获取服务器程序
### 1.6 本书中客户/服务器程序示例索引表
### 1.7 OSI模型
网络应用绕过传输层直接使用IPv4/6是可能的，使用raw socket。

协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。

* 物理层: 位（bit）
* 数据链路层: 帧（frame）
* 网络层: 包（packet），又叫分组
* 传输层: 段（segment），又叫分节

### 1.8 BSD网络支持历史
### 1.9 测试用网络及主机
### 1.10 Unix标准
### 1.11 64位体系结构
Socket API地址结构的长度使用socklen_t类型。
### 1.12 小结

## 2 传输层：TCP、UDP和SCTP
### 2.1 概述
### 2.2 总图
### 2.3 UDP
UDP不保证

* UDP数据包会到达其最终目的地
* 各个数据包的先后顺序跨网络后保持不变
* 每个数据包只到达一次

### 2.4 TCP
TCP提供

* 端对端的连接
* 可靠性：超时重传或故障通知
* 估算往返时间RTT
* 数据排序
* 流量控制：通过通告窗口指出接收缓冲区当前可用的空间量。当接收缓冲区满时，窗口大小为0。
* 拥塞控制
* 全双工

### 2.5 SCTP
SCTP提供

* 关联：取代连接，一个关联指代两个系统之间的一次通信。
* 多宿：单个SCTP端点能够支持多个IP地址，以增强网络故障的健壮性。
* 面向消息的按序递送服务。
* 多流：每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上消息的投递。（TCP会阻塞直至修复）

### 2.6 TCP连接的建立和终止
#### 2.6.1 三路握手
client: connect
server: bind, listen, accept

<pre class="sequence">
Title: TCP three-way handshake: Client active open, Server passive open
Note over Client: socket()
Note over Server: socket(),bind(),listen()
Note over Server: accept()
Note over Client: connect()
Client->Server: 1. SYN J
Server->Client: 2. SYN K,ACK J+1
Note left of Client: connect() return
Client->Server: 3. ACK K+1
Note right of Server: accept() return
</pre>

#### 2.6.2 TCP选项
每一个SYN可以含多个TCP选项

* MSS：最大分节大小，在本连接中的每个TCP分节中愿意接受的最大数据量。发送端使用接收端的MSS作为发送分节的最大大小。设置：TCP_MAXSEG。
* 窗口规模：TCP连接的任何一端能够通告对端的最大正常窗口大小是65535，这个选项指定了必须扩大（左移）的位数（0-14），因此最大窗口接近1GB（65535*2^14）。SO_RCVBUF选项影响这个选项。
* 时间戳

#### 2.6.3 TCP连接终止
主动关闭：close
被动关闭：read返回EOF -> close

<pre class="sequence">
Title: TCP connection termination: Client active close, Server passive close
Note over Client: close()
Client->Server: 1. FIN M
Note over Server: read() return 0
Server->Client: 2. ACK M+1
Note right of Server: half close
Note over Server: close()
Server->Client: 3. FIN N
Client->Server: 4. ACK N+1
</pre>

在2-3之间，从被动关闭一端到主动关闭一端的数据流动是可能的，称为**半关闭**。
当一个进程终止时，所有打开的描述符都被关闭，这会导致仍然打开的任何TCP连接上也发出一个FIN（不需要调close）。

#### 2.6.4 TCP状态转换图
![TCP State](http://upload.wikimedia.org/wikipedia/commons/a/a2/Tcp_state_diagram_fixed.svg)
可以用netstat监视状态

#### 2.6.5 观察分组
<pre class="sequence">
Title: TCP connection: Client active, Server passive
Note over Client: socket()
Note over Server: socket(),bind(),listen()
Note over Server: accept()
Note over Client: connect()
Client->Server: SYN J, MSS1
Note left of Client: SYN_SENT
Note right of Server: SYN_RCVD
Server->Client: SYN K,ACK J+1, MSS2
Note left of Client: ESTABLISHED
Note left of Client: connect() return
Client->Server: ACK K+1
Note right of Server: ESTABLISHED
Note right of Server: accept() return

Note over Server: read()
Note over Client: write()
Client->Server: PSH,ACK
Server->Client: ACK
Note right of Server: read() return
Note over Client: read()
Note over Server: write()
Server->Client: PSH,ACK
Client->Server: ACK
Note left of Client: read() return
Note over Server: read()

Note over Client: close()
Client->Server: FIN M
Note left of Client: FIN_WAIT_1
Note right of Server: CLOSE_WAIT
Note over Server: read() return 0
Server->Client: ACK M+1
Note left of Client: FIN_WAIT_2
Note over Server: close()
Server->Client: FIN N
Note right of Server: LAST_ACK
Note left of Client: TIME_WAIT
Client->Server: ACK N+1
Note right of Server: CLOSED
Note left of Client: 2MSL timeout
Note left of Client: CLOSED
</pre>

不同方向上MSS值不同不成问题。
捎带：服务器对客户端的请求的确认是伴随其应答发送，通常在服务器请求并产生应答的时间少于200ms时发生，否则分2个分节发送。
从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的一大堆细节从TCP转移到UDP应用进程。UDP则避免了TCP连接建立和终止所需的开销。

#### 2.6.7 TIME_WAIT状态
MSL: 任何IP数据报能够在因特网中存活的最长时间。
TIME_WAIT状态的持续时间是MSL的2倍。
执行主动关闭的那一端是处于TIME_WAIT状态的那一端。
TIME_WAIT状态存在的两个理由

* 可靠地实现TCP全双工连接的终止。需要正确处理连接终止序列4个分节中任何一个丢失的情况。
* 允许老的重复分节在网络中消逝。2MSL的时间防止了来自某个连接的老的重复分组在该连接已经终止后再现。

### 2.8 SCTP关联的建立和终止
#### 2.8.1 四路握手
client: connect
server: bind, listen, accept

<pre class="sequence">
Title: SCTP four-way handshake: Client active open, Server passive open
Note over Client: socket()
Note over Server: socket(),bind(),listen()
Note over Server: accept()
Note over Client: connect()
Client->Server: INIT(Ta, J)
Server->Client: Ta:INIT ACK(Tz, K, cookie C)
Client->Server: Tz: COOKIE ECHO C
Note right of Server: accept() return
Server->Client: Ta: COOKIE ACK
Note left of Client: connect() return
</pre>

在关联有效期内，验证标记Ta必须在对端发送的每个分组中出现，验证标记Tz也必须在本端发送的每个分组中出现。
四路握手结束时，两端各自选择一个主目的地址用作数据要发送到的目的地。
使用四路握手是为了避免一种DoS攻击。

#### 2.8.2 关联终止
主动关闭：close
被动关闭：read返回EOF -> close

<pre class="sequence">
Title: SCTP connection termination: Client active close, Server passive close
Note over Client: close()
Client->Server: SHUTDOWN
Note over Server: read() return 0
Note over Server: close()
Server->Client: SHUTDOWN ACK
Client->Server: SHUTDOWN COMPLETE
</pre>

没有半关闭的关联，当一端关闭某个关联时，另一端必须停止发送新的数据。
没有TIME_WAIT状态，因为使用了验证标记。

#### 2.8.3 SCTP状态转换图
#### 2.8.4 观察分组
#### 2.8.5 SCTP选项

### 2.9 端口号
0~1023: 众所周知的端口，可能的话，相同端口号就分给TCP/UDP/SCTP的同一给定服务。Unix下启动这些端口的服务需要root权限。
1024~49151: 已注册的端口。
49152~65535: 私有端口，临时端口。`49152 = 65536*3/4`

socket pair: 一个定义该连接的四元组，唯一标识一个网络上的每个TCP连接。标识每个端点的IP和端口号通常称为一个socket。
SCTP的同一个关联可能需要多个四元组标识（IP地址各不相同但端口号一样）。

### 2.10 TCP端口号与并发服务器
服务器可以指定只接受到达某个特定本地接口(IP地址)的外来连接，这里要么选一个接口要么选任意接口，不能指定某几个接口。
必须由socket pair才能确定由哪个端点(socket)接收某个到达的分节，已连接socket pair的由相应socket接收，其他指定目的端口的TCP分节都由监听socket接收。

### 2.11 缓冲区大小及限制
IPv4数据报的最大大小是65535字节，IPv6为65575字节。
IPv4要求最小链路MTU为68字节，IPv6为1280字节。
两个主机之间路径的最小MTU称为路径MTU。1500字节是以太网常见的路径MTU。
如果IP数据包超过相应链路的MTU，IPv4和IPv6都将执行分片。
IPv4头的DF(don't fragment)位若被设置，则不允许主机或路由器对它们分片。IPv6只有主机对其产生的数据报执行分片。
最小重组缓冲区大小：保证支持的最小数据报的大小，IPv4为576字节，IPv6为1500字节。
TCP的MSS的目的是告诉对端其最小重组缓冲区的实际值，从而试图避免分片。MSS经常设置成MTU减去IP和TCP的头部固定长度，IPv4为1460字节，IPv6为1440字节。
SCTP基于到对端的所有地址的最小路径MTU作为分片点。

#### 2.1.1 TCP输出
每个TCP socket有一个发送缓冲区，可以用SO_SNDBUF设置。
当写一个TCP socket的write调用成功返回仅仅表示可以重新使用原来的应用进程缓冲区（数据已成功复制到发送缓冲区，如果数据比发送缓冲区空闲大小还要大则write调用阻塞），并不表明对端的TCP或应用进程已经收到数据。
对端TCP必须确认收到的数据，只有对端ACK到达本端才能从发送缓冲区中丢弃已确认的数据。

#### 2.1.2 UDP输出
UDP的发送缓冲区并不存在，但它大小有个值，指写到该socket的数据大小的上限，可以用SO_SNDBUF设置。如果写一个大于发送缓冲区大小的数据，则返回EMSGSIZE错误。
UDP不可靠，没有发送缓冲区，不保存应用进程数据的副本，发送后即弃。
相比TCP应用数据更有可能被分片，因为TCP会把应用数据划分成MSS大小，而UDP没有对等的手段。
当写一个UDP socket的write调用成功返回仅仅表示所写的数据报或其所有分片已被加入数据链路层的输出队列。如果队列没有空间则会返回ENOBUF错误给应用进程（不一定，可能直接被丢掉）。

#### 2.1.3 SCTP输出
和TCP类似。

### 2.12 标准因特网服务
### 2.13 常见因特网应用的协议使用
### 2.14 小结


## 3 套接字编程简介
### 3.1 概述
### 3.2 套接字地址结构
一般套接字函数使用通用套接字结构sockaddr，sa_len, sa_family, sa_data[14]。结构大小16字节。
IPv4套接字结构sockaddr_in，POSIX规范只需要三个字段: sin_family(AF_INET), sin_addr, sin_port。端口号以网络字节序存储。32位地址，结构大小16字节。
IPv6套接字结构sockaddr_in6，sin6_family(AF_INET6), sin6_addr, sin6_port。128位地址，结构大小28字节。
还有Unix域结构sockaddr_un/AF_LOCAL, 数据链路结构sockaddr_dl/AF_LINK。
新通用套接字结构sockaddr_storage，ss_len, ss_family。与sockaddr相比能满足苛刻的对齐要求，而且足够大可以容纳所有结构种类。

### 3.3 值-结果参数
传入套接字地址结构的函数：bind, connect, sendto。
传出套接字地址结构的函数：accept, recvfrom, getsockname。

### 3.4 字节排序函数
小端little-endian：低序字节存储在起始地址。(低地址放低位)
大端big-endian：高序字节存储在起始地址。(低地址放高位)
一个字节内部位的排序，不存在大小端问题，高位在前。
转换函数：htons, htonl, ntohs, ntohl。

位序：在RFC分组图示中，最左边的位是最早出现（最先读到）的最高有效位。

### 3.5 字节操纵函数
Berkeley函数strings.h: bzero, bcopy, bcmp。
ANSI C函数string.h: memset, memcpy, memcmp。
bcopy能处理源地址和目标地址有重叠的情况，而memcpy不能，需要用memmove。

### 3.6 inet_aton, inet_addr和inet_ntoa函数
只适用IPv4：点分十进制字符串(ascii)和网络字节序二进制值(numeric)之间的转换。
inet_ntoa使用了静态内存，因此不可重入。

### 3.7 inet_pton和inet_ntop函数
同时适用IPv4和IPv6：地址字符串(presentation)和网络字节序二进制值(numeric)之间的转换。

### 3.8 sock_ntop相关函数
IPv4/6协议无关的wrap函数。

### 3.9 readn, writen和readline函数
字节流套接字上调用read或write输入或输出的字节数可能比请求的数量少，但这不是出错状态。read时很常见，write只有在该套接字为非阻塞下才出现。

### 3.10 小结


## 4 基本TCP套接字编程
### 4.1 概述
### 4.2 socket函数
用socket函数指定期望的通信协议类型。

* family: AF_NET, AF_NET6, AF_LOCAL, AF_ROUTE, AF_KEY
* type: SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET, SOCK_RAW
* protocol: IPPROTO_TCP, IPPROTO_UDP, IPPROTO_SCTP

AF前缀表示地址族，PF前缀表示协议族（不常用）。

### 4.3 connect函数
TCP客户端用connect函数来建立与TCP服务器的连接。

客户在调用connect函数前不必非得调用bind函数，需要的话内核会确定源IP地址，并选择一个临时端口作为源端口。

出错返回：

* 若没有收到SYN分节的响应，则返回ETIMEOUT错误。
* 若收到SYN的响应是RST，则返回ECONNREFUSED错误。表示服务器上指定的端口没有进程等待连接。
* 若发出的SYN在中间的某个路由器上引发了一个目的地不可达的ICMP错误，则返回EHOSTUNREACH/ENETUNREACH错误。

若connect失败则该套接字不再可用，必须关闭。创建新的套接字重新连接。

RST是TCP在发生错误时发送的一种TCP分节。产生RST的三种情况是：

* SYN到达而服务器上指定的端口没有进程等待连接（监听）。
* TCP想取消一个已有连接。
* TCP接收到一个根本不存在的连接上的分节。

### 4.4 bind函数
bind函数把一个本地协议地址赋予一个套接字。

对于TCP：
如果未曾用bind绑定一个端口，当调用connect或listen时，内核就要为相应的套接字选择一个临时端口。
如果不绑定一个IP地址，对于客户端，内核将根据所有外出网络接口来选择源IP地址；对于服务器，内核就把客户发送的SYN的目的IP地址作为服务器的源IP地址。

通配地址：INADDR_ANY (IPv4), in6addr_any (IPv6)

### 4.5 listen函数
listen函数仅由TCP服务器调用：把一个未连接的套接字转换成一个被动套接字，指示内核应该接受指向该套接字的连接请求。

内核为任何一个给定的监听套接字维护两个队列：

* 未完成连接队列：收到SYN分节，并发送SYNACK，处于SYN_RCVD状态。
* 已完成连接队列：已完成三次握手，处于ESTABLISHED状态，长度由backlog参数指定。（还没被accept，收到的数据会被缓存）

在三次握手正常完成的前提下，未完成连接队列中任何一项在其中的存留时间就是一个RTT。

当一个客户端SYN到达时，如果这些队列是满的，TCP就忽略该分节，而不发送RST。

### 4.6 accept函数
accept函数由TCP服务器调用，从已完成连接队列头返回下一个已完成连接。
第一个参数是监听套接字，返回已连接套接字描述符。

### 4.7 fork和exec函数
fork调用一次，返回两次。
父进程中调用fork之前打开的描述符在fork返回之后和子进程共享（引用计数变为2，为0时资源才会被释放）。

### 4.8 并发服务器

### 4.9 close函数
close函数用来关闭套接字，并终止TCP连接。

close调用后，该套接字描述符不能再由调用进程使用，TCP将尝试发送已排队等待发送到对端的任何数据，然后才是正常的TCP终止序列。

在引用计数不为0的时候，用shutdown函数代替close以强制在某个TCP连接上发送一个FIN。

### 4.10 getsockname和getpeername函数
返回与某个套接字关联的本地（外地）协议地址。

如果bind了一个通配IP地址，连接一旦建立，getsockname就可以用于返回由内核赋予该连接使用的本地源IP地址。

### 4.11 小结

## 5 TCP客户/服务器程序实例
### 5.1 概述
### 5.2 TCP回射服务器程序：main函数
### 5.3 TCP回射服务器程序：str_echo函数
### 5.4 TCP回射客户程序：main函数
### 5.4 TCP回射客户程序：str_cli函数
### 5.6 正常启动
用netstat和ps检查进程状态
`netstat -a`
`ps -o pid,ppid,tty,stat,args,wchan`

### 5.7 正常终止
### 5.8 POSIX信号处理
有两个信号不能被捕获SIGKILL和SIGSTOP。
在一个信号处理函数运行期间，正被递交的信号是阻塞的。
如果一个信号在被阻塞期间产生了一次或多次，那么解阻塞之后只递交一次。

### 5.9 处理SIGCHLD信号
当阻塞于某个**慢系统调用**的一个进程**捕获**某个信号且相应信号处理函数返回时，该系统调用可能返回一个错误，并设errno为EINTR。

### 5.10 wait和waitpid函数
要防止僵尸进程，在SIGCHLD信号处理函数中以WNOHANG选项循环调用waitpid而不是wait。

注意三种情况：

* 当fork子进程时，必须捕获SIGCHLD信号。
* 当捕获信号时，必须处理中断的系统调用。
* SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵尸进程。

### 5.11 accept返回前连接中止
当accept返回一个非致命错误，只需再次调用accept。

### 5.12 服务器进程终止
### 5.13 SIGPIPE信号
当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号，默认行为是终止进程。

### 5.14 服务器主机崩溃
### 5.15 服务器主机崩溃后重启
如果客户端不主动向服务器发送数据也想检测出主机崩溃，需要使用SO_KEEPALIVE套接字选项或心跳函数。

### 5.16 服务器主机关机
使用select或poll函数，是的服务器进程的终止一经发生，客户端就能检测到。

### 5.17 TCP程序例子小结
### 5.18 数据格式
解决数据格式问题：

* 把所有数值数据作为字符串来传递。
* 显式定义所支持的数据类型的二进制格式（位数，对齐限制，32/64bit，字节序）。

### 5.19 小结

## 6 I/O复用：select和poll函数
### 6.1 概述
I/O复用：内核一旦发现进程指定的一个或多个I/O条件就绪，它就通知进程。

### 6.2 I/O模型
一个输入操作通常包括两个阶段：

1. 当所等待的分组到达时，它被复制到内核中的某个缓冲区。
1. 把数据从内核缓冲区复制到应用进程缓冲区。

五种I/O模型：

* 阻塞式I/O：一直阻塞
* 非阻塞式I/O：主动轮询检查
* I/O复用：轮询函数阻塞，就绪通知
* 信号驱动式I/O：就绪信号通知
* 异步I/O：完成通知

同步I/O操作：导致请求阻塞进程，直到I/O操作完成。（前4种，第二阶段的I/O操作都阻塞进程）
异步I/O操作：不导致请求进程阻塞。（最后一种）

### 6.3 select函数
select函数允许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。

描述符不局限于套接字，任何描述符都可以用select来测试。
select等待时通常会被进程在等待期间捕获的信号中断，并从信号处理函数返回。
select使用描述符集，通常是个整数数组，其中每个整数中的每一位对应一个描述符。
使用四个宏来设定描述符：FD_ZERO/FD_SET/FD_CLR/FD_ISSET，常量FD_SETSIZE（通常是1024）是fd_set中的描述符总数。
指定select函数的三个参数指针都为空，就可以得到一个比sleep更精确的定时器（微秒）。
第一个参数maxfdp1，为了效率原因，它的值应为待测试的最大描述符加1。
每次调用select函数前，都得再次把所有描述符集内关心的位都置为1。

描述符就绪条件：

* 可读
    * 有数据可读，read返回大于0
    * 连接的读半部关闭（接收了FIN），read返回0
    * 给监听套接字准备好新连接
* 可写
    * 有可用于写的空间
    * 连接的写半部关闭，write将产生SIGPIPE信号
    * 使用非阻塞connect的套接字已建立连接或已失败
* 异常
    * TCP带外数据

对于套接字上发生的错误，则标记为既可读又可写，read/write返回-1。

### 6.4 str_cli函数（修订版）
### 6.5 批量输入
ping程序是测量RTT的一个简单方法。

### 6.6 shutdown函数
close有两个限制，可以用shutdown函数来避免：

* close把描述符引用计数减一，仅在0时才关闭套接字。而shutdown可以不管引用计数都触发TCP正常终止序列。
* close终止读和写两个方向的数据传送。

shutdown行为（howto参数）：

* SHUT_RD：关闭连接的读半部（并不发送FIN），套接字不再有数据可接收，接收缓冲区的现有数据都丢弃，接收的来自对端的任何数据都被确认并丢弃。
* SHUT_WR：关闭连接的写半部，称为**半关闭**，当前留在套接字发送缓冲区的数据将被发送掉，后跟TCP的正常终止序列。
* SHUT_RDWR：关闭连接的读写。

### 6.7 str_cli函数（再修订版）
### 6.8 TCP回射服务器程序（修订版）
当一个服务器处理多个客户时，它绝对不能阻塞只与单个客户相关的某个函数调用。解决：使用非阻塞I/O；单独进程/线程；设置超时。

### 6.9 pselect函数
pselect是能够处理信号阻塞并提供了更高时间精度的select增强版本。

### 6.10 poll函数
poll在处理流设备时能提供额外的信息。
poll没有select的最大描述符问题，由调用者指定长度。也不需要每次重设关心的事件。
poll识别三类数据：普通(NORM)，优先级带(BAND)，高优先级(PRI)。
测试就绪的错误部分(POLLERR/POLLHUP/POLLNVAL)不需指定，但发生时会在事件中返回。

----
Linux中的[epoll](http://man7.org/linux/man-pages/man7/epoll.7.html)：
epoll效率较高：epoll内部维护（红黑树）了通过epoll_ctrl加入的所有描述符，不用再像select或poll那样每次一个个检查比对所有描述符，epoll_wait返回时已经确定了哪些描述符上发生了就绪事件。

事件触发的两种行为：

* 水平触发LT(Level Triggered): 默认行为，如果描述符一直在就绪状态就一直触发，就像poll的更快版本。
* 边缘触发ET(Edge Triggered): 只有描述符状态改变（从未就绪变为就绪）时才触发一次而不会重复触发，效率较LT高。如果read/write返回EAGAIN则变为未就绪状态。因为就绪事件只触发一次，为了避免收不到更多的事件通知而使I/O操作阻塞，读写应该使用非阻塞描述符。

事件类型：EPOLLIN/EPOLLOUT/EPOLLRDHUP/EPOLLPRI/EPOLLERR/EPOLLHUP/EPOLLET/EPOLLONESHOT
相关操作：epoll_create/epoll_ctl/epoll_wait, 事件使用epoll_event结构。

### 6.11 TCP回射服务器程序（再修订版）
### 6.12 小结


## 7 套接字选项
### 7.1 概述
### 7.2 getsockopt和setsockopt函数
对于标志选项，0表示被禁止，非0表示启用。

### 7.3 检查选项是否受支持并获取默认值
### 7.4 套接字状态
由TCP已连接套接字从监听套接字继承而来的选项：SO_DEBUG, SO_DONTROUTE, SO_KEEPALIVE, SO_LINGER, SO_OOBINLINE, SO_RCVBUF, SO_RCVLOWAT, SO_SNDBUF, SO_SNDLOWAT, TCP_MAXSEG, TCP_NODELAY.
如果想在三次握手完成时就确保这些套接字选项是已经给已连接套接字设置好，必须先给监听套接字设置该选项。

### 7.5 通用套接字选项
设置参数级别：SOL_SOCKET

**SO_BROADCAST 允许发送广播数据报 (UDP)**

**SO_DEBUG 开启调式跟踪 (TCP)**
信息保存在内核的某个环形缓冲区中，使用`trpt`程序查看。

**SO_DONTROUTE 绕过外出路由表查询**

**SO_ERROR 获取待处理错误并清除**
当套接字上发生错误时，so_error被设为标准Unix错误值，内核以两种方式立即通知进程：

* 如果阻塞在select调用上，返回可读或可写事件
* 如果使用信号驱动I/O模型，产生一个SIGIO信号

当read/write返回-1出错时，errno被置为so_error的值，so_error随后被置为0。

**SO_KEEPALIVE 周期性测试连接是否存活 (TCP)**
如果2小时内在该套接字的任何一方向上都没有数据交换，TCP就自动给对端发送一个保持存活探测分节：

* 对端响应ACK：应用进程不会有任何通知。
* 对端响应RST：套接字so_error被设为ECONNRESET。
* 对端没有响应：每75s再发一个，共再发8次，即从第一个开始11分15秒后没有响应则放弃，so_error被设为ETIMEOUT。若收到ICMP错误，那就返回相应的错误（一般为EHOSTUNREACH）。

时间参数为内核所维护，修改会影响该主机上所有开启本选项的套接字。
本选项的功能是检测对端主机是否崩溃或不可达。也可能会终止一个有效连接。
一般用于检测**半开连接**并终止它们：对端崩溃，本端一直等待永远不会到达的输入。

检测TCP条件：

本端|对端进程退出或崩溃|对端主机崩溃或对端主机不可达
-|-|-
主动发送数据|对端发送FIN，本端可通过select可读事件检测到<br>本端发送数据，对端响应RST，再写会产生SIGPIPE信号|本端TCP将超时，so_error被设为ETIMEOUT/EHOSTUNREACH
主动接收数据|对端发送FIN，本端读到EOF|停止收到数据
空闲，KA选项设置|对端发送FIN，本端可通过select可读事件检测到|探测分节无响应，so_error被设为ETIMEOUT/EHOSTUNREACH
空闲，KA未设置|对端发送FIN，本端可通过select可读事件检测到|（无）

**SO_LINGER 若有数据发送则延时关闭 (TCP/SCTP)**
当选项开启时(l_onoff != 0)：

* l_linger == 0: 当close时，丢弃发送和接收缓冲区的数据，并发送RST给对端，状态变为CLOSED。
* l_linger > 0: 延滞的秒数，close阻塞直到：
    * 所有数据都已发送完，包括FIN均被对方确认。（成功返回，但不能保证对端进程已经读到数据）
    * 延滞时间到，返回错误。如果套接字是非阻塞型，则立即返回。（失败返回，错误为EWOULDBLOCK，丢弃发送缓冲区数据）

让本端知道对端已读到数据的方法：

* 调用shutdown(SHUT_WR)而不是close，后跟一个read，一直等到接收了对端的FIN才返回。
* 使用应用级确认。

**SO_OOBINLINE 让接收到的带外数据继续在线留存**
接收函数的MGS_OOB标志不能用来读带外数据。

**SO_RCVBUF/SO_SNDBUF 接收和发送缓冲区大小**
对于TCP，套接字接收缓冲区中可用空间限定了通告对端的窗口大小。
UDP没有发送缓冲区（但有一个大小，影响可发送的最大数据长度），只有接收缓冲区，当接收到的数据报装不进缓冲区时就被丢弃。
给已连接套接字设置该选项对于可能存在的窗口规模选项没有任何影响。
TCP套接字缓冲区大小至少应该是相应连接MSS值的四倍。
设置套接字缓冲区大小时的性能考虑，在于全双工管道的的容量（称为**带宽延迟积BDP**：带宽*RTT，RTT可以由ping程序测得）。
POSIX函数fpathconf(_PC_SOCK_MAXBUF)可以获取可设的最大缓冲区大小上限。

----
Linux相关内核参数（使用[sysctl](http://man7.org/linux/man-pages/man8/sysctl.8.html)控制）
SO_RCVBUF/SO_SNDBUF用来设置或获取一个套接字的最大缓冲区大小，内核会翻倍所设进的值，获取时也返回实际翻倍的值。

实际值|接收|发送
-|-
默认值|net.core.rmem_default|net.core.wmem_default
最大值|net.core.rmem_max|net.core.wmem_max
最小值|256|2048

对于TCP，net.ipv4.tcp_mem/net.ipv4.tcp_rmem/net.ipv4.tcp_wmem和SO_RCVBUF/SO_SNDBUF的可设置范围无关，被由内核用来根据这些值来自动调整收发缓冲区大小。对于接收缓冲区可以用参数net.ipv4.tcp_moderate_rcvbuf设置（默认开启），对于发送缓冲区不可设置总是开启。但如果应用自己设置了SO_RCVBUF/SO_SNDBUF的值，自动调整功能就失效。

**SO_RCVLOWAT/SO_SNDLOWAT 接收和发送缓冲区低水位标记**
由select函数使用：

* 接收低水位标记是让select返回“可读”时套接字接收缓冲区中所需的数据量。默认都为1.
* 发送低水位标记是让select返回“可写”时套接字发送缓冲区中所需的可用空间。默认TCP为2048，而UDP只要发送缓冲区大小（为SO_SNDBUF不变）大于该标记就总是可写。

**SO_RCVTIMEO/SO_SNDTIMEO 接收和发送超时**
接收超时影响5个输入函数：read, readv, recv, recvfrom, recvmsg
发送超时影响5个输出函数：write, writev, send, sendto, sendmsg

**SO_REUSEADDR/SO_REUSEPORT 允许重用本地地址和端口**
SO_REUSEADDR的作用：

* 允许启动一个监听服务器并绑定其端口，即使以前建立的相同本地端口的连接仍然存在（但进程实例已经不存在，处理连接的可以是原来进程的子进程）。
* 允许在同一端口上启动同一服务器的多个实例进程，只要每个实例绑定不同的本地IP地址即可。对于外来请求，使用通配地址的实例总是在最后匹配。
* 允许单个进程绑定同一端口到多个套接字上，只要每次绑定不同的本地IP地址即可。
* 允许完全重复IP和端口的绑定，仅UDP可用。单播情况下对于外来请求，哪个套接字接收取决于实现。

SO_REUSEPORT的作用：

* 允许完全重复IP和端口的绑定，要绑定的每个套接字都必须指定此选项。
* 如果绑定的IP地址是一个多播地址，则和SO_REUSEADDR等效。

建议：

* 对于TCP服务器，在绑定前总是设置SO_REUSEADDR选项。
* 对于可以同时运行多次的多播应用程序，设置SO_REUSEADDR选项，并将参加多播组的地址作为本地IP地址绑定。

**SO_TYPE 取得套接字类型**

**SO_USELOOPBACK 路由套接字取得所发送数据的副本**
仅用于路由域套接字，是唯一一个默认打开的SO_系列标志选项。

### 7.6 IPv4套接字选项
设置参数级别：IPPROTO_IP

**IP_HDRINCL 随数据包含的IP头**
如果本选项是给一个原始IP套接字设置的，那么必须构造自己的IP头以修改某些字段。

**IP_OPTIONS IP头选项**

**IP_RECVDSTADDR 返回目的IP地址**

**IP_RECVIF 返回接收接口索引**

**IP_TOS 服务类型和优先权**

**IP_TTL 存活时间**
TCP/UDP使用的默认值是64。

### 7.7 ICMPv6套接字选项
设置参数级别：IPPROTO_ICMPV6

**ICMP6_FILTER 指定待传递的ICMPv6消息类型**

### 7.8 IPv6套接字选项
设置参数级别：IPPROTO_IPV6

**IPV6_CHECKSUM 用于原始套接字的校验和字段偏移**
**IPV6_DONTFRAG 丢弃大的分组而非将其分片**
**IPV6_NEXTHOP 指定下一跳地址**
**IPV6_PATHMTU 获取当前路径MTU**
**IPV6_RECVDSTOPTS 接收目的地选项**
**IPV6_RECVHOPLIMIT 接收单播跳限**
**IPV6_RECVHOPOPTS 接收步跳选项**
**IPV6_RECVPATHMTU 接收路径MTU**
**IPV6_RECVKTINFO 接收分组信息**
**IPV6_RECVTHDR 接收源路径**
**IPV6_RECVTCLASS 接收流通类别**
**IPV6_UNICAST_HOPS 默认单播跳限**
**IPV6_USE_MIN_MTU 使用最小MTU**
**IPV6_V6ONLY 禁止v4兼容**
**IPV6_XXX 粘附性辅助数据**

### 7.9 TCP套接字选项
设置参数级别：IPPROTO_TCP

**TCP_MAXSEG TCP最大分节大小**
套接字连接后，返回TCP可以发送给对端的最大数据量，由对端使用SYN分节通告的MSS。未连接时返回默认值。

**TCP_NODELAY 禁止Nagle算法**
该算法默认是开启的，目的在于减少广域网上小分组（小于MSS）的数目，防止一个连接在任何时刻有多个小分组待确认。
常常与另一个TCP算法：ACK延滞算法（ACK尽量与可能的数据一起发回，从而省掉一个TCP分节）联合使用。

### *7.10 SCTP套接字选项*
设置参数级别：IPPROTO_SCTP

**SCTP_ADAPTION_LAYER 适配层指示**
**SCTP_ASSOCINFO 检查并设置关联信息**
**SCTP_AUTOCLOSE 自动关闭操作**
**SCTP_DEFAULT_SEND_PARAM 默认发送参数**
**SCTP_DISABLE_FRAGMENTS SCTP分片**
**SCTP_EVENTS 感兴趣事件的通知**
**SCTP_GET_PEER_ADDR_INFO 获取对端地址状态**
**SCTP_I_WAIT_MAPPED_V4_ADDR 映射的v4地址**
**SCTP_INITMSG 默认的INIT参数**
**SCTP_MAXBURST 最大爆发大小**
**SCTP_MAXSEG 最大分片大小**
**SCTP_NODELAY 禁止Nagle算法**
**SCTP_PEER_ADDR_PARAMS 对端地址参数**
**SCTP_PRIMARY_ADDR 主目的地址**
**SCTP_RTOINFO RTO信息**
**SCTP_SET_PEER_PRIMARY_ADDR 对端主目的地址**
**SCTP_STATUS 获取关联状态**

### 7.11 fcntl函数
和套接字有关的两个标志：O_NONBLOCK（非阻塞式I/O），O_ASYNC（信号驱动式I/O）。
设置某个文件状态标志的唯一正确方法是：先获取当前标志，与新标志逻辑或（`|=flag`，清除是`&=~flag`）后再设置标志。

### 7.12 小结

## 20 广播
### 20.1 概述
TCP只支持单播寻址，而UDP和原始IP还支持其它寻址类型。IPv6往寻址体系结构中增加了任播(anycasting)方式。

要点：

* 多播支持在IPv4中是可选的，在IPv6中却是必需的。
* IPv6不支持广播。广播程序如果从IPv4移植就必需改用多播。
* 广播和多播要求用于UDP或原始IP，它们不能用于TCP。

广播的用途（多播同）：

* 资源发现（定位主机）
* 减少网络分组流通

例子：

* ARP （链路层广播而不是IP层广播）
* DHCP
* NTP
* 路由守护进程

### 20.2 广播地址
* 子网定向广播地址：{子网ID，-1}，作为指定子网上所有接口的广播地址。如192.168.42/24子网的定向广播地址为192.168.42.255。通常情况下路由器不转发这种广播。
* 受限广播地址：{-1，-1}或255.255.255.255。路由器从不转发这种广播。

### 20.3 单播和广播的比较
单播情况下，如果以太网地址不一致，接口会忽略这个帧。单播帧不会对该主机造成任何额外的开销，因为忽略它们的是接口而不是主机。
子网定向广播地址会被映射成48位全为1的以太网地址（ff:ff:ff:ff:ff:ff），使得每一个以太网接口都接受该帧。

若主机没有任何应用进程绑定指定UDP端口，则丢弃该广播数据包，该主机绝不能发送一个ICMP端口不可达消息，因为可能产生广播风暴。
广播分组去往子网上的所有主机，包括发送主机自身。

广播存在的根本问题：子网上参加相应广播应用的所有主机也不得不沿协议栈一路向上完整地处理收取的UDP广播数据包，直到该数据包经历UDP层时被丢弃为止。

### 20.4 使用广播的dg_cli函数
要发送广播数据包，需设置SO_BROADCAST套接字选项。
Berkeley内核不允许对广播数据包执行分片，如果大小超过外出接口的MTU，将返回EMSGSIZE错误。（Linux可以）

### 20.5 竞争状态
因为信号会在程序执行过程中由内核随时随地提交，让信号去中断阻塞的函数调用（如：recvfrom）几乎不可行（可以用pselect/sigsetjmp/siglongjmp）。
较好的做法是：不是让信号处理函数简单地返回并期望该返回能够中断阻塞中的recvfrom，而是让信号处理函数使用IPC（全局变量pipe）通知主控函数定时器已到时。

### 20.6 小结


## 21 多播
### 21.1 概述
### 21.2 多播地址
IPv4的D类地址（224.0.0.0~239.255.255.255）是IPv4的多播地址。D类地址的低序28位构成多播组ID。

* 224.0.0.1是所有主机组，包括子网上所有具有多播能力的节点。
* 224.0.0.2是所有路由器组，包括子网上所有多播路由器。

介于224.0.0.0到224.0.0.255之间的地址成为链路局部的多播地址。多播路由器从不转发以这些地址为目的地址的数据包。

IPv6多播地址的高序字节值为ff。

* ff01:1和ff02:1是所有节点组。
* ff01:2，ff02:2和ff05:2是所有路由器组。

IPv6多播地址显式存在一个4位的范围字段，用于指定多播数据包能够游走的范围。IPv4没有单独的范围字段，IPv4首部中的TTL字段兼用作多播范围字段，但可管理的范围划分更为可取。

范围                     |IPv6范围字段 |IPv4 TTL|IPv4可管理范围
-                                   |- |-    |-
接口局部的/interface                |1 |0    |
链路局部的/link，不可由路由器转发   |2 |1    |224.0.0.0~224.0.0.255
网点局部的/site                     |5 |<32  |239.255.0.0~239.255.255.255
组织机构局部的/organization         |8 |     |239.192.0.0~239.195.255.255
全球或全局的/global                 |14|<=255|224.0.1.0~238.255.255.255

### 21.3 局域网上多播和广播的比较
发送多播数据包无需任何特殊处理，发送应用进程不必为此加入多播组。
一个进程接收某个多播数据包的先决条件是该进程加入相应多播组并绑定相应端口。

### 21.4 广域网上的多播
多播相对于广播的优势在于不会给对多播组不感兴趣的主机增加额外负担。
多播路由器之间的通信使用某个多播路由协议。

### 21.5 源特定多播
广域网上的多播因为多个原因而难以部署。多播应用系统得使用唯一的地址，而全球性的多播地址分配机制尚未出现。

源特定多播（SSM）把应用系统的源地址结合到组地址上，在有限程度上解决了这些问题：

* 接受进程向多播路由器提供发送进程的源地址作为多播组加入操作的一部分。
* 把多播组的标识从单纯多播组地址细化为单播源地址和多播目的地址之组合（通道）。SSM会话由源地址，目的地址和端口三者的组合标识。

### 21.6 多播套接字选项
setsockopt
IP_ADD_MEMBERSHIP/IPV6_JOIN_GROUP/MCAST_JOIN_GROUP: 在一个指定的本地接口上加入一个不限源的多播组。
IP_DROP_MEMBERSHIP/IPV6_LEAVE_GROUP/MCAST_LEAVE_GROUP: 离开指定的本地接口上不限源的多播组。
IP_BLOCK_SOURCE/MCAST_BLOCK_SOURCE: 对于一个所指定本地接口上已存在的一个不限源的多播组，在本套接字上阻塞接收来自某个源的多播分组。
IP_UNBLOCK_SOURCE/MCAST_UNBLOCK_SOURCE: 开通一个先前被阻塞的源。
IP_ADD_SOURCE_MEMBERSHIP/MCAST_JOIN_SOURCE_GROUP: 在一个指定的本地接口上加入一个特定于源的多播组。
IP_DROP_SOURCE_MEMBERSHIP/MCAST_LEAVE_SOURCE_GROUP: 在一个指定的本地接口上离开一个特定于源的多播组。
IP_MULTICAST_IF/IPV6_MULTICAST_IF: 指定通过本套接字发送的多播数据包的外出接口。默认由内核选择。
IP_MULTICAST_TTL/IPV6_MULTICAST_HOPS: 给外出的多播数据包设置IPv4的TTL或IPv6的跳限。默认为1，本地子网范围。
IP_MULTICAST_LOOP/IPV6_MULTICAST_LOOP: 开启或禁止多播数据包的本地自环。默认开启。

如果本地接口指定为IPv4的通配地址（INADDR_ANY）或IPv6值为0的索引，那就由内核选择一个本地接口。
一个主机在某个给定接口上属于一个给定多播组的前提是该主机上当前有一个或多个进程在那个接口上属于该组。
如果一个进程加入某个多播组之后从不显式离开组，那么当相应套接字关闭时（显式关闭或进程终止），该成员关系也自动抹除。
有些应用进程除端口外还把多播地址也绑定到某个套接字，从而防止所在主机IP层把该端口收取的目的地址为其它单播、广播或多播地址的数据包递送到该套接字。

### 21.7 mcast_join和相关函数
if_nametoindex: 从接口名字获取索引
if_indextoname: 从索引获取接口名字
ioctl(SIOCGIFADDR): 从接口名字获取单播IP地址

### 21.8 使用多播的dg_cli函数
分片操作对于多播数据包不成问题。

### 21.9 接收IP多播基础设施会话声明
IP多播基础设施是具备域间多播能力的因特网之一部分。
想要在IP多播基础设施上声明某个会话的站点会周期性地往一个众所周知的多播组和UDP端口发送包含声明会话的某个描述的一个多播分组。如会话声明协议(SAP)的众所周知多播地址为224.2.127.254:9875。

### 21.10 发送和接收
禁止出现源IP地址是多播地址或广播地址的IP数据包。所以用于发送的套接字不能绑定在多播地址上（如果又要接收就必需使用两个套接字）。

### 21.11 SNTP: 简单网络时间协议

### 21.12 小结

</xmp>
<script src="js/strapdown.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/raphael/2.1.2/raphael-min.js"></script>
<script src="js/sequence-diagram-min.js"></script>
<script>
var seqs = document.querySelectorAll(".sequence");
for (var i = 0; i < seqs.length; i++) {
    var diagram = Diagram.parse(seqs[i].innerText);
    seqs[i].innerHTML = '';
    diagram.drawSVG(seqs[i], {theme: 'hand'});
}
</script>
</html>
