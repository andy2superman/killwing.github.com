<!DOCTYPE html>
<html>
<title>Chrome Extension</title>
<xmp theme="united" style="display:none;">
## UI
两种形式：最多一个
所有扩展里的UI页面（popup.html，设置页面，`tab.create`和`window.open`打开的页面）都称为view。

### browser action
总是激活，和当前页面无关（或和所有页面都相关）。

manifest:
```
{
        "name": "My extension",
        ...
        "browser_action": {
          "default_icon": {                    // optional
            "16": "images/icon16.png",           // optional
            "24": "images/icon24.png",           // optional
            "32": "images/icon32.png"            // optional
          },
          "default_title": "Google Mail",      // optional; shown in tooltip
          "default_popup": "popup.html"        // optional
        },
        ...
}
```

UI组成：都可以用`browserAction.*`API动态设置。
icon: `default_icon`, 可以静态图片还可以是canvas元素。大小默认使用适合设备的16像素。建议PNG格式。
tooltip: `default_title`, 标题提示信息。
badge: 动态显示在图标上的信息，4个字符以内。只能用API设置。
popup: `default_popup`, 弹出窗口页面。

### page action
是否激活取决于当前页面。

manifest: 和browser action一样。
UI组成：和browser一样，但没有badge。使用`pageAction.show`和`pageAction.hide`激活和禁用（灰色）。

## Files
一个扩展至少有一个manifest文件和一个HTML文件，以及其它脚本和资源文件。
crx发布: 将扩展目录打包成zip格式，并改后缀为crx。
文件引用：使用相对路径或`chrome-extension://<extensionID>/<pathToFile>`，可以用`@@extension_id`变量表示ID。

## Backgroud Pages
### 持久后台页面
生存周期和扩展一样，只要加载就一直存在，不可见只有一个实例。

manifest: 可以只有js（后台页面自动生成）
```
{
  "name": "My extension",
  ...
  "background": {
    "scripts": ["background.js"],   // or "page": "background.html"
  },
  ...
}
```

### 事件页面
按需自动加载，不用空闲时卸载释放资源。

manifest:
```
{
  "name": "My extension",
  ...
  "background": {
    "scripts": ["eventPage.js"],
    "persistent": false
  },
  ...
}
```

会触发加载的事件：

* 扩展刚安装和升级时
* 在监听一个事件（chrome会记住哪些扩展在监听哪些事件，不需要是加载状态，但重新加载时仍需要重新装上监听器以处理事件），事件触发时
* 一个content script或其它扩展发送一个消息时
* 扩展里的其它页面调用了`runtime.getBackgroundPage`

idle状态：

* 没有在调用API及发送网络请求
* 所有可视的view关闭
* 所有消息端口关闭

在idle状态持续几秒钟，会收到`runtime.onSuspend`事件，有几秒钟可以处理然后就会被强制卸载（如果触发加载事件则会终止卸载）。
当页面卸载时所有DOM定时器及HTML5的异步调用都会失效，可以使用chrome的alarms和notifications机制替代。
`runtime.getBackgroundPage`（异步）替代`extension.getBackgroundPage`（同步）可以保证加载页面后再返回。
[其它注意点](https://developer.chrome.com/extensions/event_pages#best-practices)


## Content scripts
注入当前已加载页面的script，和浏览页面共享DOM，而不是扩展的一部分（仅能够通过消息进行通信）。

不能使用除了以下的`chrome.*`API：

* extension ( getURL , inIncognitoContext , lastError , onRequest , sendRequest )
* i18n
* runtime ( connect , getManifest , getURL , id , onConnect , onMessage , sendMessage )
* storage

### 静态注入
manifest:
```
{
  "name": "My extension",
  ...
  "content_scripts": [
    {
      "matches": ["http://www.google.com/*"],
      "css": ["mystyles.css"],
      "js": ["jquery.js", "myscript.js"]
    }
  ],
  ...
}
```

* matches: 只对符合条件[pattern](https://developer.chrome.com/extensions/match_patterns)的URL进行注入
* exclude_matches: 排除的URL
* match_about_blank: 对about:blank 和 about:srcdoc页面注入，默认false
* css: 要注入的css
* js: 要注入的js
* all_frames: 对页面上所有frame注入，默认false
* include_globs: matches同时符合此通配的URL注入，使用通配符
* exclude_globs: exclude_matches同时排除此通配
* run_at: 注入的时机
 * document_start: 在加载css文件之后，在加载任何js之前，DOM构造之前
 * document_end": DOM完全构造之后，加载外部资源如图像和frame之前
 * document_idle: 默认，在document_end之后，window.onload事件（页面完整加载）发出后时间点之前（不保证收到onload事件）

### 动态注入
必须有对浏览页面的跨域权限，有使用chrome.tabs模块的权限。（一般直接使用`activeTab`权限）

manifest:
```
{
    ...
    "permissions": [
      "activeTab"
    ],
    ...
}
```
[activeTab](https://developer.chrome.com/extensions/activeTab): 只访问活动页面时代替`<all_urls>`，同时具有`tabs`权限。用`<all_urls>`有安全隐患。

使用tabs.executeScript和tabs.insertCSS进行注入:
```
chrome.browserAction.onClicked.addListener(function(tab) {
  chrome.tabs.executeScript({
    code: 'document.body.style.backgroundColor="red"'
  });
});
```
或从文件加载：`chrome.tabs.executeScript(null, {file: "content_script.js"});`

### 共享DOM
每个script在独立的隔离环境中运行，不能使用扩展的其他页面上，浏览页面上以及其他Content script里面定义的变量和函数。其他页面也不能使用这个script的变量和函数。
共享DOM是和浏览页面通信的唯一方式。
window对象也是共享的（比如可以改变location）。但不能通过在window对象中定义变量来直接互相通信。

content script:
```
var port = chrome.runtime.connect();

window.addEventListener("message", function(event) {
  // We only accept messages from ourselves
  if (event.source != window)
    return;

  if (event.data.type && (event.data.type == "FROM_PAGE")) {
    console.log("Content script received: " + event.data.text);
    port.postMessage(event.data.text); // 发送到扩展的其他页面
  }
}, false);
```

浏览的页面：
```
document.getElementById("theButton").addEventListener("click", function() {
  window.postMessage({ type: "FROM_PAGE", text: "Hello from the webpage!" }, "*");
}, false);
```

一种利用共享DOM直接互相访问变量的方法：
```
chrome.browserAction.onClicked.addListener(function(tab) {
  chrome.tabs.executeScript({
    code: 'var s = document.createElement("script"); s.src = chrome.extension.getURL("inject.js"); document.head.appendChild(s);'
    // 静态注入的话，code就是content_scripts里js的内容
  });
});
```
浏览页面不能直接访问扩展里面的资源，所以"inject.js"文件需要加入`manifest.web_accessible_resources`。（content_scripts本身不需要加入）
这样就真正变为浏览页面的脚本，但缺点是不能进行跨域访问了。


## 通信
一个扩展里的所有页面（backgroud.html, popup.html等）都可以互相引用，调用函数以及操作DOM。
`extension.getViews`获得所有活动页面的window对象，`extension.getBackgroundPage`获得后台页面的window对象。

## 跨域请求
扩展的所有页面以及content scripts都可以进行跨域请求。但必须用hosts或host match声明权限（activeTab不行），同时Content Security Policy没有禁止。

manifest:
```
{
  "name": "My extension",
  ...
  "permissions": [
    "http://www.google.com/"
  ],
  ...
}
```

和match pattern的不同：

* 忽略path
* http, https要分开单独声明
* 所有：`"http://*/"`


## Reference
https://developer.chrome.com/extensions
http://open.chrome.360.cn/extension_dev/overview.html
</xmp>
<script src="../js/strapdown.js"></script>
</html>
