<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<title>Kubernetes</title>
<xmp theme="united" style="display:none;">
https://kubernetes.io

## 安装部署
### kubeadm
#### 安装
所有 node 上执行。
```
apt-get update && apt-get install -y apt-transport-https
curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -
cat <<EOF >/etc/apt/sources.list.d/kubernetes.list
deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main
EOF
apt-get update
apt-get install -y kubelet kubeadm kubectl
```

最新稳定版：`https://dl.k8s.io/release/stable-1.txt` (v1.13.2)
镜像：`kubeadm config images list`
```
k8s.gcr.io/kube-apiserver:v1.13.2
k8s.gcr.io/kube-controller-manager:v1.13.2
k8s.gcr.io/kube-scheduler:v1.13.2
k8s.gcr.io/kube-proxy:v1.13.2
k8s.gcr.io/pause:3.1
k8s.gcr.io/etcd:3.2.24
k8s.gcr.io/coredns:1.2.6
```

手动拉镜像并重命名
```
#!/bin/bash
images=`kubeadm config images list`
for i in $images; do
	image=registry.cn-hangzhou.aliyuncs.com/google_containers/${i#k8s.gcr.io/}
	docker pull $image
	docker tag $image $i
done
```

#### init master
`kubeadm init --config config.yaml`
默认配置：`kubeadm config print init/join-defaults`
详细说明：https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta1

config.yaml
```
apiVersion: kubeadm.k8s.io/v1beta1
kind: InitConfiguration
localAPIEndpoint:
  advertiseAddress: 192.168.212.107
  bindPort: 6443
nodeRegistration:
  kubeletExtraArgs:
    dynamic-config-dir: /var/lib/kubelet/dynamic-config
---
apiVersion: kubeadm.k8s.io/v1beta1
kind: ClusterConfiguration
apiServer:
  extraArgs:
    enable-admission-plugins: NodeRestriction,ExtendedResourceToleration
networking:
  podSubnet: "10.100.0.0/16" # 需与 calico 配置一致，且不与 host 网络冲突
imageRepository: "registry.cn-hangzhou.aliyuncs.com/google_containers"
kubernetesVersion: "v1.13.2"
---
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
featureGates:
    DynamicKubeletConfig: true
```

网络插件
```
kubectl apply -f https://docs.projectcalico.org/v3.4/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml
```

#### join node
`kubeadm token create --print-join-command`
`kubeadm join <ip>:<port> --token <token> --discovery-token-ca-cert-hash <hash>`

#### 删除 node
```
kubectl drain <node name> --delete-local-data --force --ignore-daemonsets
kubectl delete node <node name>
kubeadm reset
```

reset iptable:
`iptables -F && iptables -t nat -F && iptables -t mangle -F && iptables -X`

#### 更新配置
组件：直接更新 `/etc/kubernetes/manifests` 配置
kubelet: 使用[configMap](https://kubernetes.io/docs/tasks/administer-cluster/reconfigure-kubelet/), 必须一开始加上 `--dynamic-config-dir` 和开启 `DynamicKubeletConfig` feature gate （默认true）。

#### 相关配置
`/etc/kubernetes/*.conf` 各组件访问 APIServer 鉴权文件。
`/etc/kubernetes/pki/` ca公钥私钥。
`/etc/kubernetes/manifests` 各组件静态 Pod。
`/var/lib/kubelet/kubeadm-flags.env` kubeadm 为 kubelet 设置的 `KUBELET_EXTRA_ARGS`。
`/var/lib/kubelet/config.yaml` kubelet 本地 configMap 配置文件。
`/etc/default/kubelet` kubelet `KUBELET_EXTRA_ARGS=` 配置。
`/etc/systemd/system/kubelet.service.d/10-kubeadm.conf` kubelet systemd 配置，启动命令行。

### 其它插件
[nvidia-device-plugin](https://github.com/NVIDIA/k8s-device-plugin)
`kubectl apply -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v1.11/nvidia-device-plugin.yml`

[dashboard](https://github.com/kubernetes/dashboard)
`kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml`

[rook](https://github.com/rook/rook)
```
kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/operator.yaml
kubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/cluster.yaml
```

[kube-prometheus](https://github.com/coreos/prometheus-operator/tree/master/contrib/kube-prometheus)

[logging](https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/fluentd-elasticsearch)

### Tips
kubelet alias 自动补全(Linux)：
`source <(kubectl completion bash | sed 's/kubectl/kc/g')`

### 验证
#### [Node Conformance Test](https://kubernetes.io/docs/setup/node-conformance/)
在 node 加入集群之前验证。
run: `test/e2e_node/conformance/run_test.sh`

#### Cluster
validate cluster: `KUBECTL_PATH=$(which kubectl) NUM_NODES=1 KUBERNETES_PROVIDER=local cluster/validate-cluster.sh`

#### 其他
https://github.com/heptio/sonobuoy
https://github.com/bloomberg/powerfulseal

## Networking
Networking Model:

* all containers can communicate with all other containers without NAT
* all nodes can communicate with all containers (and vice-versa) without NAT
* the IP that a container sees itself as is the same IP that others see it as

### 网络方案
#### Overlay (UDP/VXLAN)
[![img](https://cdn-images-1.medium.com/max/1600/1*JqSLd3cPv14BWDtE7YEcRA.png)](https://blog.laputa.io/kubernetes-flannel-networking-6a1cb1f8ec7c)
代表：[flannel](https://github.com/coreos/flannel)

#### Routing (Host-GW)
![img](https://feisky.gitbooks.io/sdn/container/calico/calico.png)
代表：[calico](https://www.projectcalico.org/)

### [CNI](https://github.com/containernetworking/cni)
[spec](https://github.com/containernetworking/cni/blob/master/SPEC.md) / [k8s cni](https://github.com/kubernetes/community/blob/master/contributors/devel/kubelet-cri-networking.md)

功能：

* 在容器网络命名空间中配置网络接口。
* 在host上配置网络。
* 给容器中的网络接口分配IP地址以及路由。

[标准基础插件](https://github.com/containernetworking/plugins)：

* main: 创建网络设备
* IPAM: IP地址分配
* meta: 其他(内置flannel)

plugin位置：`/opt/cni/bin`
配置(Network Configuration Lists)：`/opt/cni/net.d` 只会加载按字母顺序第一个，如 `10-flannel.conflist`

执行环境：由 CRI (如dockershim) 调用: [`RunPodSandbox` -> `SetUpPod`](https://github.com/kubernetes/kubernetes/blob/4dc40aabfb9af68913986a2caf87906312c9f4ea/pkg/kubelet/dockershim/docker_sandbox.go#L177)

执行参数：

* 环境变量：`CNI_*`
  * `CNI_COMMAND`: `ADD`/`DEL`/`CHECK`/`VERSION`
  * `CNI_CONTAINERID`: 容器ID
  * `CNI_NETNS`: 网络命名空间路径, `/proc/<container_pid>/ns/net`
  * `CNI_IFNAME`: 容器内网络接口名字
  * `CNI_ARGS`: KV形式的自定义参数
  * `CNI_PATH`: plugin搜索路径
* stdin: `Network Configuration` 调用中可能会被修改
```
{
    "cniVersion": "0.4.0",
    "name": "dbnet",
    "type": "bridge",
    // type (plugin) specific
    "bridge": "cni0",
    "ipam": {
      "type": "host-local",
      // ipam specific
      "subnet": "10.1.0.0/16",
      "gateway": "10.1.0.1"
    },
    "dns": {
      "nameservers": [ "10.1.0.1" ]
    }
}
```
`delegate` 字段（内容和 `Network Configuration` 相同）可以用于委派其他插件完成。

执行结果(`ADD`)：

* result code: 1/2/3/11
* stdout: `Result` (`IPAM`的结果没有interfaces)
```
{
    "cniVersion": "0.4.0",
    "interfaces": [...],
    "ips": [...],
    "routes": [...],
    "dns": [...]
}
```
失败结果：
```
{
    "cniVersion": "0.4.0",
    "code": <numeric-error-code>,
    "msg": <short-error-message>,
    "details": <long-error-message> (optional)
}
```

整体List执行：
`ADD`按照`Network Configuration Lists`配置的plugins顺序执行，`DEL`反序执行。
```
{
    "cniVersion": "0.4.0",
    "name": "...",
    "disableCheck": false,
    "plugins": [<Network Configuration>, ...]
}
```

对于 `ADD`, 把结果 `Result` 作为`Network Configuration` 的一个新增字段 `prevResult` 传给下一个plugin。后面的 plugin 除非需要修改或覆盖结果，都应该把收到的 `prevResult` 原样输出给下一个。
如果 `ADD` 中有一个 plugin 失败，执行 `DEL` (全部 plugins) 作为错误处理。
`DEL` 输入也包含最近 `ADD` 的 `Result` 作为 `prevResult`。

## Storage
### [CSI](https://kubernetes-csi.github.io/)
[spec](https://github.com/container-storage-interface/spec/blob/master/spec.md) / [k8s csi](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md)

[![img](https://cdn-images-1.medium.com/max/1000/1*oMgMPjx0obXKlaItZOkRfA.png)](https://medium.com/google-cloud/understanding-the-container-storage-interface-csi-ddbeb966a3b)

external components (从 kubelet 剥离，由 k8s 维护):

* [node driver registrar](https://github.com/kubernetes-csi/node-driver-registrar): 向 kubelet 注册 CSI 驱动。安装驱动可执行文件。以及健康检测。
* [cluster driver registrar](https://github.com/kubernetes-csi/cluster-driver-registrar): 为驱动创建 `CSIDriver` 对象。（非必要）
* [external provisioner](https://github.com/kubernetes-csi/external-provisioner)：监听 `PersistentVolumeClaim` 对象，触发 CSI 端点的 `CreateVolume/DeleteVolume` 方法。
* [external attacher](https://github.com/kubernetes-csi/external-attacher): 监听 `VolumeAttachment` 对象，触发 CSI 端点的 `ControllerPublish/Unpublish` 方法。

csi driver / plugin （第三方提供）：

* CSI Identity: 提供驱动的标识和基本信息。
* CSI Controller: 提供卷的基本服务：创建，删除，attach/dettach (publish/unpublish，指将设备挂到node上，一般只有块存储需要), snapshoting 等。（volume contoller逻辑，不需要在node上操作，部署在master节点上）
* CSI Node: 在node上执行的具体操作（由 kubelet 直接调用），如格式化以及 mount/unmount 存储路径到 pod volume 的 mount point 上。

## Runtime
### [CRI](https://github.com/kubernetes/community/blob/master/contributors/devel/container-runtime-interface.md)

## Components
### [Scheduler](https://github.com/kubernetes/community/blob/master/contributors/devel/scheduler.md)
### [Controller](https://github.com/kubernetes/community/blob/master/contributors/devel/controllers.md)
### [Device Plugin](https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md)

## Utilities
### Leader Election
[![img](https://cdn-images-1.medium.com/max/1600/0*1bwwLXjQrLWL67RQ&resize=w1280)](https://medium.com/@dominik.tornow/kubernetes-high-availability-d2c9cbbdd864)

`k8s.io/client-go/tools/leaderelection`

配置：

* `LeaseDuration` 租期
* `RenewDeadline` 续租间隔

`tryAcquireOrRenew` 获得锁的条件（或）：

* 锁资源还没创建，创建并声明获得
* Leader Lease 过期了 （本地当前时间已经超过了最后一次在本地观察到 record 变化（即刷新过）的时间+本地配置的租期）
* 现 Leader 就是自己

一般用 `endpoint`/`configmap` 表示资源锁对象：
相关信息 `LeaderElectionRecord`（只有`HolderIdentity`被用来判断自己是否是 leader，其他都是记录信息） 存在 `control-plane.alpha.kubernetes.io/leader` annotation 里面。

```
type LeaderElectionRecord struct {
	HolderIdentity       string      `json:"holderIdentity"`       // hostname + uuid
	LeaseDurationSeconds int         `json:"leaseDurationSeconds"` // 租期
	AcquireTime          metav1.Time `json:"acquireTime"`          // 获取时间
	RenewTime            metav1.Time `json:"renewTime"`            // 刷新时间
	LeaderTransitions    int         `json:"leaderTransitions"`    // 转换次数
}
```

不能保证只有一个 leader (fencing) , 如果出现2个(split brain)，由 controller 自己靠调谐 (reconciliation) 来解决冲突。
可以容忍绝对时钟偏移值（因为计算都用的本地单调时钟），但会受到时钟偏移率的影响。

</xmp>
<script src="../js/strapdown.js"></script>
</html>
