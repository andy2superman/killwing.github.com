<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<title>KV</title>
<xmp theme="united" style="display:none;">
## LSM-Tree
[Log Structured Merge Tree](http://paperhub.s3.amazonaws.com/18e91eb4db2114a06ea614f0384f2784.pdf)
不可变结构的优点：
不用预分配空间，减少存储开销
读取时不用加锁，提高并发读性能
顺序写，效率高，碎片少 single pass, append-only

定期合并重写，减少文件总数量，以减少查询时需要的文件数量
因为不可变，插入更新删除都需要重写整个文件

### SSTable
LSM-Tree的一种实现：[Sorted String Table](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf) 是一种持久化的，有序的，不可变的 map 结构，kv 都是 byte string。

结构：
index block: `{key:offset}`，在内存中，可以用搜索树（B-Tree, [skiplist](https://www.epaperpress.com/sortsearch/download/skiplist.pdf)）实现，offset 指向 data block 中的数据偏移。
data block: `{key:value}`，持久化不变结构，kv 记录一个接一个依次相接。

特性：
每个SSTable key有序且key range不重合
每个item都有一个timestamp，如插入时间，更新时间，删除时间
删就是加一个placeholder记录并标记为删除，改就是一个新的timestamp的记录 (shadowing)

操作：
写：直接写内存(内存里对应一个可变的搜索树结构MemTable)，当树大小（或定时）超过阈值，就写磁盘为一个新的SSTable (flush)。同时写WAL。
读：根据索引搜索所有磁盘上的SSTable, 同时检查内存里的MemTable，然后合并结果。
压缩(housekeeping)：为提高读性能，减少冗余记录，对所有SSTable做类似归并排序的合并操作（和读取时合并相同），并重构索引。（可以将同样大小的SSTable归为一个level，当这个level的table数量达到阈值时压缩）

优化：

* 为写优化，读相对慢
* 为顺序读写优化:
  * 从某一点读取范围是顺序读
  * 所有的写操作都是顺序写：同步MemTable，合并压缩，WAL

例子：
[LevelDB](https://github.com/golang/leveldb), RocksDB, Cassandra, [badger](https://github.com/dgraph-io/badger)

## B-Tree

例子：BoltDB

## WAL
Write-Ahead Log: 保证可靠性，在改变数据文件之前追加写操作日志。
重放WAL以恢复状态，这样就不用每次操作都要将数据文件sync到磁盘。
WAL一般写在和数据文件不同的磁盘上。

## Bitcask

</xmp>
<script src="../js/strapdown.js"></script>
</html>
