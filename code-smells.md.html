<!DOCTYPE html>
<html>
<title>Code Smells</title>
<xmp theme="readable" style="display:none;">
> If it stinks, change it.
> - Grandma Beck, discussing child-rearing philosophy

[重构: 改善既有代码的设计](http://book.douban.com/subject/4262627/)
[重构与模式](http://book.douban.com/subject/1917706/)

## 异曲同工的类 Alternative Classes with Different Interfaces
指两个相似类却有不同接口的时候。如果发现两个类很相似，通常可以将它们重构为共享一个公共的接口。

* 通过Adaptor统一接口
* 重命名方法
* 移动方法

## 组合爆炸 Combinatorial Explosion
是一种不那么明显的重复。当有许多段代码使用不同种类或数量的数据或对象做同样的事情的时候。

* 用Interpreter替换隐式语言

## 过多的注释 Comments (a.k.a. Deodorant)
当你感觉要撰写注释时，请先尝试重构，试着让所有注释都变得多余（因为代码已经清楚地说明了一切）。

* 重命名方法
* 提取方法
* 引入断言

## 条件逻辑过复杂 Conditional Complexity
如果条件逻辑很容易理解，而且只包含几行代码，那么其本身是无辜的。不幸的是，它很少能够这样善始善终。例如，实现几个新功能后，条件逻辑就突然变得复杂而又开销高昂。

* 用Strategy替换条件逻辑
* 将装饰功能搬移到Decorator
* 用State替换状态改变条件语句
* 引入Null Object

## 纯粹的数据类 Data Class
它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过份细琐地操控着。

* 移动方法
* 封装数据成员
* 封装集合

## 数据泥团 Data Clumps
总是绑在一起出现的数据真应该拥有属于它们自己的对象。一个好的评判方法是：删掉众多数据中的一项，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新对象。

* 提取类
* 保持整个对象
* 引入参数对象

## 发散式变化 Divergent Change
发生在某个类经常因为不同的原因在不同的方向上发生变化的时候。针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应此变化。

* 提取类

## 重复代码 Duplicated Code
重复代码是软件中最司空见惯、最刺鼻的坏味。它可能很明显，也可能微妙难寻。完全相同的代码中当然存在明显的重复，而微妙的重复会出现在表面不同但是本质相同的结构或处理步骤中。

* 形成Template Method
* 用Factory Method引入多态创建
* 链构造函数
* 用Composite替换一/多之分
* 提取Composite
* 通过Adapter统一接口
* 引入Null Object
* 提取方法/类
* 上移方法/成员
* 替换算法

## 依恋情节 Feature Envy
函数对某个类的兴趣高过对自己所处类的兴趣。某个函数为了计算某个值，从另一个对象那调用几乎半打的取值函数。

* 提取方法
* 移动类
* 移动数据成员

## 冗赘类 Freeloader (a.k.a. Lazy Class)
类如果功能有限，缺乏存在价值，就应该删除。

* 内联Singleton
* 内联类
* 压缩继承关系

## 狎昵关系 Inappropriate Intimacy
有时你会看到两个类过于亲密，花费太多时间去探究彼此的private成分。过分亲密的类必需拆散，希望它们严守清规。

* 移动方法
* 移动数据成员
* 把双向联系变成单向联系
* 提取类
* 隐藏委托
* 用委托替换继承

## 不完美的库类 Incomplete Library Class
库往往构造得不够好，而且往往不可能让我们修改其中的类使它完成我们希望完成的工作。

* 引入外部方法
* 引入本地扩展

## 不恰当的暴露 Indecent Exposure
缺乏信息隐藏。在客户代码不应该看到的方法或者类，却对客户公开可见时，就会出现这种坏味。这种代码的暴露意味着客户了解到不太重要或者只有间接重要性的代码。这会增加代码的复杂程度。

* 用Factory封装类

## 类过大 Large Class
存在太多的实例变量，往往说明类的职责太多。一般而言，过大的类通常包含过多的职责。

* 用Command替换条件调度程序
* 用State替换状态改变条件语句
* 用Interpreter替换隐式语言
* 提取类/子类/接口
* 用对象替换数值

## 方法过长 Long Method
逻辑共享：两个很长的方法很可能包含重复代码。如果将这些方法分解为多个小方法，就能发现通常有很多方式能够使它们共享逻辑。
帮助理解代码：如果对一段代码的意图不太理解，可以将它提炼为小的、命名准确的方法，这样再理解原来的代码将更容易。包含大量小方法的系统更容易扩展和维护，因为它们更容易理解，重复更少。

* 组合方法
* 将聚集操作搬移到Collecting Parameter
* 用Command替换条件调度程序
* 将聚集操作搬移到Visitor
* 用Strategy替换条件逻辑
* 提取方法
* 引入参数对象
* 分解条件
* 保持整个对象
* 用方法对象替换方法
* 用查询替换临时对象

## 过长参数列 Long Parameter List
太长的参数列难以理解，太多的参数会造成前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给函数，大多数修改都将没有必要，因为你很可能只需增加一两条请求，就能得到更多数据。

* 用显式方法替换参数
* 引入参数对象
* 保持整个对象

## 过度耦合的消息链 Message Chains
如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象...这就是消息链。意味客户代码将与查找过程中的导航紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。

* 隐藏委托
* 提取方法
* 移动方法

## 中间人 Middle Man
封装往往伴随着委托，但可能过度运用委托。某个类接口有一半的函数都委托给其他类就是过度运用。

* 移除委托
* 内联方法
* 用继承替换委托

## 怪异解决方案 Oddball Solution
在系统中应该始终用一种方式解决一种问题，如果在同一系统中使用不同方式解决同一问题，就称之为怪异或不一致的解决方案。这往往说明存在不易察觉的重复代码。

* 通过Adapter统一接口

## 平行继承体系 Parallel Inheritance Hierarchies
是Shotgun Surgery的一种特殊情况，每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。

* 移动方法
* 移动数据成员

## 基本类型迷恋 Primitive Obsession
基本类型，包括整数、字符串、双整型、数组和其他低层次的语言要素，都具有一般性，因为许多人都要使用它们。但是，类可能需要是非常特定的，因为创建它们往往就是要用于特定的目的。许多情况下，类在建模各种事物方面能够提供比基本类型更简单且更自然的方式。而且，创建一个类之后，经常会发现系统中的其他代码 也应该属于这个类。
基本类型迷恋在代码过于依赖基本类型时会自我暴露出来，这通常出现在没有看到如何用更高层的抽象澄清或者简化代码的时候。

* 用类替换类型代码
* 用State替换状态改变条件语句
* 用Strategy替换条件逻辑
* 用Composite替换隐含树
* 用Interpreter替换隐式语言
* 将装饰功能搬移到Decorator
* 用Builder封装Composite
* 用对象替换数值
* 引入参数对象
* 提取类
* 用State/Strategy/Subclass替换类型代码
* 用对象替换数组

## 被拒绝的遗赠 Refused Bequest
子类应该继承超类的函数和数据。但如果它们不想或不需要继承，这就意味着继承体系设计错误。

* 下移方法
* 下移数据成员
* 用委托替换继承

## 霰弹式修改 Shotgun Surgery
如果每遇到某种变化，你都必须再需许多不同的类内做出许多小修改。如果需要修改的代码散步四处，你不但很难找到它们，也很容易忘记某个重要的修改。

* 移动方法
* 移动类
* 内联类

## 解决方案蔓延 Solution Sprawl
如果许多类中都有用来完成某些职责的代码和/或数据，我们就说存在解决方案蔓延坏味。这种坏味通常是由于在系统中快速添加特性，却没有花费足够时间来简化和改进设计以适应新特性而造成的。

* 将创建知识搬移到Factory

## 夸夸其谈未来性 Speculative Generality
企图以各式各样的钩子和特殊情况来处理一些非必要的事情。结果往往造成系统更加难理解和维护。如果所有装置都会被用到，那就值得那么做；如果用不到，就不值得。

* 压缩继承
* 重命名方法
* 移除参数
* 内联类

## 分支语句 Switch Statement
switch语句（或者if...elseif...elseif...结构的等效语句）本身并没有问题。只有在使用这种语句会使设计过度地复杂或者僵硬时，它们才会成为问题。这时，最好将分支语句去除，重构为更基于对象或者多态的解决方案。

* 用Command替换条件调度程序
* 将聚集操作搬移到Visitor
* 用多态替换条件
* 用State/Strategy/Subclass替换类型代码
* 用显式方法替换参数
* 引入Null Object

## 令人迷惑的临时字段 Temporary Field
其内某个实例变量仅为某种特定情况而设。

* 提取类
* 引入Null Object
</xmp>
<script src="js/strapdown.js"></script>
</html>
