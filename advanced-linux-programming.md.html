<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<title>Advanced Linux Programming</title>
<xmp theme="readable" style="display:none;">
http://www.advancedlinuxprogramming.com/
http://sourceforge.net/apps/trac/elpi/wiki/ALP

## 1.起步


## 2.编写优质GNU/Linux软件
### 2.1 与运行环境交互
* 使用getopt_long处理命令行参数。
* 文件描述符0代表标准输入，1为标准输出而2为标准错误。
* stdout 是经过缓冲处理的，stderr 没有经过缓冲处理；输出到 stderr 的数据会直接被发送到终端。
* 返回0表示正常，而非0表示错误的出现。可以通过特殊环境变量$?得到最近执行的一个程序的退出代码。
* setenv 和 unsetenv 函数则分别可用于设置和清除环境变量。
* 使用 mkstemp，tmpfile操作临时文件。

### 2.2 防御性编码
* Linux 会在程序退出的时候清理分配的内存、打开的文件和其它绝大多数资源，因此不必在调用 exit 之前释放缓冲区并关闭文件。不过如临时文件和共享内存等——这些资源在进程结束后仍然存在。

### 2.3 编写并使用程序库
* 要创建一个共享库，您必须在编译那些用于生成共享库的对象时为编译器指定 -fPIC 选项。位置无关代码（Position-Independent Code） 共享库中的函数在不同程序中可能被加载在不同的地址，因此共享库中的代码不能依赖特定的加载地址（或位置）。
* 对于同名的静态库和共享库，链接器会依次搜索每个文件夹（首先搜索 -L选项指定的路径，然后是系统默认搜索路径）。不论链接器发现了哪一个，它都会停止搜索过程。如果当时只找到了两者中的一个，链接器会选择找到的那个进行链接。如果两个版本同时存在，除非您明确指定链接静态版本，链接器会选择共享库版本进行链接。
* 可以用 ldd 命令显示与一个程序建立了动态链接的库的列表。
* 当程序运行时，系统会搜索 /lib 和 /usr/lib 并加载这个共享库。如果某个链接到程序中的共享库在别的目录，必须在链接的时候指明 -Wl,-rpath 参数，或者使用LD_LIBRARY_PATH环境变量。
* 两个库可能互相依赖，通常这种情况都是由于不良设计导致的。在这种情况下，可以在命令行中多次指定同一个库。链接器会在每次读取到这个库的时候重新查找库中的符号。


## 3.进程
### 3.1 查看进程
* 每个进程都有一个父进程，init进程是树的“根”。
* 使用`<sys/types.h>`中定义的pid_t类型，可以通过getpid()系统调用获取自身所运行的进程的ID，也可以通过`getppid()`系统调用获取父进程ID。

### 3.2 创建进程
* system 函数提供了一种调用其它程序的方法，它建立了一个运行着标准 Bourne shell（/bin/sh）的子进程，然后将命令交由它执行，所以它受到系统 shell 自身的功能特性和安全缺陷的限制。
* fork 函数创建一个调用进程的精确拷贝。exec 族函数，使一个进程由运行一个程序的实例转换到运行另外一个程序的实例。要产生一个新进程，应首先用 fork 创建一个当前进程的副本，然后使用 exec 将其中一个进程转为运行新的程序。
* 一个进程通过调用 fork 会创建一个被称为子进程的副本进程。父进程从调用 fork 的地方继续执行；子进程也一样。父进程得到的 fork 调用返回值是子进程的 ID，子进程得到的返回值是0（任何进程的 ID 均不为0）。
* exec 族函数用一个程序替换当前进程中正在运行的程序。当某个 exec 族的函数被调用时，如果没有出现错误的话，调用程序会被立刻中止，而新的程序则从头开始运行。
* nice/renice 命令或函数调整进程调度的优先级，默认每个进程的 niceness 均为 0（较高的值代表了较低的进程优先级）。

### 3.3 信号
* 信号机制是异步的；当一个进程接收到一个信号时，它会立刻处理这个信号，而不会等待当前函数甚至当前一行代码结束运行。
* 如果指定了一个信号处理函数，当前程序会暂停当前的执行过程，同时开始执行信号处理函数，并且当信号处理函数返回之后再从被暂停处继续执行。
* Linux 系统在运行中出现特殊状况的时候也会向进程发送信号通知。如当一个进程执行非法操作的时候可能会收到SIGBUS（主线错误），SIGSEGV（段溢出错误）及 SIGFPE（浮点异常）这些信号，默认处理方式是终止程序并且产生一个核心转储文件（core file）。
* 应该尽量避免在信号处理函数中使用输入输出功能、绝大多数库函数和系统调用。
* 如果需要从信号处理函数中设置全局标志，这个标志必须是特殊类型sig_atomic_t的实例（原子操作）。

### 3.4 进程终止
* 当用户在终端按下 Ctrl+C 时会发送一个 SIGINT 信号给进程。SIGTERM 信号由 kill 命令发送。abort 函数给自己发送一个 SIGABRT 信号。SIGKILL信号会导致进程立刻终止，而且这个信号无法被阻止或被程序自主处理。
* 大于128的退出代码有特殊的含义——当一个进程由于一个信号而结束运行，它的退出值就是128加上信号的值。
* wait系统调用会阻塞调用进程，直到某一个子进程退出（或者出现一个错误）。wait3 函数可以获取退出进程的CPU占用情况，而 wait4 函数允许通过更多参数指定等待的进程。
* 子进程死亡的时候会转化为一个僵尸进程（已经中止而没有被清理的进程）。清理僵尸子进程是父进程的责任，wait 函数会负责这个清理过程（僵尸子进程的结束状态被提取出来，子进程被删除，并且 wait 函数立刻返回）。
* 当一个程序退出而没有wait，它的僵尸子进程就被一个特殊的init进程继承。Init 进程总以进程ID 1运行（Linux 启动后运行的第一个进程），会自动清理所有它继承的僵尸进程。
* 当一个子进程结束的时候，Linux 给父进程发送 SIGCHLD 信号（可以让父进程来调用wait清理）。


## 4.线程
### 4.1 创建线程
* pthread_create创建 / pthread_exit结束 / pthread_join等待 / pthread_self本线程ID
* pthread_attr_t属性 / pthread_attr_init初始化 / pthread_attr_destroy销毁
* pthread_attr_setdetachstate(PTHREADCREATEDETACHED) 创建可脱离线程（在结束的时候会被自动清理，其它线程无法与它的结束事件进行同步，也无法获取其返回值）。
* 一个可等待线程(默认)，也可以随后调用 pthread_detach 转换成一个脱离线程（无法转回去）。

### 4.2 取消线程
* 调用pthread_cancel 一个线程可以请求另外一个线程中止，应该对一个被取消的线程执行pthread_wait以释放它占用的资源，除非这个线程是脱离线程。一个取消线程的返回值由特殊值PTHREAD_CANCELED指定。
* pthread_setcanceltype 设置取消类型：
    * PTHREAD_CANCEL_ASYNCHRONOUS: 线程可以在执行中的任意时刻被取消。
    * PTHREAD_CANCEL_DEFERRED(默认): 取消请求会被排队，而线程只有在到达特殊的执行点才会执行取消操作。创建一个取消点的方法是调用pthread_testcancel。
* pthread_setcancelstate 设置取消状态：
    * PTHREAD_CANCEL_ENABLE
    * PTHREAD_CANCEL_DISABLE: 尝试取消线程的请求会被直接忽略。

### 4.3 线程专有数据
* 系统为每个线程提供一个线程专有数据区（thread-specific data area）。当数据被存放在这个区域时会自动为每个线程创建一个副本。
* pthread_key_create创建 / pthread_setspecific设置 / pthread_getspecific 获取
* pthread_cleanup_push / pthread_cleanup_pop 清理句柄是一个临时性的工具，只在当线程被取消或中途退出而不是正常结束运行的时候被自动调用。
* 如果一个线程运行中调用了 pthread_exit，C++并不能保证线程的栈上所有自动对象的析构函数将被调用。

### 4.4 同步和临界代码段
* Mutex:
    * pthread_mutex_t类型 /pthread_mutex_init初始化 /PTHREAD_MUTEX_INITIALIZER初始化对象 /pthread_mutex_lock锁 /pthread_mutex_unlock解锁 /pthread_mutexattr_t属性 /pthread_mutex_trylock尝试
    * 默认是fast mutex，递归锁要设置属性PTHREAD_MUTEX_RECURSIVE_NP（锁住后要解锁相应的次数才能解）。
* Semaphore
    * sem_t类型 /sem_init初始化 /sem_destroy销毁 /sem_wait减信号 /sem_trywait尝试 /sem_post加信号
    * 每一次调用wait将会使semaphore值减一，而如果semaphore值已经为0，则wait操作将会阻塞。每一次调用post将会使semaphore值加一（注意和递归mutex不一样，不同线程共享一个sem计数器）。
* Condition
    * pthread_cond_t类型 /pthread_cond_init初始化 /pthread_cond_signal发信号 /pthread_cond_broadcast发所有信号 /pthread_cond_wait等待
    * 一个线程等待一个条件变量，需要等另一个线程发信号才能解除。
    * wait时必须和一个已锁住的mutex联用，锁住condition的同时帮mutex解锁，当收到信号而解锁condition时自动再锁住mutex，以避免竞态。
    * 信号会记住加锁解锁的次数，而条件则看当前的状态是否在等待；信号只能唤醒一个线程，而条件可以唤醒多个线程。
* 死锁解决：对于多个资源需要加多个锁，按同样的顺序加锁。

### 4.5 GNU/Linux 线程实现
* GNU/Linux平台上的POSIX线程实现与其它许多类UNIX操作系统上的实现有所不同：在 GNU/Linux 系统中，线程就是用进程实现的。每创建一个新线程的时候，创建一个新进程运行这个线程的代码。新进程与父进程共享地址空间和资源，而不是分别获得一份拷贝。
* 一个线程调用函数 pthread_kill 可以给另一个特定线程发送信号。
* 实现：clone系统调用。**2.6内核已使用NPLT线程模型代替原来的LinuxThreads，各线程共享同一个pid）**

### 4.6 进程 VS 线程
* 一个程序的所有线程都必须运行同一个执行文件。而一个新进程则可以通过 exec 函数运行一个新的执行文件。
* 由于所有线程共享地址空间和资源，一个错误的线程可能影响所有其它线程。而进程不会，因为每个进程都有父进程的地址空间的完整副本。
* 为新进程复制内存会比创建新线程存在性能方面的损失。只有当对内存进行写入操作的时候复制操作才会发生，读取操作的性能损失微乎其微。
* 对于需要精细并行控制的程序，线程是更好的选择。进程适合只需要比较粗糙的并行程序。
* 由于线程之间共享地址空间，容易共享数据。进程之间共享要求使用各种IPC机制，虽然麻烦而笨重，但同时避免了许多并行错误的出现。


## 5.进程间通信(IPC)
### 5.1 共享内存
* 共享内存在各种进程间通信方式中具有最高的效率，不需要通过系统调用或者其它需要切入内核的过程来完成。但是内核没有对访问共享内存进行同步。
* 要使用一块共享内存，一个进程必须首先分配它。随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块。
* 创建: shmget，返回SHMID。
    * 第一个参数是一个用来标识共享内存块的键值，用特殊常量IPC_PRIVATE作为键值可以保证系统建立一个全新的共享内存块。
    * 第二个参数指定了所申请的内存块的大小，实际分配的内存块大小将被扩大到页面大小的整数倍（Linux中内存页面大小是4KB，getpagesize）。
    * 第三个参数是一组标志: IPC_CREAT(创建一个新的共享内存块), IPC_EXCL(只能与IPC_CREAT同时使用, 如果已有一个这个键值的共享内存块存在，则shmget会调用失败，否则返回这个共享内存块), 模式标志(表示属主、属组和其它用户对该内存块的访问权限)。
* 绑定: shmat，返回绑定的共享内存块对应的地址。
    * 第一个参数SHMID。
    * 第二个参数是一个指针，指向希望用于映射该共享内存块的进程内存地址；如果指定NULL则会自动选择一个合适的地址用于映射。
    * 第三个参数是一个标志位: SHM_RND表示第二个参数指定的地址应被向下靠拢到内存页面大小的整数倍（如果不指定这个标志，则需要在调用shmat的时候手工将共享内存块的大小按页面大小对齐）。SHM_RDONLY表示这个内存块只读。
    * 通过 fork 函数创建的子进程同时继承这些共享内存块。
* 脱离: shmdt
    * 将由shmat函数返回的地址传递给这个函数。
    * 对exit或任何exec族函数的调用都会自动使进程脱离共享内存块。
* 控制: shmctl，返回一个共享内存块的相关信息。
    * 第一个参数SHMID。
    * 要获取一个共享内存块的相关信息，则为该函数传递 IPC_STAT 作为第二个参数，同时传递一个指向一个 struct shmid_ds 对象的指针作为第三个参数。
    * 要删除一个共享内存块，则应将 IPC_RMID 作为第二个参数，而将 NULL 作为第三个参数。当最后一个绑定该共享内存块的进程与其脱离时，该共享内存块将被删除。
    * 系统所允许的共享内存块的总数有限制。
* 相关命令
    * ipcs -m 获取有关共享内存的信息。
    * ipcrm shm {shmid} 删除共享内存（如果在程序结束后没有被释放而是被错误地保留下来）。

### 5.2 进程信号量(SystemV信号量)
* 信号量会一直保存在系统中，所有使用它们的进程都退出后也不会自动被销毁。最后一个使用信号量的进程必须明确地删除所使用的信号量组。与共享内存不同，删除一个信号量组会导致 Linux 立即释放资源。
* 创建: semget, 返回信号量组标识符
    * 参数: 用于标识信号量组的键值，该组中包含的信号量数量，与 shmget 所需的相同的权限位标识。
* 控制:  semctl
    * 参数: 信号量组的标识符，组中包含的信号量数量、常量 IPC_RMID 和一个 union semun 类型的任意值（被忽略）。
    * 初始化: 以 0 为第二参数，以 SETALL 为第三个参数调用 semctl 可以对一个信号量组进行初始化。
* 等待和投递: semop
    * 参数: 信号量的标识符，一个包含 struct sembuf 类型元素的数组(希望执行的操作)，数组的长度。
    * sembuf的sem_op指定加减的信号数量，如果操作使信号量的值小于零，则会导致进程阻塞。
    * sembuf的符号位指定 IPC_NOWAIT 以防止操作阻塞；如果该操作本应阻塞，则semop调用会失败。指定SEM_UNDO，则会在进程退出的时候自动撤销该次操作。
* 相关命令
    * ipcs -s 查看
    * ipcrm sem {semid} 删除

### 5.3 映射内存
* 映射内存既可以用于进程间通信，也可以作为一种访问文件内容的简单方法。还可以映射 /dev/zero 以获取整块经过初始化的内存。
* 映射内存在一个文件和一块进程地址空间之间建立了联系，将文件分割成内存分页大小的块并复制到虚拟内存中，因此进程可以在自己的地址空间中直接访问或修改文件内容。
* 映射: mmap, 返回一个指向被映射内存区域的起点的指针，失败则返回常量 MAP_FAILED。
    * 第一个参数指明了您希望Linux将文件映射在进程地址空间中的位置；传递NULL指针允许Linux系统自动选择起始地址。
    * 第二个参数是映射内存块的长度，以字节为单位。
    * 第三个参数指定了对被映射内存区域的保护，由 PROT_READ、PROT_WRITE 和 PROT_EXEC 三个标志位按位与操作得到。
    * 第四个参数是一个用于指明额外选项的标志值。
        * MAP_FIXED: 强制使用提供的地址进行映射，而不只是将该地址作为一个对映射地址的参考进行选择。该地址必须按内存分页边界对齐。
        * MAP_PRIVATE: 对映射区域内存的写操作不会直接导致对被绑定文件的修改，而是修改该进程持有的一份该文件的私有副本(写时复制，随后执行的所有读写操作都针对这个副本进行)。其它进程即使映射了同一个文件也不会看到这些变化。
        * MAP_SHARED: 对内存的写入操作会立刻反应在被映射的文件中，而不会被系统缓冲。将映射内存作为一种 IPC 手段时应使用这个标志。
    * 第五个参数应传递一个已经打开的、指向被映射文件的句柄。
    * 最后一个参数指明了文件中被映射区域相对于文件开始位置的偏移量。
* 释放: munmap
    * 参数：被映射内存区域的开始地址和内存块的长度。
    * 进程结束的时候会自动释放进程中映射的内存区域。
* 同步: msync
    * 前两个参数与 munmap 相同，用于指明一个映射内存块。
    * 第三个参数:
        * MS_ASYNC: 计划一次更新，但是这次更新未必在调用返回之前完成。
        * MS_SYNC: 立刻执行更新。
        * MS_INVALIDATE: 使映射的页高速缓存中的内容无效，重新从磁盘写入数据到映射的页高速缓存。

### 5.4 管道
* 管道的数据容量是有限的。如果写入的进程写入数据的速度比读取进程消耗数据的速度更快，且管道无法容纳更多数据的时候，写入端的进程将被阻塞，直到管道中出现更多的空间为止。换言之，管道可以自动同步两个进程。
* 创建: pipe
    * 参数: 一个包含两个 int 值的数组作为参数。读取端文件描述符将被保存在数组的第0个元素而写入端文件描述符保存在第 1 个元素中。
    * 一个进程中的文件描述符不能传递给另一个无关进程；通过调用 pipe 得到的文件描述符只在调用进程及子进程中有效。如果希望不相关的进程互相通信，应该用 FIFO 代替管道。
* 每次写入操作之后通过调用 fflush 刷新管道内容。否则，字符串可能不会立刻被通过管道发送出去。
* 当调用 ls|less 这个命令的时候会出现两次 fork 过程：一次创建 ls 子进程，一次创建 less 子进程。两个进程都继承了这些指向管道的文件描述符，因此它们可以通过管道进行通信。
* 重定向: dup2
    * dup2 (fd, STDIN_FILENO);  关闭标准输入，然后将它作为 fd 的副本重新打开。
    * popen 和 pclose 函数简化了对 pipe、fork、dup2、exec 和 fdopen 的一系列调用的过程，与一个在子进程中运行的程序发送和接受数据。
* FIFO: mkfifo
    * 一个在文件系统中有一个名字的管道。任何进程均可以打开或关闭 FIFO；通过 FIFO 连接的进程不需要是彼此关联的。
    * 第一个参数是要创建 FIFO 的路径，第二个参数是被创建的 FIFO 的属主、属组和其它用户权限。
    * 访问FIFO与访问普通文件完全相同。要通过 FIFO 通信，必须有一个程序打开这个 FIFO 写入信息，而另一个程序打开这个 FIFO 读取信息。可以有多个读取进程和多个写入进程，来自每个写入进程的数据当到达 PIPE_BUF（Linux 系统中为 4KB）的时候会自动写入 FIFO。

### 5.5 套接字
* 相关系统调用: socket/close/connect/bind/listen/accept
* 创建: socket
    * 三个参数：通信类型(SOCK_STREAM/SOCK_DGRAM)，命名空间(PF_LOCAL/PF_UNIX/PF_INET)和协议(一般为0)。
* 尽管多台主机可能共享一个文件系统，只有同一台主机上运行的程序之间可以通过本地套接字通信。
* socketpair 函数(必须使用PF_LOCAL)为一台主机上的一对相连接的的套接字创建两个文件描述符，这对文件描述符允许相关进程之间进行双向通信。
* 在GNU/Linux系统中，协议——服务名关系列表被保存在了/etc/services。


## 6.设备
### 6.1 设备类型
* 设备文件不是一般的文件并不对应于基于磁盘的文件系统中的一块数据。对设备文件进行读写会直接导致与设备驱动的沟通，从而操作底层对应的硬件。
* 字符设备: 以串的形式读写数据字节流的硬件设备。如串行和并行端口，磁带驱动器，终端设备和声卡。
* 块设备: 以固定大小数据块为单位进行读写的硬件设备。和字符设备不同，块设备提供了随机访问存储在设备上数据的能力。如磁盘驱动器。

### 6.2 设备号
* Linux 使用两个号码标识每个设备：主设备号（major device number）和次设备号（minor device number）。
* 主设备号标识了设备对应的驱动。从主设备号到设备驱动的对应关系在内核代码中确定且已经成为 Linux 内核的一部分。同一个设备号可能对应于两个不同的驱动，一个块设备驱动和一个字符设备驱动。
* 次设备号用于标识对应于同一个驱动的单独设备或组件。次设备号的具体含义取决于设备驱动程序。
* Linux 内核源码文档中列出了主设备号。在很多 GNU/Linux 发行版本中，这个文档位于 /usr/src/Linux/Documentation/devices.txt。/proc/devices 列出了已加载到内核中、被激活的设备驱动对应的主设备号。

### 6.3 设备文件
* 设备文件在许多方面与普通文件是一样的。可以用 mv 命令移动它或者用 rm 命令删除。用 cp 命令从是设备中读取字节（如果设备支持读操作）并写入到目标文件中。如果尝试覆盖一个设备文件，实际会将内容写入到目标设备上去。对于字符设备，可以像打开普通文件一样打开，然后对它进行读写操作。
* 创建: mknod
    * 第一个参数是设备文件的路径，第二个参数如果是 b 则代表块设备，c 则代表字符设备。将对应的主、从设备号作为第三、第四个参数传递。
    * 只有超级用户进程可以调用 mknod 命令或系统调用创建字符和块设备。
* GNU/Linux 系统中会有一个 /dev 文件夹包含了所有 Linux 系统所知的块设备和字符设备文件。/dev 中的文件有着经过标准化的名字对应于不同的主、次设备号。

### 6.4 硬件设备
* 可能有多个字符设备对应一个硬件设备；不同的字符设备对应于不同的语义。

### 6.5 特殊设备
* Linux 同时提供了多个并不对应于硬件的设备文件。这些设备的主设备号都是 1；这个主设备号对应于 Linux 内核的内存设备而非任何设备驱动。
* /dev/null: 所有写入到 /dev/null 的数据会被丢弃。从 /dev/null 中读取会始终得到文件结束标记（EOF）。
* /dev/zero: 表现为一个具有无限长度 0 字节的文件。可以用于初始化内存。
* /dev/full: 表现为位于一个没有剩余空间的文件系统上的文件。向 /dev/full 写入文件将会失败并得到 errno 错误号为 ENOSPC代表着写入的设备已满。用于测试程序在写入文件时遇到空间不足情况的行为。
* /dev/random和/dev/urandom: 提供了对 Linux 内核内置的随机数生成器的访问。
    * 如果从 /dev/random 中读取一个很长序列的随机数而不产生任何输入事件（不碰键盘、不移动鼠标或做任何类似的事情），Linux 将会阻塞读取操作。只有当提供了某些随机性给 Linux 时，系统才会生成更多随机数并返回给程序。
    * 对 /dev/urandom 的读操作将不会被阻塞。如果 Linux 耗尽了随机性数据，它会通过某种加密算法从之前的随机字节序列中生成更多的伪随机数。
* /dev/loop0, /dev/loop1...: 允许用户以一个普通磁盘文件虚拟一个块设备。

### 6.6 虚拟终端（PTYs）
* 一个特殊文件系统，devpts，被挂载在 /dev/pts 目录上，由 Linux 内核动态创建并维护。
* /dev/pts中的文件对应于虚拟终端设备。Linux 为每个新的终端窗口在这里建立一个设备文件。
* 如果从这个设备中读取信息，将劫持到本将被发送到运行在这个 PTY 上进程的键盘输入。如果向这个设备写入信息，写入的内容将被现实在终端窗口上。
* 如果在一个文本模式终端中（可以通过 Ctrl+Alt+F1 组合键切换到第一个终端, F7切回）尝试调用 ps 命令判断当前的 TTY 设备，将发现它是运行在一个普通终端设备上，而非一个 PTY 设备。

### 6.7 ioctl
* ioctl系统调用是一个控制硬件设备的通用接口。第一个参数是一个已经打开的指向被控制的设备的文件描述符，第二个参数是一个请求的操作对应的代码。不同设备有多种有效的请求代码。


## 7./proc文件系统
* /proc文件系统中的文件内容并不像普通文件一样都是固定的数据而是在读取文件时，由正在运行的内核动态生成的。可以通过写 /proc 文件系统上的特定文件来修改内核配置。

### 7.1 从 /proc 里提取信息
### 7.2 进程项
* /proc 文件系统包含对应 GNU/Linux 操作系统上运行着的每个进程的目录项。每个目录的名字是对应进程的PID。这个目录随着进程在系统上开始和结束而动态地出现和消失。
* 每个目录提供了若干条目用于获取对应进程的相关信息。
    * cmdline 包含进程的参数列表。
    * cwd 是一个指向进程当前工作目录（可通过 chdir 调用设置）的符号连接。
    * environ 包含进程的环境。
    * exe是一个指向正在运行的进程的可执行文件的符号链接。
    * fd 是一个包含了被进程打开的文件描述符项的子目录。
    * maps 显示文件映射到进程地址空间的信息表。对每一个映射文件，maps 显示相关文件被映射到的进程地址空间的区间，这些地址的权限，相关文件名和其他信息。每个进程的maps表中包含了这个进程的可执行文件，加载的共享库以及进程映射的其他文件。
    * root 是指向这个进程的根目录的符号链接。它通常链接到系统的根目录“/”。可以使用chroot 系统调用或者 chroot 命令改变这个进程的根目录。
    * stat 包含进程的状态和统计信息。它们和 status 项中的数据一样，只不过这里是原始的数字格式，并且都位于一行。
    * statm 包含了进程内存使用情况的信息。
    * status 包含了进程的大量状态和统计信息，这些信息被组织成便于阅读理解的格式。
    * cpu 只在支持对称多处理(SMP)的 Linux 内核中出现。它包含了每个 CPU 的进程时间明细（包括用户时间和系统时间）。
* /proc/self: /proc 文件系统的一个额外的项目使程序可以更方便地找到关于自身的信息。是一个指向当前进程（指正在访问 /proc/self 的进程）对应的 /proc 进程目录的符号链接。

### 7.3 硬件信息
* CPU信息: /proc/cpuinfo; 设备信息: /proc/devices; PCI 总线信息: /proc/pci; 串行端口信息: /proc/tty/driver/serial;

### 7.4 内核信息
* 版本信息: /proc/version; 启动参数: /proc/cmdline; 主机名和域名: /proc/sys/kernel/hostname&domainname; 内存使用: /proc/meminfo;

### 7.5 驱动器，挂载和文件系统
* 文件系统: /proc/filesystems(只列出了那些被静态链接进内核或者是已经被加载的文件系统类型); 驱动器和分区: /proc/ide&scsi; 磁盘分区: /proc/partitions; CD-ROM: /proc/sys/dev/cdrom/info; 挂载的文件系统: /proc/mounts; 锁: /proc/locks;

### 7.6 统计信息
* 系统负载信息: /proc/loadavg; 系统启动开始的时间长度: /proc/uptime;


## 8.Linux系统调用
* 库函数（library function）是由程序之外的函数库提供的普通函数。目前提及的大多库函数都属于是 C 标准库，libc。对库函数的调用与其它函数的调用类似。调用参数被写进处理器的寄存器或者推入栈顶，执行代码将跳转到函数的开始位置。通常这个位置位于加载的共享库里。
* 系统调用（system call）由 Linux 内核提供。当程序使用系统调用时，所有的参数都会被打包并移交给内核，而内核在结束执行这段系统调用之前不会交回执行的权利。系统调用不是一个普通的函数调用，在管理权移交给内核时需要一个特殊的处理过程。 GNU C 函数库封装了系统调用函数以便轻松地调用。
* 系统调用的集合构成了程序与 Linux 内核沟通的基本接口。每个系统调用都实现了一个基本的操作或者功能。
* 在 /usr/include/asm/unistd.h 可以查看系统内核的系统调用列表。

### 8.1 使用strace
* strace 命令可以跟踪一个正在执行的程序，列出程序所涉及的一切系统调用和它收到的一切信号。

### 8.2-8.15
* access: 用于判断调用进程是否拥有访问指定文件的权限。
* fctnl: 允许程序在一个文件上设置读锁或写锁(并不能真正阻止其它的进程打开这个文件，读取内容或者写入，除非它们同样利用 fcntl 申请同样的锁，即只用于同步)。
* fsync/fdatasync: 写到文件里的任意数据都被刷新到磁盘。也可以使用同步（O_SYNC ）作打开一个文件，这将引起所有写数据都立刻被提交到磁盘中。
* getrlimit/setrlimit: 允许一个进程读取或设置它被允许使用的系统资源。最大 CPU 时间，最大内存空间，同时运行的最大进程数，同时打开的文件描述符的最大数量等。
* getusage: 从内核中获取进程统计信息。
* gettimeofday: 可以获取系统当前挂钟时间。从Unix **epoch**（UTC 时间 1970 年 1 月 1 日）开始到当前流逝的时间。
* mlock/mlockall/munlock: 允许程序在物理内存上锁住它的部分或全部地址空间。这将阻止Linux 将这个内存页调度到交换空间（swap space），即使该程序已有一段时间没有访问这段空间。
* mprotect: 设置内存访问权限。所指定的内存区间必须包含整个页：区间地址必须和整个系统页大小对齐，而区间长度必须是页大小的整数倍。（malloc 返回的内存区域通常并不与内存页面对齐，可以选择使用 mmap 系统调用来绕过 malloc 并直接从 Linux 内核中分配页面对齐内存。）
* nanosleep: 一个相比标准 UNIX 的 sleep 调用具有更高精度的版本。
* readlink: 用于获得符号链接的目标。
* sendfile: 提供了从一个文件描述符复制数据到另一个文件描述符的高效机制。
* setitimer: 是 alarm 系统调用的衍生，会预设在指定的时间之后发送信号。
* sysinfo: 获得系统统计信息。
* uname: 获得包括系统的主机名和域名以及系统版本等系统信息。


## *9.内联汇编代码*


## 10.安全性
### 10.1 用户和组
* 每个 Linux 用户都被分配到一个叫做一个用户ID（user ID）或 UID 的独一无二的号码。
* 每一个组被分配一个独一无二的号码，叫做组ID（group ID）或者 GID。一个单独的用户 ID 可以是任意组的成员，但是一个组不能包含其它组，只能包含用户。

### 10.2 进程用户 ID 和组 ID
* 每一个进程关联一个用户 ID 和组 ID。 当调用一个命令，它将以调用者的用户 ID 和组 ID 作为运行的身份。
* getuid/getgid

### 10.3 文件系统权限
* 每一个文件都有一个属主（owing user）和属组（owning group）。当创建一个新文件时，文件的属主和属组被设置为当前进程对应的用户和组。
* 文件权限只有读、写、执行。对于目录，读 - 读取目录中所包含的文件列表，写 - 可以添加及删除文件（不需要对要删除的文件具有修改的权限），执行 - 可以进入目录并访问其包含的文件和子目录等。
* 如果一个目录被设置了粘滞位(chmod +t, 仅作用于目录)，则仅当用户是一个文件的属主时才被允许删除这个文件。在普通情况下，用户只要对目录具有写权限即可删除其中的文件，并不要求这个用户是文件的属主。

### 10.4 真实 ID 和有效 ID
* 每个进程事实上关联两个用户 ID：有效用户 ID(effective user ID)和真实用户 ID（real user ID）。（及有效组ID）
* geteuid/getegid
* 如果你想改变一个已经在运行的进程的有效用户 ID，内核会同时检查真实和有效用户 ID。
* setreuid/seteuid: 内核不会允许所有进程任意切换用户 ID。只允许：
    * 将有效用户 ID 设置为与真实用户 ID 相同。
    * 将真实用户 ID 设置为与有效用户 ID 相同。
    * 交换两个用户 ID。
* setuid(chmod +s): 当这个程序允许时，进程的有效用户 ID 将被设置为程序文件的属主而非调用 exec 的进程的有效用户 ID。

### 10.5 用户身份验证

### 10.6 更多安全漏洞
* 缓冲区溢出, /tmp 文件夹中的竞争状态, 调用 system 或 popen。

## *11.一个 GNU/Linux 示例应用程序*
</xmp>
<script src="js/strapdown.js"></script>
</html>
