<!DOCTYPE html>
<html>
<meta charset="utf-8" />
<title>Algorithms 4ed</title>
<xmp theme="readable" style="display:none;">
## 1 基础
定义

* **链表**是一种递归的数据结构，它或者为空（null），或者是指向一个节点（node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。
* 用`~f(N)`表示所有随着N的增大除以`f(n)`的结果趋近于1的函数。用`g(N)~f(N)`表示`g(N)/f(N)`随着N的增大趋近于1。
* 一棵树的**大小**是它的节点的数量。树中一个节点的**深度**是它到根节点的路径上的链接数。树的**高度**是它的所有节点中的最大深度。
* **union-find的成本模型**：在研究实现`union-find`的API的各种算法时，统计的是数组的访问次数（访问任意数组元素的次数，无论读写）。

性质 & 命题

* A. ThreeSum（在N个数中找出三个和为0的整数元组的数量）的运行时间的增长数量级为`N³`。
* B. 3-sum的暴力算法使用了`~N³/2`次数组访问来计算N个整数中和为0的整数三元组的数量。
* C. （倍率定理）如果`T(N)~aNᵇlogN`，那么`T(2N)/T(N)~2ᵇ`。
* D. 在Bag、Stack和Queue链表实现中所有的操作在最坏情况下所需的时间都是常数级别的。
* E. 在基于可调整大小的数组实现的Stack数据结构中，对空数据结构所进行的任意操作序列对数组的平均访问次数在最坏情况下均为常数。
* F. 在quick-find算法中，每次`find()`调用只需要访问数组一次，而归并两个分量的`union()`操作访问数组的次数在`N+3`到`2N+1`之间。
* G. quick-union算法中的`find()`方法访问数组的次数为1加上给点触点所对应节点的深度的两倍。`union()`和`connected()`访问数组的次数为两次`find()`操作（如果`union()`中给定的两个触点分别存在于不同的树中则还需要加1）。
* H. 对于N个触点，加权quick-union算法构造的森林中的任意节点的深度最多为`logN`。推论：在最坏情况下`find()`、`connected()`和`union()`的成本的增长数量级为`logN`。

## 2 排序
定义

* **排序成本模型**：在研究排序算法时，需要计算比较和交换的数量。对于不交换元素的算法，会计算访问数组的次数。
* 当一个二叉树的每个节点都大于等于它的子节点时，称为**堆有序**。
* **二叉堆**是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。

性质 & 命题

* A. 对于长度为N的数组，选择排序需要大约`N²/2`次比较和`N`次交换。
* B. 对于随机排列的长度为N且主键不重复的数组，平均情况下插入排序需要`~N²/4`次比较以及`~N²/4`次交换。最坏情况下需要`~N²/2`次比较和`~N²/2`次交换，最好情况下需要`N-1`次比较和`0`次交换。
* C. 插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。
* D. 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。
* E. 使用递增序列`1, 4, 13, 40, 121, 364…`的希尔排序所需的比较次数不会超出N的若干倍乘以递增序列的长度。
* F. 对于长度为N的任意数组，自顶向下的归并排序需要`1/2NlogN`至`NlogN`次比较。
* G. 对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组`6NlogN`次。
* H. 对于长度为N的任意数组，自顶向上的归并排序需要`1/2NlogN`至`NlogN`次比较，最多访问数组`6NlogN`次。
* I. 没有任何基于比较的算法能够保证使用少于`log(N!)~NlogN`次比较将长度为N的数组排序。
* J. 归并排序是一种渐进最优的基于比较排序的算法。
* K. 将长度为N的无重复数组排序，快速排序平均需要`~2NlnN`次比较（以及`1/6`的交换）。
* L. 快速排序最多需要约`N²/2`次比较，但随机打乱数组能够预防这种情况。
* M. 不存在任何基于比较的排序算法能够保证在`NH-N`次比较之内将N个元素排序，其中H为由主键值出现频率定义的香浓信息量。
* N. 对于大小为N的数组，三向切分的快速排序需要`~(2ln2)NH`次比较。其中H为由主键值出现频率定义的香浓信息量。
* O. 根节点是堆有序的二叉树中的最大节点。
* P. 一颗大小为N的完全二叉树的高度为`logN`（向下取整，高度从0开始）。
* Q. 对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过`logN+1`次比较，删除最大元素的操作需要不超过`2logN`次比较。在一个大小为N的索引优先队列中，插入元素（insert）、改变优先级（change）、删除（delete）和删除最小元素（remove the minimum）操作所需的比较次数和`logN`成正比。
* R. 用下沉操作由N个元素构造堆只需要少于`2N`次比较以及少于`N`次交换。
* S. 将N个元素排序，堆排序只需少于`2NlogN+2N`次比较（以及一半次数的交换）。
* T. 快速排序是最快的通用排序算法。
* U. 平均来说，基于切分的选择算法的运行时间是线性级别的。

## 3 查找
定义

* **符号表**是一种存储键值对的数据结构，支持两种操作：插入（put），即将一组新的键值对存入表中；查找（get），即根据给定的键得到相应的值。
* **查找的成本模型**: 在学习符号表的实现时，我们会统计比较的次数（等价性测试或是键的相互比较）。在内循环不进行比较（极少）的情况下，我们会统计数组的访问次数。

性质 & 命题

* A. 在含有 N 对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要`N`次比较。命中的查找在最坏情况下需要`N`次比较。特别地，向一个空表中插入`N`个不同的键需要`∼N²/2`次比较。
* B. 在`N`个键的有序数组中进行二分查找最多需要`lgN+1`次比较（无论是否成功）。向大小为`N`的有序数组中插入一个新的元素在最坏情况下需要访问`∼2N`次数组，因此向一个空符号表中插入`N`个元素在最坏情况下需要访问`∼N²`次数组。

## 4 图


## 5 字符串


## 6 背景

</xmp>
<script src="js/strapdown.js"></script>
</html>
