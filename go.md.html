<!DOCTYPE html>
<html>
<title>Go</title>
<xmp theme="readable" style="display:none;">
[http://golang.org](http://golang.org) | v1.5

## 准备
### [下载安装](http://golang.org/doc/install)

下载安装包，并解压到安装路径(如`$HOME/go`)，最后配置环境变量。
```
export GOROOT=$HOME/go
export PATH=$PATH:$GOROOT/bin
```

### [环境配置](http://golang.org/doc/code.html)
工作区：包含src, pkg, bin目录。
项目一般都是单独git目录在src下，编译`go build`出来的库文件和可执行文件安装`go install`在pkg，bin下。
设置工作区环境变量：
```
export GOPATH=$HOME/go_ws
export PATH=$PATH:$GOPATH/bin
```
安装一个包或可执行文件都会自动安装其依赖的包。如果有源文件import了一个repo URL，运行`go get`会自动下载编译和安装（git clone最新的，一般用于稳定通用库，不用于普通项目依赖管理）。
可执行文件和它所依赖的包都是静态链接在一起的。


### [工具集](http://golang.org/doc/cmd)
编译并直接运行：`go run test.go`
清除src目录下build生成的临时对象文件：`go clean`

交叉编译：
如在mac上：`GOOS=linux GOARCH=amd64 go build`


### 开发辅助工具
github.com:
[godef](https://github.com/rogpeppe/godef)
[gotags](https://github.com/jstemmer/gotags)
[gocode](https://github.com/nsf/gocode) 在`$GOPATH/pkg/$GOOS_$GOARCH`和`$GOROOT/pkg/$GOOS_$GOARCH`找lib，本地lib必须先install到pkg下
[errcheck](https://github.com/kisielk/errcheck)
[golint](https://github.com/golang/lint)

https://go.googlesource.com/tools/
goimports
oracle
gorename

用[vim-go](https://github.com/fatih/vim-go)的`:GoInstallBinaries`命令安装或`go get -u -v`安装到workspace的bin下:
github.com/nsf/gocode
github.com/rogpeppe/godef
github.com/golang/lint/golint
github.com/kisielk/errcheck
github.com/jstemmer/gotags
golang.org/x/tools/cmd/goimports
golang.org/x/tools/cmd/oracle
golang.org/x/tools/cmd/gorename

## Basics
源文件以UTF8编码。
语句以分号结尾，一个语句时通常省略，全局域中以及括号后边也不需要。
圆括号通常只用在参数列表中。
花括号的位置在一行末尾。（gofmt工具可以用来格式化代码风格）
标识: 数字，字母，下划线。
注释: `/* */`，`//`
命名：camelCasing风格。

## 基本类型
数字: int, int8/16/32/64, uint, uint8/16/32/64, float32/64, byte(unit8), rune(int32, 代表一个Unicode码), uintptr, complex64/128。支持八进制(0)，十六进制(0x)及科学记数法。
布尔(bool): true, false (预定义常量)
字符串(string):

* 默认空串(`""`)。不以0结尾。
* 可复制但不可修改其中字符，要修改必须先转为`[]byte`, `[]rune`再转回来并会造成复制。下标访问其中的字节/字符（字符可以用`''`表示）。
* `+`连接字符串。内部是UTF8的字节数组，可以用slice相关的操作。
* 16进制: `"\xFF"    // 1 byte`
* Unicode: `"\u00FF"  // 1 unicode char, 2 bytes of UTF-8`
* `len`返回字节数。用`utf8.RuneCountInString()`返回实际字符数。
* Raw:
```
`\n\.abc\t\` 相当于 "\\n\\.abc\\t\\"
```

指针：

* 默认值`nil`
* 有指针(`*Type`)及指针的指针(`**Type`)，但没有指针算术。
* 用`&`取得变量的指针，一律用`.`访问目标。
* 函数中可以返回局部变量的指针，因为局部变量不一定分配在栈上。

类型转换

* 转换只适用于几种简单的情况：转换整数(int)到去其他的精度和大小，整数(int)与浮点数(float)的转换，底层一样但类型名不一样之间的转换
* 没有隐式转换
* 显式转换T(v)：
* 转换会不会造成复制取决于转换的类型
```
uint8(int_var)   // truncate to size
int(float_var)   // truncate fraction
float64(int_var) // convert to float
string(0x1234)          // == "\u1234"
string(array_of_bytes)  // bytes -> bytes
string(array_of_ints)   // ints -> Unicode/UTF-8
[]byte("hello")  // string -> array of byte
```

操作符优先级：`* / % << >> & &^（位清除）^（取反）`，`+ - | ^（异或）`，`== != < <= > >=`，`<-（通信）`，`&&`，`||`。


## 变量常量
var(变量): 必须有类型和初始化表达式之一。
未初始化的变量自动为0, 指针和引用为nil。
不用的变量可以使用`_`。
`:=`缩写声明并初始化变量，只可以在函数中使用。
未被使用的局部非常变量或导入的包被认为是个错误。
多重赋值的时候，先计算等号右边的表达式，再进行赋值（都是从左到右的顺序）。多重赋值可以用于函数调用时实参传给形参。
```
var i int
var j = 365.245 // 自动推导类型
var a, b int = 1, 2 // a,b都是int
v := value // 省略var的简写
a, b, c, d := 1, 2.0, "three", FOUR

// 初始化表
var (
    i int;
    j = 356.245; // 分号可省
    k int = 0;
    l, m uint64 = 1, 2;
    billion int64 = 1e9;
    inter, floater, stringer = 1, 2.0, "hi"
)
```

`const`(常量): 必须有编译期确定初始化表达式，只可以是数字，字符，布尔类型，类型说明可省。
```
// 枚举（只可以此类型自己或常量匹配）
type Weekday int
const (
    Monday Weekday = iota
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)

const (
    a = "xyz"
    b            // 同上
)

// 使用iota自增长counter
const (
    loc0, bit0 uint32 = iota, 1<<iota;  // 0, 1
    loc1, bit1;                         // 1, 2 重复上一个表达式
    loc2, bit2;                         // 2, 4
)
```

`type`: 给一个匿名类型（一般是复合类型，如`[]int`, `map[int]int`, `struct {}`, `func() {}`）起个名字（命名！简单区别：命名类型只含有标识没有其它符号）或一个命名类型起个别名，类似C里的typedef，但不完全一样：

* 如果两个类型的变量都是命名类型，即使底层一样也不能通用（可以强转）。
* 如果两个类型的变量其中有一个是匿名类型，如果底层一样则可以通用。

```
type Point struct {
    x, y, z float32;
    name string
}
type Operator func(a, b int) int
type ArrayOfIntPointers []*int
```

当把一个（非interface）的类型定义为一个新的类型时，可以在新的类型上增加方法，但新的类型不会继承现有类型的方法，而interface类型会保留。可以用匿名内嵌的方式：
```
type myType struct {
    AType
}
```

赋值，可以多个变量一起
```
a = b
x, y, z = f1(), f2(), f3()
a, b = b, a
nbytes, error := Write(buf)
```

`new` 是一个函数，分配了一个零初始化的类型值，返回指向它的指针，没有delete。不一定分配在堆上。
```
var p *Point = new(Point) // 或 &Point{}
v := new(int)   // v has type *int
```

`make`

* 对于引用语义的复杂类型(slice, map, channel)用make来初始化引用（分配内存和初始化结构）。引用类型的赋值可以理解成这个类型头结构的值传递赋值。
* 未初始化的引用为nil, 如: `var ar []int`, `var m map[string]int`, `var chan int`
* 字面定义`ar := []int {}` 和 `ar := make([]int)`
* 字面定义`m := map[string]int {}` 和 `m := make(map[string]int)`

`++`/`--` 是语句不是表达式，只能后置使用。

## 控制结构
`if`: 可以有一个简单的语句（初始化变量的作用域仅在语句和if/else内，内部是新的作用域可以定义同名变量），也可以什么也没有表示true(switch同)
其他类型不能自动转为bool，因此不能直接用于条件语句。
不支持三元操作`x > y ? x : y`。没有逗号操作符。
```
if v := f(); v < 10 {
    fmt.Printf("%d less than 10\n", v)
} else {
    fmt.Printf("%d not less than 10", v)
}
```

`for`: 表示循环(没有while)
```
for i := 0; i < 10; i++ { ... }
for i < 10 { ... } // while
for { fmt.Printf("Mine! ") } // endless loop
for key, value := range m { // m is map, 也可只取key，对于array和slice, 返回index及value，key&value每次迭代都会被重用
    fmt.Printf("key %s, value %g\n", key, value)
}
s := "[\u00ff\u754c]";
for i, c := range s { // 对于string，按照rune类型迭代
    fmt.Printf("%d:%c ", i, c)  // 打印 0:[ 1:ÿ 3:界 6:]
}
for range s {  } // iterate only
```
range会复制一份对象出来迭代，循环里引用的是复制过的对象，尽量使用引用或指针类型。
迭代值的重用：注意[range和goroutine结合使用的问题](http://stackoverflow.com/questions/30577212/go-for-range-slice-and-goroutine-method-invocation-the-logic-behind), [common mistakes](https://github.com/golang/go/wiki/CommonMistakes)。

`switch`: 任意类型，除非以`fallthrough`语句结束并进入下一个分支，否则分支会自动终止，一个case可以带多个值
```
a, b := x[i], y[j];
switch { // true
case a < b:  return -1
case a == b: return 0
case a > b:  return 1
}
```

`break`(可用于for/switch/select), `continue`(可用于for): 后面可以接一个标识循环(for)的label，表示这个continue/break是针对这个循环的（一般是内层循环使用，label标识外层循环，label为函数scope）。
label也可以在`goto`中使用。

## 复杂类型
### Array
声明: `var ar [3]int`, 长度: `len(ar)`
按值传递，但可以用指针避免复制(更多的是使用slice)。
初始化
```
[3]int { 1, 2, 3 }
[10]int { 1, 2, 3 } // 其它为0
[...]int { 1, 2, 3 } // 自己计算长度
[10]int { 2:1, 3:1, 5:1, 7:1 } // 个别赋值
[...][2]int {{1,2}, {3,4}, {5,6}} // 2维数组
```

### [Slice](http://blog.golang.org/go-slices-usage-and-internals)
Slice是一个引用类型，是对一个Array的部分引用。只要有slice在引用着，底层Array就不会被GC掉。
声明: `var a []int`, 不指定长度。
`len()`可以取得长度，而`cap()`则返回slice的容量(默认一直至被引用数组结尾的大小)。基于slice创建的slice不能超过cap大小。
string也可以被slice。不可修改。
初始化，赋值
```
a = ar[7:9] // 长度为2, [7,9)
a2 = ar[7:9:10] // 指定容量为3, [7,10)，下标都是指索引值
a3 = &ar  // same as a = ar[0:len(ar)] or ar[:]
header, data := buf[0:n], buf[n:len(buf)] // split
var slice = []int{ 1,2,3,4,5 } // 字面定义，可以个别赋值，自动创建底层数组
var s100 = make([]int, 100) // slice: 100 ints, cap = len
var sl = make([]int, 0, 100)  // len 0, cap 100
s1 = nil // clear
data := [][]int {[]int{1,2}, []int{3,4}} // slice of slice
slice = slice[5:10] // reslice, reuse name
```

`append(slice, v1, v2, ...)`: 在slice（可以是nil）结尾添加数据，返回新slice。如果未超出cap限制，会修改原数组，否则会复制并重新分配底层数组，且cap变为原来的2倍。
`copy(dest, src)`: 复制一个slice到另一个，直到其中一个结尾，返回copy的个数，可正确处理重叠部分。复制到一个数组：`copy(array[:], src)`


更多：[Slice详解](http://blog.golang.org/slices), [SliceTricks](https://github.com/golang/go/wiki/SliceTricks)

### [Map](https://blog.golang.org/go-maps-in-action)
Map是哈希表（key可以为任何定义了等于操作符的类型），引用类型。
声明: `var m map[string]float32 // key:string, value:float32`, 长度: `len(m)`返回key的个数，cap不可作用于map。(set: `var s map[string]struct{}`)
初始化，赋值
```
m = map[string]float32 { "1":1, "pi":3.1415 } // 字面定义
m = map[Point]string {{1,2} : "foo", {5,6} : "bar"}
m = make(map[string]float32, 500) // len为0，500类似cap
var m1 map[string]float32 = m // m1 and m now refer to same map
```
访问元素
```
one   := m["1"] // 取值，会复制一份出来
crash := m["not present"]  // 0
m["2"] = 2
v, ok := m[x] // the "comma ok" form, 测试是否有值
m[x].name = "abc" // 如果没有值则error
delete(m, x)   // deletes entry for x，若不存在不会出错
for key, value := range m { ... } // 迭代，顺序不固定，其中可以有删除操作，删除的元素不会被后续迭代到
```
如果需要有序遍历map，则要维护一个有序的key slice，然后用其来迭代。

### Struct
Struct是值类型，声明: `var p struct { x, y float32 }`
可用`_`表示占位字段。成员可以是自身类型的指针。
`var pp *Point = new(Point); pp.x = 1; pp.y = 2 // 没有"->"，统一用"."访问成员，或(*pp).x`
初始化，赋值:
```
type Point struct { x, y float32 };
p = Point{ 7.2, 8.4 } // 顺序初始化必须包括所有成员，或者都不提供（空初始化）
p = Point{ y:8.4, x:7.2 }
pp := &Point{ 23.4, -1 }   // idiomatic
```
可以为字段定义一个字面字符串标签（struct tag, 属于类型的一部分），用于反射读取。`var x struct {pos int "position"}`
如果一个struct成员开头大写，则表示对包外可见。
匿名域：如果一个struct包含一个没有命名的变量，则用它的类型名字命名（同时用匿名类型及其指针类型会同名）。`type B struct {string}; fmt.Println(b.string);`
如果成员是个匿名struct或其指针，则还可以平展开，就像自己有这样的成员（该类型的所有方法会变成外部类型的方法，但被调用时其接收的参数仍是内部类型），但外面的名字会具有高优先级。同级不能有相同名字的成员。（类似继承）
```
type B struct{ a, b int }
type C struct{ s string }
type D struct {
	B
	b float64
	*C
}
var d = D{B{1, 2}, 3, &C{"xyz"}}
fmt.Println(d.a)    // 1
fmt.Println(d.b)    // 3
fmt.Println(d.B)    // {1,2}
fmt.Println(d.B.b)  // 2
fmt.Println(d.C)    // &{xyz}
fmt.Println(d.s)    // xyz
```
同一包内的struct可以使用另一个包内struct的域及方法（包内全可见）。

### 比较
只有Struct, Array可以进行`==`, `!=`比较，逐个元素比较，成员必须也可以比较。
Slice, Map, Function都只可以和nil比较。可以用`reflect.DeepEqual()`函数来比较。
Interface的等同比较包括类型和值都要相同。


## 函数及接口
### function
first class, 定义:
```
func MySqrt(f float32) (v float32, ok bool) {
    if f >= 0 { v,ok = math.Sqrt(f),true }
    return // implicit
}
```
可以指定每个参数的名字或者不指定任何参数名字，不能只指定部分函数参数的名字。
如果是相邻的参数是相同的类型，也可以统一指定类型。
如果命名了返回值参数（局部变量），return可以不带参数返回当前值（不被其他同名变量遮盖(shadowed)的情况下）。
不支持默认参数。
多返回值可以直接作为函数调用的实参。

闭包：
```
func adder() (func(int) int) {
    var x int
    return func(delta int) int { // lambda
        x += delta
        return x
    }
}
var f = adder();
fmt.Print(f(1));
fmt.Print(f(20));
fmt.Print(f(300));
```
闭包以引用的方式使用外部变量。

可变参数：只能有一个，必须放在所有参数最后。类似slice的处理。
```
func foo(x int, y ...int) {
    for i, v := range y {
        x += v
    }
}

a := []int {1, 2, 3, 4}
foo(100, a...) // 展开slice
```

### method
可以把方法附加在本包内的任意非指针或接口类型上（不仅仅是struct，对内置类型要type改名一下），只要指明接收者即可（可以是值或指针类型）。
无论接收者是值类型还是指针类型的方法，用值或指针实例都可以进行调用（编译器会转成接收者对应的类型），但只有用指针接收者的形式才能避免值拷贝传递以及做修改（类似函数参数）。
用值调用指针接收方法时，值要可以取址。有着非指针类型struct元素值的Map如`m[1]`不可取址（slice却可以），也不能直接赋值`m[1].x=2`，必须使用临时变量。
只有struct没有class，method是一种特殊的函数，不支持重载，接收者（相当于this）是方法签名的一部分。
Accessor方法命名惯例直接用属性名表示get，“set属性名”表示set。
```
type Point struct { x, y float64 }
func (p Point) Abs() float64 {
    return math.Sqrt(p.x*p.x + p.y*p.y)
}
func (p *Point) Swap() {
    p.x, p.y = p.y, p.x
}

p := &Point{3, 4};
fmt.Print(p.Abs());  // will print 5

p2 := Point{5,6}
p2.Swap()
fmt.Print(p2);  // will print {6,5}
```

类型和它的方法必须在同一包内。
当一个匿名类型嵌入一个struct，它的所有方法也被“继承”。同名方法可以被此struct重载。
```
type Mutex struct { ... }
func (m *Mutex) Lock() { ... }
type Buffer struct {
    data [100]byte
    Mutex  // need not be first in Buffer
}
var buf = new(Buffer);
buf.Lock();  // == buf.Mutex.Lock()
```
如果为一个类型定义`String()`方法，则可以直接被`fmt.Print[ln]`打印使用。

method value & method expression：可以把method像函数一样赋值给其他变量
```
mv := p.Abs // method value
mv() // 已绑定实例
me := Point.Abs // method exp: func(p Point) float64
me(p)

sv := p.Swap
se := (*Point).Swap // func(p *Point)
se(&p)
```

### interface
一个interface是许多method的集合。接口命名惯以er为后缀，只有签名没有实现，没有数据字段，可以包含其他接口。
interface变量仅在类型和值都为nil时才为nil: `val==nil`。如果只是值为nil，那么也会打印出`<nil>`。
```
func foo() *int {
    return nil
}

var a interface{} = foo()
if v, ok := a.(*int); ok {
    if v == nil {
        fmt.Printf("%v, %v, %v", nil, a, a == nil)
    }
}
// output: <nil>, <nil>, false
```
如果你的类型实现了一个和众所周知的类型具有相同含义的方法，那么就使用相同的名字和签名；如Read，Write，Close，Flush，String等。
定义:
```
type EmptyInterface interface { }
type AbsInterface interface {
    Abs() float32  // receiver is implied
}
```

任何实现了其接口的类型的变量都可以赋值给interface变量（隐式接口，无需声明，静态检查），它存储了receiver的值（只读复制品，如果要修改成员变量必须传递指针类型）以及一张method表。
每个类型都有与之关联的方法集，这个集合决定了实现了接口的哪些方法。

* 类型`T`包含全部接收者类型为`T`的方法。
* 类型`*T`包含全部接收者类型为`T`和`*T`的方法。
* 如类型`S`包含匿名字段`T`，则包含`T`的方法。
* 如类型`S`包含匿名字段`*T`，则包含`T`和`*T`的方法。
* 不管包含`T`还是`*T`，`*S`总是包含`T`和`*T`的方法。

```
type Vector struct {
    a []EmptyInterface // 可以放任意类型的vector
}
```

将接口类型转回原类型：`interface_value.(type_to_extract)`，在运行期检测（使用comma,ok或switch检测，否则会panic，相比普通类型转换在编译期静态检查）。
接口之间也可以互相转换，取决于底层所包含的类型能否转换，超集可以转换为子集。
```
// 检查是否实现了String接口
type Stringer interface { String() string }
if sv, ok := v.(Stringer); ok {
    fmt.Printf("implements String(): %s\n", sv.String()); // note: sv not v
}

// 习惯在switch里重用一个名字，实际上是在每个case里声名一个新的变量，其具有相同的名字，但是不同的类型。
switch v := v.(type) {
case Stringer:
    ...
}
```
Print等利用反射机制("reflect" package)知道其参数类型，也可以用`%v`表示任意类型格式。

接口一般只针对method，如果一般函数要实现接口，则在函数类型上附加方法：
```
type ToString func() string
func (this ToString) String() string {
    return this()
}

var s Stringer = ToString(func() string { return "test" })
s.String()
```


## Concurrency
> [Do not communicate by sharing memory; instead, share memory by communicating.](http://blog.golang.org/share-memory-by-communicating)

并发模型：[CSP模型(Communicating Sequential Processes)](https://en.wikipedia.org/wiki/Communicating_sequential_processes)
内存模型：https://golang.org/ref/mem

### Goroutine
goroutine指在同一地址空间内并发执行的函数，非常廉价和轻量级。执行: `go f()`
`go`也可以用于启动新定义的内部函数（闭包）为goroutines。
可以在不同的处理器上并发运行，而且共享内存。(gccgo目前是使用pthread实现的)
goroutine的默认堆栈大小8KB，最大1GB（64bit），250M（32bit）。
goroutine是系统资源，从外部无法结束它，除非自己退出，否则会造成资源泄露（通常是一直阻塞在里面的channel上）。

### 调度
`runtime.GOMAXPROCS(n)` 指定最多可以并行执行的goroutine数目（实际系统线程数可以大于PROC数，最大256），默认为CPU核心线程数。`runtime.NumGoroutine()`返回当前存在的goroutine的数目。`runtime.NumCPU()`返回CPU核心数目。
`runtime.Goexit()`终止当前goroutine的执行（defer仍起作用）。
`runtime.Gosched()`暂停当前goroutine，等待被再次调度（类似协程里的yield）。
goroutine如果内部调用了非内联函数（内联函数如lambda，编译运行时可以用`-gcflags -m`查看），会在函数入口采用抢占式调度。其他调度时机：在`Gosched()`，GC、go声明、阻塞channel、阻塞系统调用和lock操作后进行调度。
进程退出时并不等待goroutine结束，可以用`sync.WaitGroup`等待。

关于goroutine的调度，可以看[go-scheduler](http://morsmachine.dk/go-scheduler) （[中文](http://mikespook.com/2013/07/%E7%BF%BB%E8%AF%91go-%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8/)）, [netpoller](http://morsmachine.dk/netpoller)，以及[原始设计文档](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw)。

### Channel
声明: `chan element_type`，创建: `var c = make(chan int)`
channel是引用类型，内部同步，并发安全。
`len`返回未被读取的缓冲元素个数，`cap`返回缓冲区大小。
```
var c = make(chan int)
c <- 1   // send
i := <-c // receive
```
channel是同步的，发送要等待接收，接收要等待发送。只有一个goroutine的情况下(main)，等待会抛出死锁异常。
在一个nil的channel上发送和接收会永久阻塞，可用来控制select中的某个case。
可以用make指定buffer: `make(chan int, 50)`, buffer只是channel的属性不是类型，默认大小为0（无缓冲）。
range会从channel迭代数据，直到channel关闭。
```
func suck(ch chan int) {
    go func() {
        for v := range ch { fmt.Println(v) }
    }()
}
```

关闭channel: `close()`, 一般由发送端来关闭channel，而不是接收端，因为向一个已经关闭的channel发送数据会引起panic（无论阻不阻塞，如果先阻塞再关闭则会永久阻塞，应使用timeout解决），而从一个已经关闭（如果有buffer数据会先读完）的channel接收数据为0/nil和false: `v, ok = <-c`。
默认channel是双向的，也可以转换为指定的方向：`var recv_only <-chan int;  var send_only chan<- int;` 可以用双向channel赋值给单向的，反之不可，单向不同方向也不可。

`select`

* select的case必须是channel操作。如果有表达式都会被依次求值。
* 如果每个条件都阻塞，select就会阻塞（如果有default则进入操作）。
* 如果多个条件满足，则随机选择一个执行。
* `select {}`阻塞goroutine。
```
c1 := make(chan int)
c2 := make(chan int)
select {
case v := <-c1:
    fmt.Printf("received %d from c1\n", v)
case v := <-c2:
    fmt.Printf("received %d from c2\n", v)
case t := <-time.After(1 * time.Second):
    fmt.Printf("received timeout, current time: %s\n", t)
default:
    time.Sleep(10000)
}
```

`chanOfChans := make(chan chan int)`

## Concurrency Patterns
### [Timing out, moving on](http://blog.golang.org/go-concurrency-patterns-timing-out-and)
#### timeouts
```
timeout := make(chan bool, 1)
go func() {
    time.Sleep(1 * time.Second)
    timeout <- true
}()

select {
case <-ch:
    // a read from ch has occurred
case <-timeout:
    // the read from ch has timed out
}
```
实际中直接使用`<-time.After(1 * time.Second)`代替case timeout条件。`time.After`返回一个阻塞的chan，时间到后变为可读，返回当前时间。

#### race condition
取query中第一个返回的response：
```
func Query(conns []Conn, query string) Result {
    ch := make(chan Result, 1)
    for _, conn := range conns {
        go func(c Conn) {
            select {
            case ch <- c.DoQuery(query):
            default:
            }
        }(conn)
    }
    return <-ch
}
```
带有空default的select：非阻塞，保证ch满（其它case阻塞）时也能正常退出，释放goroutine资源。
带有buffer的channel：保证还未开始接收时，也能存放结果，否则（不带缓存）发送全部失败(default退出)，接收永远阻塞。

### [Pipelines and cancellation](http://blog.golang.org/pipelines)
fan-out: 多个函数从同一个channel里面读直至关闭。
fan-in: 一个函数从不同的输入读取和处理并汇总到一个channel输出直到所有输入都关闭。
pipeline: 一系列由channel连接的处理过程，每个处理过程由一组goroutine执行完成相同的功能。

原则：
每个处理过程当所有发送都完成后要关闭输出channel（使用defer close）。
每个处理过程从输入channel里读取，直到所有输入都关闭（使用range loop）或发送者退出（使用done channel通知，也应关闭channel）。

```
func gen(done <-chan struct{}, nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            select {
            case out <- n * n:
            case <-done:
                return
            }
        }
    }()
    return out
}

func sq(done <-chan struct{}, in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            select {
            case out <- n * n:
            case <-done:
                return
            }
        }
    }()
    return out
}

func merge(done <-chan struct{}, cs ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    wg.Add(len(cs))
    for _, c := range cs {
        go func(ch <-chan int) {
            defer wg.Done()
            for n := range ch {
                select {
                case out <- n:
                case <-done:
                    return
                }
            }
        }(c)
    }

    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}

func main() {
    // done channel在整个pipeline中共享，在pipeline退出时关闭来通知所有工作goroutine退出
    done := make(chan struct{})
    defer close(done)

    in := gen(done, 2, 3)

    // fan-out
    c1 := sq(done, in)
    c2 := sq(done, in)

    // fan-in
    out := merge(done, c1, c2)

    fmt.Println(<-out) // 4 or 9
}
```


### [Context](http://blog.golang.org/context)
Context是一个请求的上下文，一般用于服务端在一系列goroutine里处理请求时带上取消通知，超时通知，相关请求参数（如ID，token等）以便主动超时或取消请求时（或发生异常时）退出所有相关goroutine释放资源。
Context本身是线程安全的，它携带的参数也必须是线程安全的。
Context可以有继承关系，当一个Context被取消，它所有的子Context都会被取消（收到通知）。
```
// A Context carries a deadline, cancelation signal, and request-scoped values
// across API boundaries. Its methods are safe for simultaneous use by multiple
// goroutines.
type Context interface {
    // Done returns a channel that is closed when this Context is canceled
    // or times out.
    Done() <-chan struct{}

    // Err indicates why this context was canceled, after the Done channel
    // is closed.
    Err() error

    // Deadline returns the time when this Context will be canceled, if any.
    Deadline() (deadline time.Time, ok bool)

    // Value returns the value associated with key or nil if none.
    Value(key interface{}) interface{}
}
```

`func Background() Context` 返回可以作为所有Context的父Context，它永远不会被取消。
`func WithCancel(parent Context) (ctx Context, cancel CancelFunc)` 当cancel被调用到时（一般在处理这个请求的handler返回时调用），ctx得到通知（`Done()返回`）。
`func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)` 当超过某段时间时，ctx得到通知。
`func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)` 当某个时间点到达时，ctx得到通知。
`func WithValue(parent Context, key interface{}, val interface{}) Context` 用于设置请求相关参数。用`ctx.Value()`取得值。

## 错误处理
### [errors](http://blog.golang.org/error-handling-and-go) ([pkg](https://golang.org/pkg/errors/))
内置的error接口（还有`errors`包），当用`fmt`包的多种不同的打印函数输出一个`error`时，会自动的调用`Error`方法。
error的描述一般小写开头，最后不带句号，因为经常被嵌入到其他描述中。
```
type error interface {
    Error() string
}
```
`errors.New`/`fmt.Errorf`：创建error对象。

### [panic and recover](http://blog.golang.org/defer-panic-and-recover)
`defer`

* defer后面的语句在函数return时候调用（最终返回之前，(如果有)计算return表达式之后，并可改变返回参数的值）。
* defer函数的参数值在defer的定义点确定并复制（如果需要实时的值，可以使用闭包）。
* 可以有多个defer，执行时按LIFO顺序，即使中间发生panic也都保证后续执行。
* defer性能不高，不要在循环内使用。
* 如果要在语句块中使用，可以写成lambda代替语句块。

`panic`: 类似抛出异常，一直向上传递，并终止程序（不能跨越goroutine的边界）。参数类型为`interface{}`，可接受任何参数。一些运行时错误比如数组越界，引用空指针也会引发panic。
`recover`: 终止panic展开，返回最后一个的panic的参数，只能在defer函数中**直接**调用。没有捕获到panic则返回nil。


## Packages
每个go的源文件第一行都必须是`package xxx`

* 可执行文件包名`package main`(在单独目录)，内含一个main函数。
* 库文件包名(一般和所在目录名相同，包里的每个源文件都必须有相同的名字): `package fmt`

导入包: `import myfmt "path/to/fmt"  // use the name myfmt，相对src的路径`
导入本地包：`import "./myfmt" // 仅对go run或go build main.go有效`
导入内部包（内部包只能包自己可以用，`go run`不受此限制）。`import "myfmt/internal/util"`
不导入仅初始化：`import _ "fmt"`
全部导入（无须以包名开头使用）：`import . "fmt"`
导入多个包：
```
import (
    "fmt"
    "math"
)
```
在一个包内部，所有全局变量函数等对于包的源文件可见。对于包的使用者来说，只有开头字母大写的可见。
全局变量的初始化：声明的时候初始化；使用`init()`函数，在包所有全局变量初始化后执行`main.main()`之前执行。初始化总是单线程的，根据包的依赖顺序执行。
导入一个包时，这个包内除了`*_test.go`每个源文件的`init()`都会被调用，不管有没有用到里面的变量或函数。
一般来说，一个目录一个包，作为一个单元一起编译，忽略测试文件。
按照惯例，包名使用小写，且为一个单词的名字；不要使用下划线或者混合大小写。

### Vendoring
实验性功能，默认不启用。启用：`GO15VENDOREXPERIMENT=1`
在src下如果有形如`d/vendor`的目录（一般vendor不直接放在src下），那么在`d`及其子目录下面build的时候import路径也会在`d/vendor`下面查找。如果有同名冲突，则选择路径长的。


## Testing ([pkg](http://golang.org/pkg/testing/))
### Test
* 命令: `go test`, 运行所有测试文件。`go help testflag`查看测试相关参数。
* 文件名: `*_test.go`，里面定义的变量在非测试时不可用。
* 用例函数签名: `func TestXxxx(t *testing.T)`，如果调用了`t.Error`, `t.Fail`则测试失败。
* 测试工具包: `import "testing"`, 支持logging, error reporting...
* 重写`TestMain`以进行初始化/清理工作。
```
func TestMain(m *testing.M) {
    // do setup
    code := m.Run()
    // do teardown
    os.Exit(code)
}
```
* subtests: 可以创建子测试用例，subbench类似
```
func TestFoo(t *testing.T) {
    // do setup
    t.Run("sub1", func(t *testing.T) {
        // do test
    })
    // do teardown
}
```

### Benchmarks
`go test -bench=. -benchtime=3s -benchmem`
测试函数必须形如：`b.N`是本轮测试循环次数，会根据每个测试的要求时间自动调整（默认1s）。
```
func BenchmarkHello(b *testing.B) {
    for i := 0; i < b.N; i++ {
        fmt.Sprintf("hello")
    }
}
```
用`b.ResetTimer()`重新计时。

### Example
示例函数命名(suffix可选)：

* package: Example_suffix
* func: ExampleFuncA_suffix
* type: ExampleTypeA_suffix
* method: ExampleTypeA_MethodA_suffix

通过stdout输出来判断结果。(内置函数`print/println`输出到stderr)

### util packages
`net/http/httptest`: 测试http
`testing/iotest`：模拟io读写错误等
`testing/quick`: 产生随机数做黒盒测试，[详解](http://blog.matttproud.com/2015/06/testingquick-blackbox-testing-in-go-for.html)
https://github.com/dvyukov/go-fuzz : 随机数据测试
https://github.com/stretchr/testify : 辅助测试工具

## Debuging ([pkg](https://golang.org/pkg/runtime/debug/))
查看运行状态：`GOMAXPROCS=2 GODEBUG="schedtrace=1000, scheddetail=1" ./test.out`
查看GC情况：`GODEBUG="gctrace=1" ./test.out` 用[gcvis](https://github.com/davecheney/gcvis)可视化。
查看go相关环境变量：`go env`
查看import及依赖：`go list -json`
竞态检测：`go run/build/test -race`

[GDB](https://golang.org/doc/gdb): v7.1+

* debug: 禁止内联和优化 `-gcflags "-N -l"`。
* release: 删除调试信息和符号表 `-ldflags "-w -s"`。

## Coverage ([cmd](http://golang.org/cmd/cover/))
生成：`go test -coverprofile=cover.out`
查看：`go tool cover -html=cover.out`

## [Profiling](http://blog.golang.org/profiling-go-programs) ([cmd](http://golang.org/cmd/pprof/) [pkg](https://golang.org/pkg/runtime/pprof/))
测试时：`go test -cpuprofile/-memprofile out.prof`
独立程序：`pprof.StartCPUProfile()/pprof.StopCPUProfile()/pprof.WriteHeapProfile()`
查看：`go tool pprof binary out.prof`

http接口：`import _ "net/http/pprof"`
查看：`go tool pprof http://localhost:6060/debug/pprof/profile(heap, block)`

## Documentation ([cmd](http://godoc.org/golang.org/x/tools/cmd/godoc))
规范化注释格式，任何直接属于顶层声明的注释都会可被`godoc`提取为文档注释（除了package main）。

* 要和被注释的成员相邻
* 用空行分隔段落
* 缩进表示格式化文本（代码片段）
* bug: `// BUG(author): overflow`
* 每个程序包都应该有一个包注释，一个位于package语句之前的注释（只需要出现在一个文件中）。
* 每一个被导出的（大写的）名字，都应该有一个注释。
* 注释的第一句话应该为一条概括，并且使用被声明的名字作为开头。`// FuncName does ...`

## [CodingStyle](http://blog.golang.org/go-fmt-your-code) ([cmd](http://golang.org/cmd/gofmt/))
[Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
[What's in a name?](https://talks.golang.org/2014/names.slide#1)

## Build Constraints([pkg](https://golang.org/pkg/go/build/))
又称build tag或条件编译。在`go run/build/test`的时候以`-tags`指定。
指令：在源文件（不一定是go文件）中以`// +build`表示，必须在package之前并以空行隔开。
条件：`空格：或`，`逗号：与`，`!：非`，多行表示“与”。比如`// +build linux,386 darwin,!cgo`表示`(linux OR darwin) AND 386`
特殊的tag：操作系统`runtime.GOOS`，架构`runtime.GOARCH`，编译器`gc`/`gccgo`，`cgo`，版本`go1.x`，忽略`ignore`。
操作系统和架构也可以以文件名的形式说明：`*_GOOS`, `*_GOARCH`, `*_GOOS_GOARCH`，如`source_windows_amd64.go`

## [Packages](https://golang.org/pkg/)
### net/http
* 在得到http请求的响应且没有错误的情况下(resp不为nil)，在读取完body之后（或没有body），都要手动进行`resp.Body.Close()`。
* 如果不想http保持连接，在发送请求之前设置`req.Close = true`或者`req.Header.Add("Connection", "close")`。

### [reflection](http://blog.golang.org/laws-of-reflection)
通过reflection可以取得接口里面的类型和值的信息。

#### 从接口得到reflection对象
`reflect.ValueOf()` 取得值对象
`reflect.Type()` 取得类型对象
`reflect.Kind()/reflect.Type().Kind()` 取得类型的枚举值(底层类型)，可以用getter/setter方法转为相应的（最大范围）类型。

#### 从reflection对象到接口
`v.Interface()` 将reflect值对象转为interface。
`v.Elem()` 如果v底层是Interface或Ptr对象，取得其包含或指向的对象。
`t.Elem()` 如果v底层是Array, Chan, Map, Ptr, 或Slice类型，取得其元素类型。

#### 更新可设置reflection对象的值
`v.CanSet()` 测试一个值是否可以设置(是否可以通过reflection对象来设置原始值，这就要求取得reflection对象时必须传递指针给ValueOf()，则`v.Elem().CanSet()`为true)。

#### Struct
通过value对象的field方法取得field对象。
通过type对象的field方法取得field元信息。
struct的field可设置必须首先是导出的。

```
type T struct {
    A int
    B string
}
t := T{23, "skidoo"}
s := reflect.ValueOf(&t).Elem()
typeOfT := s.Type()
for i := 0; i < s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf("%d: %s %s = %v\n", i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
}
// out:
// 0: A int = 23
// 1: B string = skidoo
```

### [encoding/json](https://blog.golang.org/json-and-go)
#### encoding/marshal
* 对于map类型必须以string为key
* channel, complex, function类型不能被encode
* 循环数据结构不能被encode
* 指针类型会被encode成其指向的值
* 只有导出的字段会被encode
* 数据流使用`NewEncoder`

Go|Json
-|-
bool|boolean
int, float...|numbers
string|string
array,slice|array
map[string]T|object
[]byte|base64 string
struct|object
nil|null

#### decoding/unmarshal
* decode匹配字段struct tag > 字段名 > 不区分大小写字段名，找不到匹配的则忽略
* 对于指针，slice，map类型若没预先分配则会自动分配内存，如果没有匹配字段则为nil
* 数据流使用`NewDecoder`

Json|Go
-|-
boolean|bool
number|float64
string|string
null|nil
array|[]interface{}
object|map[string]interface{}

#### struct tag
`json:"-"` 忽略这个字段
`json:"myName"` 在json里key为myName
`json:"myName,omitempty"` 如果字段为空值则忽略
`json:",string"` 数值，布尔类型在json里转为string编码

### misc
* `log.Fatal*()`和`log.Panic*()`会导致进程退出和panic。
* 未导出的结构体的字段将不会被（json、xml、gob等）编码。

## [cgo](http://blog.golang.org/c-go-cgo) ([cmd](https://golang.org/cmd/cgo/) [eg](https://golang.org/misc/cgo/))
用`CGO_ENABLED`环境变量启用／禁用。

### preamble
preamble以注释的形式在`import "C"`前面，会在编译这个包的时候一起编译。

* 直接代码。
* `#include`: 包含头文件，可以以`C.xxx`的方式使用里面的类型，函数，变量等（不论大小写，但静态变量不可引用）。（实现文件如果在包内目录会一起参与编译）
* `#cgo`: 传递CFLAGS, CPPFLAGS, CXXFLAGS和LDFLAG编译参数(`CGO_XXX`)给编译器。也可以用`#cgo pkg-config`指定CPPFLAGS和LDFLAGS参数。`${SRCDIR}`会被扩展成包源文件所在目录。


```
// #cgo CFLAGS: -DPNG_DEBUG=1
// #cgo amd64 386 CFLAGS: -DX86=1
// #cgo LDFLAGS: -lpng
// #cgo pkg-config: png cairo
// #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo
// #include <stdlib.h>
import "C"

func Random() int {
    return int(C.random())
}

func Seed(i int) {
    C.srandom(C.uint(i))
}
```

### C->Go
所有C/C++类型对应在Go里都是非导出的。
不能在Go里直接调用C函数指针。但可以存在变量里传递。

类型

Go|C/C++
-|-
`C.char, C.uint, etc.`|`char, unsigned int, etc.`
`C.size_t`|`size_t`
`unsafe.Pointer`|`void*`
`x._type` (reserved keyword)|`x.type`
`C.sturct_S`|`struct S`
`C.enum_E`|`enum E`
`C.union_U`|`union U`
`n, err := C.sqrt(-1)`|`n = sqrt(-1); err = errno`
`C.f(&C.x[0])` (array arg)|`f(x)`
`nil`|`NULL`

一些转string换函数(复制数据)，注意使用完调用`C.free(unsafe.Pointer(p))`(stdlib.h)释放内存。
```
// Go string to C string
func C.CString(string) *C.char

// C string to Go string
func C.GoString(*C.char) string

// C string, length to Go string
func C.GoStringN(*C.char, C.int) string

// C pointer, length to Go []byte
func C.GoBytes(unsafe.Pointer, C.int) []byte
```

### Go->C
使用`export`导出函数。

```
// export MyFunction
func MyFunction(arg1, arg2 int, arg3 string) int64 {...}
```
-> 在`_cgo_export.h`头文件中：
```
extern int64 MyFunction(int arg1, int arg2, GoString arg3);
```

## Reference
https://golang.org/ref/spec
http://godoc.org/
https://github.com/golang/go/wiki

</xmp>
<script src="js/strapdown.js"></script>
</html>
