<!DOCTYPE html>
<html>
<title>Go</title>
<xmp theme="readable" style="display:none;">
[http://golang.org](http://golang.org) | v1.5

## 准备
### [下载安装](http://golang.org/doc/install)

下载安装包，并解压到安装路径(如`$HOME/go`)，最后配置环境变量。
```
export GOROOT=$HOME/go
export PATH=$PATH:$GOROOT/bin
```

### [环境配置](http://golang.org/doc/code.html)
工作区：包含src, pkg, bin目录。
项目一般都是单独git目录在src下，编译`go build`出来的库文件和可执行文件安装`go install`在pkg，bin下。
设置工作区环境变量：
```
export GOPATH=$HOME/go_ws
export PATH=$PATH:$GOPATH/bin
```
安装一个包或可执行文件都会自动安装其依赖的包。如果有源文件import了一个repo URL，运行`go get`会自动下载编译和安装。
可执行文件和它所依赖的包都是静态链接在一起的。


### [工具集](http://golang.org/doc/cmd)
编译并直接运行：`go run test.go`
清除src目录下build生成的临时对象文件：`go clean`

交叉编译：
如在mac上：`GOOS=linux GOARCH=amd64 go build`


### 开发辅助工具
用[vim-go](https://github.com/fatih/vim-go)的`:GoInstallBinaries`命令安装或`go get`安装到workspace的bin下

github.com:
[godef](https://github.com/rogpeppe/godef)
[gotags](https://github.com/jstemmer/gotags)
[gocode](https://github.com/nsf/gocode)
[errcheck](https://github.com/kisielk/errcheck)
[golint](https://github.com/golang/lint)

https://go.googlesource.com/tools/
goimports
oracle
gorename

## Basics
源文件以UTF8编码。
语句以分号结尾，一个语句时通常省略，全局域中以及括号后边也不需要。
圆括号通常只用在参数列表中。
花括号的位置在一行末尾。（gofmt工具可以用来格式化代码风格）
标识: 数字，字母，下划线。
注释: `/* */`，`//`
命名：camelCasing风格。

## 基本类型
数字: int, int8/16/32/64, uint, uint8/16/32/64, float32/64, byte(unit8), rune(int32, 代表一个Unicode码), uintptr, complex64/128。支持八进制(0)，十六进制(0x)及科学记数法。
布尔(bool): true, false (预定义常量)
字符串(string):

* 默认空串(`""`)。不以0结尾。
* 可复制但不可修改其中字符，要修改必须先转为`[]byte`, `[]rune`再转回来并会造成复制。下标访问其中的字符。
* `+`连接字符串。内部是UTF8的字节数组，可以用slice相关的操作。
* 16进制: `"\xFF"    // 1 byte`
* Unicode: `"\u00FF"  // 1 unicode char, 2 bytes of UTF-8`
* Raw:
```
`\n\.abc\t\` 相当于 "\\n\\.abc\\t\\"
```

指针：

* 默认值`nil`
* 有指针(`*Type`)及指针的指针(`**Type`)，但没有指针算术。
* 用`&`取得变量的指针，一律用`.`访问目标。
* 函数中可以返回局部变量的指针。

类型转换

* 转换只适用于几种简单的情况：转换整数(int)到去其他的精度和大小，整数(int)与浮点数(float)的转换
* 没有隐式转换
* 显式转换T(v)：
```
uint8(int_var)   // truncate to size
int(float_var)   // truncate fraction
float64(int_var) // convert to float
string(0x1234)          // == "\u1234"
string(array_of_bytes)  // bytes -> bytes
string(array_of_ints)   // ints -> Unicode/UTF-8
```

操作符优先级：`* / % << >> & &^（位清除）`，`+ - | ^（异或）`，`== != < <= > >=`，`<-（通信）`，`&&`，`||`。


## 变量常量
var(变量): 必须有类型和初始化表达式之一。
未初始化的变量自动为0, 指针和引用为nil。
不用的变量可以使用`_`。
`:=`缩写声明并初始化变量，只可以在函数中使用。
未被使用的局部非常变量或导入的包被认为是个错误。
多重赋值的时候，先计算等号右边的表达式，再进行赋值（都是从左到右的顺序）。
```
var i int
var j = 365.245 // 自动推导类型
var a, b int = 1, 2 // a,b都是int
v := value // 省略var的简写
a, b, c, d := 1, 2.0, "three", FOUR

// 初始化表
var (
    i int;
    j = 356.245; // 分号可省
    k int = 0;
    l, m uint64 = 1, 2;
    billion int64 = 1e9;
    inter, floater, stringer = 1, 2.0, "hi"
)
```

`const`(常量): 必须有编译期确定初始化表达式，类型说明可省。
```
// 枚举（只可以此类型自己或常量匹配）
type Weekday int
const (
    Monday Weekday = iota
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)

const (
    a = "xyz"
    b            // 同上
)

// 使用iota自增长counter
const (
    loc0, bit0 uint32 = iota, 1<<iota;  // 0, 1
    loc1, bit1;                         // 1, 2 重复上一个表达式
    loc2, bit2;                         // 2, 4
)
```

`type`: 给一个匿名类型（一般是复合类型，如`[]int`, `map[int]int`, `struct {}`, `func() {}`）起个名字（命名！简单区别：命名类型只含有标识没有其它符号）或一个命名类型起个别名，类似C里的typedef，但不完全一样：

* 如果两个类型的变量都是命名类型，即使底层一样也不能通用。
* 如果两个类型的变量其中有一个是匿名类型，如果底层一样则可以通用。

```
type Point struct {
    x, y, z float;
    name string
}
type Operator func(a, b int) int
type ArrayOfIntPointers []*int
```

赋值，可以多个变量一起
```
a = b
x, y, z = f1(), f2(), f3()
a, b = b, a
nbytes, error := Write(buf)
```

`new` 是一个函数，分配了一个零初始化的类型值，返回指向它的指针，没有delete。
```
var p *Point = new(Point) // 或 &Point{}
v := new(int)   // v has type *int
```

`make`

* 对于引用语义的复杂类型(slice, map, channel)用make来初始化引用（分配内存和初始化结构）。
* 未初始化的引用为nil, 如: `var ar []int`, `var m map[string]int`, `var chan int`
* 字面定义`ar := []int {}` 和 `ar := make([]int)`
* 字面定义`m := map[string]int {}` 和 `m := make(map[string]int)`

`++`/`--` 是语句不是表达式，只能后置使用。

## 控制结构
`if`: 可以有一个简单的语句（初始化变量的作用域仅在if/else内），也可以什么也没有表示true(switch同)
其他类型不能自动转为bool，因此不能直接用于条件语句。
不支持三元操作`x > y ? x : y`。没有逗号操作符。
```
if v := f(); v < 10 {
    fmt.Printf("%d less than 10\n", v)
} else {
    fmt.Printf("%d not less than 10", v)
}
```

`for`: 表示循环(没有while)
```
for i := 0; i < 10; i++ { ... }
for i < 10 { ... } // while
for { fmt.Printf("Mine! ") } // endless loop
for key, value := range m { // m is map, 也可只取key，对于array和slice, 返回index及value
    fmt.Printf("key %s, value %g\n", key, value)
}
s := "[\u00ff\u754c]";
for i, c := range s { // 对于string，按照rune类型迭代
    fmt.Printf("%d:%c ", i, c)  // 打印 0:[ 1:ÿ 3:界 6:]
}
for range s {  } // iterate only
```
range会复制一份对象出来迭代，尽量使用引用类型。

`switch`: 任意类型，除非以`fallthrough`语句结束并进入下一个分支，否则分支会自动终止，一个case可以带多个值
```
a, b := x[i], y[j];
switch { // true
case a < b:  return -1
case a == b: return 0
case a > b:  return 1
}
```

`break`(可用于for/switch/select), `continue`(可用于for): 后面可以接一个label(goto)

## 复杂类型
### Array
声明: `var ar [3]int`, 长度: `len(ar)`
按值传递，但可以用指针避免复制(更多的是使用slice)。
初始化
```
[3]int { 1, 2, 3 }
[10]int { 1, 2, 3 } // 其它为0
[...]int { 1, 2, 3 } // 自己计算长度
[10]int { 2:1, 3:1, 5:1, 7:1 } // 个别赋值
[...][2]int {{1,2}, {3,4}, {5,6}} // 2维数组
```

### Slice
Slice是一个引用类型，是对一个Array的部分引用。
声明: `var a []int`, 不指定长度。
`len()`可以取得长度，而`cap()`则返回slice的容量(默认一直至被引用数组结尾的大小)。基于slice创建的slice不能超过cap大小。
string也可以被slice。不可修改。
初始化，赋值
```
a = ar[7:9] // 长度为2, [7,9)
a2 = ar[7:9:10] // 指定容量为3, [7,10)，下标都是指索引值
a3 = &ar  // same as a = ar[0:len(ar)] or ar[:]
header, data := buf[0:n], buf[n:len(buf)] // split
var slice = []int{ 1,2,3,4,5 } // 字面定义，可以个别赋值，自动创建底层数组
var s100 = make([]int, 100) // slice: 100 ints, cap = len
var sl = make([]int, 0, 100)  // len 0, cap 100
s1 = nil // clear
data := [][]int {[]int{1,2}, []int{3,4}} // slice of slice
```

`append(slice, value)`: 在slice结尾添加数据，返回新slice。如果未超出cap限制，会修改原数组，否则会复制并重新分配底层数组，且cap变为原来的2倍。
`copy(dest, src)`: 复制一个slice到另一个，直到其中一个结尾。


### Map
Map是哈希表，引用类型。
声明: `var m map[string] float // key:string, value:float`, 长度: `len(m)`返回key的个数
初始化，赋值
```
m = map[string]float { "1":1, "pi":3.1415 } // 字面定义
m = map[Point]string {{1,2} : "foo", {5,6} : "bar"}
m = make(map[string]float, 500) // len为0，500类似cap，cap不可作用于map
var m1 map[string]float = m // m1 and m now refer to same map
```
访问元素
```
one   := m["1"] // 取值，会复制一份出来
crash := m["not present"]  // 0
m["2"] = 2
v, ok := m[x] // the "comma ok" form, 测试是否有值
delete(m, x)   // deletes entry for x，若不存在不会出错
for key, value := range m { ... } // 迭代，顺序不固定，其中可以有删除操作
```

### Struct
Struct是值类型，声明: `var p struct { x, y float }`
可用`-`表示占位字段。成员可以是自身类型的指针。
`var pp *Point = new(Point); pp.x = 1; pp.y = 2 // 没有"->"，统一用"."访问成员，或(*pp).x`
初始化，赋值:
```
type Point struct { x, y float };
p = Point{ 7.2, 8.4 } // 顺序初始化必须包括所有成员
p = Point{ y:8.4, x:7.2 }
pp := &Point{ 23.4, -1 }   // idiomatic
```
可以为字段定义一个标签（属于类型的一部分），用于反射读取。`var x struct {pos int "position"}`
如果一个struct成员开头大写，则表示对包外可见。
匿名域：如果一个struct包含一个没有命名的变量，则用它的类型名字命名（同时用匿名类型及其指针类型会同名）。`type B struct {string}; fmt.Println(b.string);`
如果成员是个匿名struct，则还可以平展开，就像自己有这样的成员，但外面的名字会具有高优先级。同级不能有相同名字的成员。（类似继承）
```
type B struct { a, b int }
type D struct { B; b float }
var d D;
fmt.Println(d.a)
fmt.Println(d.b)
fmt.Println(d.B.b)
```
同一包内的struct可以使用另一个包内struct的域及方法（包内全可见）。

### 比较
只有Struct, Array可以进行`==`, `!=`比较，逐个元素比较。
Slice, Map, Function都只可以和nil比较。


## 函数及接口
### function
first class, 定义:
```
func MySqrt(f float) (v float, ok bool) {
    if f >= 0 { v,ok = math.Sqrt(f),true }
    return // implicit
}
```
可以指定每个参数的名字或者不指定任何参数名字，不能只指定部分函数参数的名字。
如果是相邻的参数是相同的类型，也可以统一指定类型。
如果命名了返回值参数（局部变量），return可以不带参数返回当前值（不被其他同名变量遮盖(shadowed)的情况下）。
不支持默认参数。
多返回值可以直接作为函数调用的实参。

闭包：
```
func adder() (func(int) int) {
    var x int
    return func(delta int) int { // lambda
        x += delta
        return x
    }
}
var f = adder();
fmt.Print(f(1));
fmt.Print(f(20));
fmt.Print(f(300));
```
闭包以引用的方式使用外部变量。

可变参数：只能有一个，必须放在所有参数最后。类似slice的处理。
```
func foo(x int, y ...int) {
    for i, v := range y {
        x += v
    }
}

a := []int {1, 2, 3, 4}
foo(100, a...) // 展开slice
```

### method
可以把方法附加在本包内的任意非指针或接口类型上（不仅仅是struct，对内置类型要type改名一下），只要指明接收者即可（可以是值或指针，一般使用指针避免值传递）。
只有struct没有class，method是一种特殊的函数，不支持重载，接收者（相当于this）是方法签名的一部分。
Accessor方法命名惯例直接用属性名表示get，“set属性名”表示set。
```
type Point struct { x, y float64 }
// A method on *Point
func (p *Point) Abs() float64 {
    return math.Sqrt(p.x*p.x + p.y*p.y)
}
func (p Point) Swap() Point {
    p.x, p.y = p.y, p.x
    return p
}

p := &Point{ 3, 4 };
fmt.Print(p.Abs());  // will print 5
```

类型和它的方法必须在同一包内。
当一个匿名类型嵌入一个struct，它的所有方法也被“继承”。同名方法可以被此struct重载。
```
type Mutex struct { ... }
func (m *Mutex) Lock() { ... }
type Buffer struct {
    data [100]byte
    Mutex  // need not be first in Buffer
}
var buf = new(Buffer);
buf.Lock();  // == buf.Mutex.Lock()
```
如果为一个类型定义`String()`方法，则可以直接被`fmt.Print[ln]`打印使用。

method value & method expression：可以把method像函数一样赋值给其他变量
```
mv := p.Abs
mv() // 已绑定实例
me := (*Point).Abs
me(&p) // 传递实例
sv := p.Swap // 如果接收者以值传递会造成复制
se := Point.Swap
se2 := (*Point).Swap
se2(&p) // 只是改变签名，仍会复制
me2 := Point.Abs // compile error
```

### interface
一个interface是许多method的集合。接口命名惯以er为后缀，只有签名没有实现，没有数据字段，可以包含其他接口。
如果你的类型实现了一个和众所周知的类型具有相同含义的方法，那么就使用相同的名字和签名；如Read，Write，Close，Flush，String等。
定义:
```
type EmptyInterface interface { }
type AbsInterface interface {
    Abs() float32  // receiver is implied
}
```

任何实现了其接口的类型的变量都可以赋值给interface变量（隐式接口，无需声明），它存储了receiver的值（只读复制品，如果要修改成员变量必须传递指针类型）以及一张method表。
```
type Vector struct {
    a []EmptyInterface // 可以放任意类型的vector
}
```
将接口类型转回原类型：`interface_value.(type_to_extract)`，在运行期检测（使用comma,ok或switch检测，否则会panic）。
接口之间也可以互相转换，取决于底层所包含的类型能否转换，超集可以转换为子集。
```
// 检查是否实现了String接口
type Stringer interface { String() string }
if sv, ok := v.(Stringer); ok {
    fmt.Printf("implements String(): %s\n", sv.String()); // note: sv not v
}

// 习惯在switch里重用一个名字，实际上是在每个case里声名一个新的变量，其具有相同的名字，但是不同的类型。
switch v := v.(type) {
case Stringer:
    ...
}
```
Print等利用反射机制("reflect" package)知道其参数类型，也可以用`%v`表示任意类型格式。

接口一般只针对method，如果一般函数要实现接口：
```
type ToString func() string
func (this ToString) String() string {
    return this()
}

var s Stringer = ToString(func() string { return "test" })
s.String()
```


## Concurrency
> [Do not communicate by sharing memory; instead, share memory by communicating.](http://blog.golang.org/share-memory-by-communicating)

### Goroutine
goroutine指在同一地址空间内并发执行的函数，非常廉价和轻量级。执行: `go f()`
`go`也可以用于启动新定义的内部函数（闭包）为goroutines。
可以在不同的处理器上并发运行，而且共享内存。(gccgo目前是使用pthread实现的)
goroutine的默认堆栈大小8KB，最大1GB（64bit），250M（32bit）。

### 调度
`runtime.GOMAXPROCS(n)` 指定最多可以并行执行的goroutine数目（实际系统线程数可以大于PROC数，默认最大10000），默认为CPU核心线程数。`runtime.NumGoroutine()`返回当前存在的goroutine的数目。
`runtime.Goexit()`终止当前goroutine的执行（defer仍起作用）。
`runtime.Gosched()`暂停当前goroutine，等待被再次调度（类似协程里的yield）。
goroutine如果内部调用了非内联函数（内联函数如lambda），会在函数入口采用抢占式调度。
进程退出时并不等待goroutine结束，可以用`sync.WaitGroup`等待。

关于goroutine的调度，可以看[go-scheduler](http://morsmachine.dk/go-scheduler) （[中文](http://mikespook.com/2013/07/%E7%BF%BB%E8%AF%91go-%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8/)）, [netpoller](http://morsmachine.dk/netpoller)，以及[原始设计文档](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw)。

### Channel
声明: `chan element_type`，创建: `var c = make(chan int)`
channel是引用类型，内部同步，并发安全。
`len`返回未被读取的缓冲元素个数，`cap`返回缓冲区大小。
```
var c = make(chan int)
c <- 1   // send
i := <-c // receive
```
channel是同步的，发送要等待接收，接收要等待发送。只有一个goroutine的情况下(main)，等待会抛出死锁异常。
可以用make指定buffer: `make(chan int, 50)`, buffer只是channel的属性不是类型，默认大小为0（无缓冲）。
range会从channel迭代数据，直到channel关闭。
```
func suck(ch chan int) {
    go func() {
        for v := range ch { fmt.Println(v) }
    }()
}
```

关闭channel: `close()`, 测试: `closed()`。
只有发送者才能关闭channel，而不是接收者。向一个已经关闭的channel发送数据会引起panic，从一个已经关闭的channel接收数据为0/nil和false: `v, ok = <-c`。
默认channel是双向的，也可以转换为指定的方向：`var recv_only <-chan int;  var send_only chan<- int;` 可以用双向channel赋值给单向的，反之不可，单向不同方向也不可。

`select`

* select的case必须是channel操作。
* 如果每个条件都阻塞，select就会阻塞（如果有default则进入操作）。
* 如果多个条件满足，则随机选择一个执行。
* `select {}`阻塞goroutine。
```
c1 := make(chan int)
c2 := make(chan int)
select {
case v := <-c1:
    fmt.Printf("received %d from c1\n", v)
case v := <-c2:
    fmt.Printf("received %d from c2\n", v)
case t := <-time.After(1 * time.Second):  // time.After 返回一个阻塞的chan，时间到后变为可读，返回当前时间
    fmt.Printf("received timeout, current time: %s\n", t)
default:
    time.Sleep(10000)
}
```

`chanOfChans := make(chan chan int)`


## 错误处理
内置的error接口（还有`errors`包），当用`fmt`包的多种不同的打印函数输出一个`error`时，会自动的调用`Error`方法。
```
type error interface {
    Error() string
}
```
`error.New`：创建error对象。

`defer`

* defer后面的语句在函数return时候调用（最终返回之前，(如果有)计算return表达式之后）。
* defer函数的参数值在defer的定义点确定并复制（如果需要实时的值，可以使用闭包）。
* 可以有多个defer，执行时按LIFO顺序，即使中间发生panic也都保证后续执行。
* defer性能不高，不要在循环内使用。
* 如果要在语句块中使用，可以写成lambda代替语句块。

`panic`: 类似抛出异常，并终止程序。参数类型为`interface{}`，可接受任何参数。
`recover`: 终止panic展开，返回最后一个的panic的参数，只能在defer函数中**直接**调用。


## Packages
每个go的源文件第一行都必须是`package xxx`

* 可执行文件包名`package main`(在单独目录)，内含一个main函数。
* 库文件包名(一般和所在目录名相同，包里的每个源文件都必须有相同的名字): `package fmt`

导入包: `import myfmt "path/to/fmt"  // use the name myfmt，相对src的路径`
导入本地包：`import "./myfmt" // 仅对go run有效`
导入内部包（内部包只能包自己可以用，`go run`不受此限制）。`import "myfmt/internal/util"`
不导入仅初始化：`import _ "fmt"`
全部导入（无须以包名开头使用）：`import . "fmt"`
导入多个包：
```
import (
    "fmt"
    "math"
)
```
在一个包内部，所有全局变量函数等对于包的源文件可见。对于包的使用者来说，只有开头字母大写的可见。
全局变量的初始化：声明的时候初始化；使用`init()`函数，在包所有全局变量初始化后执行`main.main()`之前执行。初始化总是单线程的，根据包的依赖顺序执行。
一般来说，一个目录一个包，作为一个单元一起编译，忽略测试文件。
按照惯例，包名使用小写，且为一个单词的名字；不要使用下划线或者混合大小写。

### Vendoring
实验性功能，默认不启用。启用：`GO15VENDOREXPERIMENT=1`
在src下如果有形如`d/vendor`的目录（一般vendor不直接放在src下），那么在`d`及其子目录下面build的时候import路径也会在`d/vendor`下面查找。如果有同名冲突，则选择路径长的。


## [Testing](http://golang.org/pkg/testing/)
### Test
* 命令: `go test`, 运行所有测试文件。
* 文件名: `*_test.go`
* 用例函数签名: `func TestXxxx(t *testing.T)`，如果调用了`t.Error`, `t.Fail`则测试失败。
* 测试工具包: `import "testing"`, 支持logging, error reporting...
* 重写`TestMain`以进行初始化/清理工作。
```
func TestMain(m *testing.M) {
    // do setup
    code := m.Run()
    // do teardown
    os.Exit(code)
}
```

### Benchmarks
`go test -bench`

### Example
示例函数命名(suffix可选)：

* package: Example_suffix
* func: ExampleFuncA_suffix
* type: ExampleTypeA_suffix
* method: ExampleTypeA_MethodA_suffix

通过stdout输出来判断结果。(内置函数`print/println`输出到stderr)

## [Debuging](https://golang.org/pkg/runtime/debug/)
查看运行状态：`GOMAXPROCS=2 GODEBUG="schedtrace=1000, scheddetail=1" ./test.out`
查看go相关环境变量：`go env`
查看import及依赖：`go list -json`
竞态检测：`go run/build/test -race`

[GDB](https://golang.org/doc/gdb): v7.1+

* debug: 禁止内联和优化 `-gcflags "-N -l"`。
* release: 删除调试信息和符号表 `-ldflags "-w -s"`。

## [Coverage](http://golang.org/cmd/cover/)
## [Profiling](http://golang.org/cmd/pprof/)
https://golang.org/pkg/runtime/pprof/

## [Documentation](http://godoc.org/golang.org/x/tools/cmd/godoc)
规范化注释格式，任何直接属于顶层声明的注释都会可被`godoc`提取为文档注释（除了package main）。

* 要和被注释的成员相邻
* 用空行分隔段落
* 缩进表示格式化文本（代码片段）
* bug: `// BUG(author): overflow`
* 每个程序包都应该有一个包注释，一个位于package语句之前的注释（只需要出现在一个文件中）。
* 每一个被导出的（大写的）名字，都应该有一个注释。
* 注释的第一句话应该为一条概括，并且使用被声明的名字作为开头。`// FuncName does ...`

## [CodingStyle](http://golang.org/cmd/gofmt/)

## Reference
http://godoc.org/

</xmp>
<script src="js/strapdown.js"></script>
</html>
